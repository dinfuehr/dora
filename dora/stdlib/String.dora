@internal class String {
  fun equals(rhs: String) -> Bool {
    var i = 0;

    if self.length() != rhs.length() {
        return false;
    }

    let len = self.length();

    while i < len {
        if self.getByte(i) != rhs.getByte(i) {
            return false;
        }

        i = i + 1;
    }

    return true;
  }

  fun toString() -> String = self;

  @internal fun compareTo(rhs: String) -> Int;

  @internal fun length() -> Int;
  @internal fun toIntOrThrow() throws -> Int;
  fun toInt() -> Option[Int] {
    do {
      return some[Int](try self.toIntOrThrow());
    } catch e: Exception {
      return none[Int]();
    }
  }
  @internal fun toLongOrThrow() throws -> Long;
  fun toLong() -> Option[Long] {
    do {
      return some[Long](try self.toLongOrThrow());
    } catch e: Exception {
      return none[Long]();
    }
  }

  @internal fun plus(rhs: String) -> String;

  @internal fun getByte(idx: Int) -> Byte;
  @internal fun clone() -> String;

  @internal @static fun fromBytesPartOrNull(val: Array[Byte], offset: Int, len: Int) throws -> String;
  @internal @static fun fromStringPartOrNull(val: String, offset: Int, len: Int) throws -> String;

  @static fun fromBytesPart(val: Array[Byte], offset: Int, len: Int) -> Option[String] {
    do {
      return some[String](try String::fromBytesPartOrNull(val, offset, len));
    } catch e: Exception {
      return none[String]();
    }
  }

  @static fun fromBytes(val: Array[Byte]) -> Option[String] {
    do {
      return some[String](try String::fromBytesPartOrNull(val, 0, val.length()));
    } catch e: Exception {
      return none[String]();
    }
  }

  @static fun fromStringPart(val: String, offset: Int, len: Int) -> Option[String] {
    do {
      return some[String](try String::fromStringPartOrNull(val, offset, len));
    } catch e: Exception {
      return none[String]();
    }
  }

  @static fun fromString(val: String) -> String = val.clone();

  @static fun binary(var data: Long) -> String {
    if data == 0L { return "0"; }
    let array = Array[Byte](64);
    var at = array.length();
    while data != 0L {
      array(at - 1) = ('0'.toLong() + (data & 1L)).toByte();
      data = data.shiftRight(1);
      at = at - 1;
    }
    return String::fromBytesPart(array, at, array.length() - at + 1).unwrap();
  }

  @static fun hex(var data: Long) -> String {
    if data == 0L { return "0"; }
    let array = Array[Byte](16);
    var at = array.length();
    array(at) = '0'.toInt().toByte();
    while (data != 0L) {
      let digit = (data & 0xFL).toInt();

      if digit < 10 {
        array(at - 1) = ('0'.toInt() + digit).toByte();
      } else {
        array(at - 1) = ('A'.toInt() + digit - 10).toByte();
      }

      data = data.shiftRight(4);
      at = at - 1;
    }
    return String::fromBytesPart(array, at, array.length() - at + 1).unwrap();
  }

  fun isEmpty() -> Bool = self.length() == 0;

  fun codePoints() -> CodepointIterator = CodepointIterator(self, 0);
}
