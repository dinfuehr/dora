use std::traits::{Default, Equals, Hash, Iterator, Zero};
use std::string::Stringable;
use std::fatalError;

@pub @internal struct Unit

@pub @internal struct Bool

impl Bool {
  @pub @internal fun toInt32(): Int32;
  @pub @internal fun toInt64(): Int64;

  @pub fun hash(): Int32 = self.toInt32();

  @pub fun toString(): String = if self { "true" } else { "false" };
  @pub fun toStringBinary(): String = if self { "1" } else { "0" };
  @pub fun toStringHex(): String = if self { "1" } else { "0" };

  @pub @internal fun equals(rhs: Bool): Bool;
  @pub @internal fun not(): Bool;
}

@pub @internal struct Int32

impl Int32 {
  @pub @internal fun toUInt8(): UInt8;
  @pub fun toChar(): Option[Char] {
    if self >= 0i32 && self <= 0x10FFFFi32 && (self < 0xD800i32 || self > 0xDFFFi32) {
      Option[Char]::Some(self.toCharUnchecked())
    } else {
      Option[Char]::None
    }
  }
  @pub @internal fun toCharUnchecked(): Char;
  @pub @internal fun toInt64(): Int64;
  @pub @internal fun toString(): String;

  @pub fun toStringBinary(): String = String::binary(self.toInt64() & 0xFFFFFFFFi64);
  @pub fun toStringHex(): String = String::hex(self.toInt64() & 0xFFFFFFFFi64);

  @pub @internal fun toFloat32(): Float32;
  @pub @internal fun toFloat64(): Float64;

  @pub @internal fun asFloat32(): Float32;

  @pub @internal fun equals(rhs: Int32): Bool;
  @pub @internal fun compareTo(rhs: Int32): Int32;

  @pub @internal fun plus(rhs: Int32): Int32;
  @pub @internal fun minus(rhs: Int32): Int32;
  @pub @internal fun times(rhs: Int32): Int32;
  @pub @internal fun div(rhs: Int32): Int32;
  @pub @internal fun remainder(rhs: Int32): Int32;

  @pub @internal fun wrappingAdd(rhs: Int32): Int32;
  @pub @internal fun wrappingSub(rhs: Int32): Int32;
  @pub @internal fun wrappingMul(rhs: Int32): Int32;

  @pub @internal fun bitwiseOr(rhs: Int32): Int32;
  @pub @internal fun bitwiseAnd(rhs: Int32): Int32;
  @pub @internal fun bitwiseXor(rhs: Int32): Int32;

  @pub @internal fun shiftLeft(by: Int32): Int32;
  @pub @internal fun shiftRightSigned(by: Int32): Int32;
  @pub @internal fun shiftRight(by: Int32): Int32;

  @pub @internal fun rotateLeft(by: Int32): Int32;
  @pub @internal fun rotateRight(by: Int32): Int32;

  @pub @internal fun unaryPlus(): Int32;
  @pub @internal fun unaryMinus(): Int32;
  @pub @internal fun not(): Int32;
  @pub fun abs(): Int32 {
    let s = self.shiftRightSigned(31i32);
    return self.bitwiseXor(s).wrappingSub(s);
  }

  @pub @internal fun countZeroBits(): Int32 = self.not().countOneBits();
  @pub @internal fun countOneBits(): Int32 {
    let mut x = self;
    let mut c = 0i32;
    while (x != 0i32) {
      c = c + 1i32;
      x = x.bitwiseAnd(x - 1i32);
    }
    return c;
  }
  @pub @internal fun countZeroBitsLeading(): Int32 {
    if self == 0i32 {
      return Int32::bits();
    }
    let mut t = 1i32.shiftLeft(Int32::bits() - 1i32);
    let mut r = 0i32;
    while self.bitwiseAnd(t) == 0i32 {
      t = t.shiftRight(1i32);
      r = r + 1i32;
    }
    return r;
  }
  @pub @internal fun countOneBitsLeading(): Int32 = self.not().countZeroBitsLeading();
  @pub @internal fun countZeroBitsTrailing(): Int32 {
    if self == 0i32 {
      return Int32::bits();
    }
    let mut t = 1i32;
    let mut r = 0i32;
    while self.bitwiseAnd(t) == 0i32 {
      t = t.shiftLeft(1i32);
      r = r + 1i32;
    }
    return r;
  }
  @pub @internal fun countOneBitsTrailing(): Int32 = self.not().countZeroBitsTrailing();

  @pub fun hash(): Int32 = self;

  @pub @static fun bits(): Int32 = 32i32;
  @pub @static fun bytes(): Int32 = 4i32;

  @pub @static fun maxValue(): Int32 = 2147483647i32;
  @pub @static fun minValue(): Int32 = -2147483648i32;

  @pub @static fun min(lhs: Int32, rhs: Int32): Int32 = if lhs < rhs { lhs } else { rhs };
  @pub @static fun max(lhs: Int32, rhs: Int32): Int32 = if lhs < rhs { rhs } else { lhs };
}

@pub class Int32Range(lower: Int32, upper: Int32)

impl Int32Range {
  @pub fun makeIterator(): Int32RangeIter {
    return Int32RangeIter(self, 0i32);
  }
}

@pub fun range(lower: Int32, upper: Int32): Int32Range = Int32Range(lower, upper);

class Int32RangeIter {
  range: Int32Range,
  value: Int32,
}

impl Iterator for Int32RangeIter {
  fun next(): Option[Int32] {
    if self.value < self.range.upper {
      let cur = self.value;
      self.value = cur + 1i32;
      Some[Int32](cur)
    } else {
      None[Int32]
    }
  }
}

@pub @internal struct Char

impl Char {
  @pub @internal fun toInt32(): Int32;
  @pub @internal fun toInt64(): Int64;
  @pub @internal fun toString(): String;

  @pub @internal fun equals(rhs: Char): Bool;
  @pub @internal fun compareTo(rhs: Char): Int32;

  @pub fun hash(): Int32 = self.toInt32();

  @pub fun encodeUtf8(bytes: Array[UInt8], offset: Int64): Unit {
    let val = self.toInt32();

    if val < 0x80i32 {
      bytes.set(offset, val.toUInt8());
    } else if val < 0x800i32 {
      bytes.set(offset, (0xC0i32 | (val.shiftRightSigned(6i32) & 0x1Fi32)).toUInt8());
      bytes.set(offset+1i64, (0x80i32 | (val & 0x3Fi32)).toUInt8());
    } else if val < 0x10000i32 {
      bytes.set(offset, (0xE0i32 | (val.shiftRightSigned(12i32) & 0x0Fi32)).toUInt8());
      bytes.set(offset+1i64, (0x80i32 | (val.shiftRightSigned(6i32) & 0x3Fi32)).toUInt8());
      bytes.set(offset+2i64, (0x80i32 | (val & 0x3Fi32)).toUInt8());
    } else {
      bytes.set(offset, (0xF0i32 | (val.shiftRightSigned(18i32) & 0x07i32)).toUInt8());
      bytes.set(offset+1i64, (0x80i32 | (val.shiftRightSigned(12i32) & 0x3Fi32)).toUInt8());
      bytes.set(offset+2i64, (0x80i32 | (val.shiftRightSigned(6i32) & 0x3Fi32)).toUInt8());
      bytes.set(offset+3i64, (0x80i32 | (val & 0x3Fi32)).toUInt8());
    }
  }

  @pub fun lenUtf8(): Int32 {
    let val = self.toInt32();

    if val < 0x80i32 {
      return 1i32;
    } else if val < 0x800i32 {
      return 2i32;
    } else if val < 0x10000i32 {
      return 3i32;
    } else {
      return 4i32;
    }
  }
}

@pub @internal struct Int64

impl Int64 {
  @pub @internal fun toUInt8(): UInt8;
  @pub fun toChar(): Option[Char] {
    if self >= 0i64 && self <= 0x10FFFFi64 && (self < 0xD800i64 || self > 0xDFFFi64) {
      Option[Char]::Some(self.toCharUnchecked())
    } else {
      Option[Char]::None
    }
  }
  @pub @internal fun toCharUnchecked(): Char;
  @pub @internal fun toInt32(): Int32;
  @pub @internal fun toString(): String;
  @pub fun toStringHex(): String { String::hex(self) }

  @pub fun toStringBinary(): String = String::binary(self);

  @pub @internal fun toFloat32(): Float32;
  @pub @internal fun toFloat64(): Float64;

  @pub @internal fun asFloat64(): Float64;

  @pub @internal fun equals(rhs: Int64): Bool;
  @pub @internal fun compareTo(rhs: Int64): Int32;

  @pub @internal fun plus(rhs: Int64): Int64;
  @pub @internal fun minus(rhs: Int64): Int64;
  @pub @internal fun times(rhs: Int64): Int64;
  @pub @internal fun div(rhs: Int64): Int64;
  @pub @internal fun remainder(rhs: Int64): Int64;

  @pub @internal fun wrappingAdd(rhs: Int64): Int64;
  @pub @internal fun wrappingSub(rhs: Int64): Int64;
  @pub @internal fun wrappingMul(rhs: Int64): Int64;

  @pub @internal fun bitwiseOr(rhs: Int64): Int64;
  @pub @internal fun bitwiseAnd(rhs: Int64): Int64;
  @pub @internal fun bitwiseXor(rhs: Int64): Int64;

  @pub @internal fun shiftLeft(by: Int32): Int64;
  @pub @internal fun shiftRightSigned(by: Int32): Int64;
  @pub @internal fun shiftRight(by: Int32): Int64;

  @pub @internal fun rotateLeft(by: Int32): Int64;
  @pub @internal fun rotateRight(by: Int32): Int64;

  @pub @internal fun unaryPlus(): Int64;
  @pub @internal fun unaryMinus(): Int64;
  @pub @internal fun not(): Int64;
  @pub fun abs(): Int64 {
    let s = self.shiftRightSigned(63i32);
    return self.bitwiseXor(s).wrappingSub(s);
  }

  @pub @internal fun countZeroBits(): Int32 = self.not().countOneBits();
  @pub @internal fun countOneBits(): Int32 {
    let mut x = self;
    let mut c = 0i32;
    while (x != 0i64) {
      c = c + 1i32;
      x = x.bitwiseAnd(x - 1i64);
    }
    return c;
  }
  @pub @internal fun countZeroBitsLeading(): Int32 {
    if self == 0i64 {
      return Int64::bits();
    }
    let mut t = 1i64.shiftLeft(Int64::bits() - 1i32);
    let mut r = 0i32;
    while (self.bitwiseAnd(t)) == 0i64 {
      t = t.shiftRight(1i32);
      r = r + 1i32;
    }
    return r;
  }
  @pub @internal fun countOneBitsLeading(): Int32 = self.not().countZeroBitsLeading();
  @pub @internal fun countZeroBitsTrailing(): Int32 {
    if self == 0i64 {
      return Int64::bits();
    }
    let mut t = 1i64;
    let mut r = 0i32;
    while (self.bitwiseAnd(t)) == 0i64 {
      t = t.shiftLeft(1i32);
      r = r + 1i32
    }
    return r;
  }
  @pub @internal fun countOneBitsTrailing(): Int32 = self.not().countZeroBitsTrailing();

  @pub fun hash(): Int32 = self.toInt32();

  @pub @static fun bits(): Int32 = 64i32;
  @pub @static fun bytes(): Int32 = 8i32;

  @pub @static fun maxValue(): Int64 = 9223372036854775807i64;
  @pub @static fun minValue(): Int64 = -9223372036854775808i64;

  @pub @static fun min(lhs: Int64, rhs: Int64): Int64 = if lhs < rhs { lhs } else { rhs };
  @pub @static fun max(lhs: Int64, rhs: Int64): Int64 = if lhs < rhs { rhs } else { lhs };
}

@pub @internal struct Float32

impl Float32 {
  @pub @internal fun toInt32(): Int32;
  @pub @internal fun toInt64(): Int64;
  @pub @internal fun toFloat64(): Float64;
  @pub @internal fun toString(): String;

  @pub @internal fun asInt32(): Int32;

  @pub @internal fun equals(rhs: Float32): Bool;
  @pub @internal fun compareTo(rhs: Float32): Int32;
  @pub @internal fun sortsAs(rhs: Float32): Int32 {
    let mut ix = self.asInt32();
    let mut iy = rhs.asInt32();

    let sx = ix.shiftRightSigned(31i32).shiftRight(1i32);
    let sy = iy.shiftRightSigned(31i32).shiftRight(1i32);

    ix = ix.bitwiseXor(sx);
    iy = iy.bitwiseXor(sy);

    if ix < iy { return -1i32; }
    if ix == iy { return 0i32; }
    return 1i32;
  }

  @pub @internal fun plus(rhs: Float32): Float32;
  @pub @internal fun minus(rhs: Float32): Float32;
  @pub @internal fun times(rhs: Float32): Float32;
  @pub @internal fun div(rhs: Float32): Float32;

  @pub @internal fun unaryPlus(): Float32;
  @pub @internal fun unaryMinus(): Float32;
  @pub @internal fun abs(): Float32;

  @pub @internal fun roundToZero(): Float32;
  @pub @internal fun roundUp(): Float32;
  @pub @internal fun roundDown(): Float32;
  @pub @internal fun roundHalfEven(): Float32;

  @pub @internal fun isNan(): Bool;
  @pub @internal fun sqrt(): Float32;

  @pub fun hash(): Int32 = self.asInt32();

  // should be lets, not funs
  @pub @static fun bits(): Int32 = 32i32;
  @pub @static fun bytes(): Int32 = 4i32;
  @pub @static fun infinityPositive(): Float32 = 0x7f800000i32.asFloat32();
  @pub @static fun infinityNegative(): Float32 = 0xff800000i32.asFloat32();
  @pub @static fun notANumber(): Float32 = 0x7fC00000i32.asFloat32();
}

@pub @internal struct Float64

impl Float64 {
  @pub @internal fun toInt32(): Int32;
  @pub @internal fun toInt64(): Int64;
  @pub @internal fun toFloat32(): Float32;
  @pub @internal fun toString(): String;

  @pub @internal fun asInt64(): Int64;

  @pub @internal fun equals(rhs: Float64): Bool;
  @pub @internal fun compareTo(rhs: Float64): Int32;
  @pub @internal fun sortsAs(rhs: Float64): Int32 {
    let mut ix = self.asInt64();
    let mut iy = rhs.asInt64();

    let sx = ix.shiftRightSigned(63i32).shiftRight(1i32);
    let sy = iy.shiftRightSigned(63i32).shiftRight(1i32);

    ix = ix.bitwiseXor(sx);
    iy = iy.bitwiseXor(sy);

    if ix < iy { return -1i32; }
    if ix == iy { return 0i32; }
    return 1i32;
  }

  @pub @internal fun plus(rhs: Float64): Float64;
  @pub @internal fun minus(rhs: Float64): Float64;
  @pub @internal fun times(rhs: Float64): Float64;
  @pub @internal fun div(rhs: Float64): Float64;

  @pub @internal fun unaryPlus(): Float64;
  @pub @internal fun unaryMinus(): Float64;
  @pub @internal fun abs(): Float64;

  @pub @internal fun roundToZero(): Float64;
  @pub @internal fun roundUp(): Float64;
  @pub @internal fun roundDown(): Float64;
  @pub @internal fun roundHalfEven(): Float64;

  @pub @internal fun isNan(): Bool;
  @pub @internal fun sqrt(): Float64;

  @pub fun hash(): Int32 = self.asInt64().toInt32();

  // should be lets, not funs
  @pub @static fun bits(): Int32 = 64i32;
  @pub @static fun bytes(): Int32 = 8i32;
  @pub @static fun infinityPositive(): Float64 = 0x7ff0000000000000i64.asFloat64();
  @pub @static fun infinityNegative(): Float64 = 0xfff0000000000000i64.asFloat64();
  @pub @static fun notANumber(): Float64 = 0x7ff8000000000000i64.asFloat64();
}

@pub @internal struct UInt8

impl UInt8 {
  @pub @internal fun toChar(): Char;
  @pub @internal fun toInt32(): Int32;
  @pub @internal fun toInt64(): Int64;
  @pub @internal fun toString(): String;

  @pub fun toStringBinary(): String = String::binary(self.toInt64());
  @pub fun toStringHex(): String = String::hex(self.toInt64());

  @pub @internal fun equals(rhs: UInt8): Bool;
  @pub @internal fun compareTo(rhs: UInt8): Int32;

  @pub fun hash(): Int32 = self.toInt32();

  @pub @static fun bits(): Int32 = 8;
  @pub @static fun bytes(): Int32 = 1;

  @pub @static fun maxValue(): UInt8 = 255u8;
  @pub @static fun minValue(): UInt8 = 0u8;
}

@pub enum Option[T] {
  Some(T),
  None,
}

use Option::Some;
use Option::None;

impl[T] Option[T] {
  @pub fun isNone(): Bool {
    match self {
      Some(_) => false,
      None => true,
    }
  }

  @pub fun isSome(): Bool {
    match self {
      Some(_) => true,
      None => false,
    }
  }

  @pub fun getOrPanic(): T {
    match self {
      Some(value) => value,
      None => {
        fatalError("cannot unwrap None.");
        unreachable[T]()
      }
    }
  }

  @pub fun unwrapNone(): Unit {
    match self {
      Some(_) => {
        fatalError("cannot unwrap Some.");
      },
      None => (),
    }
  }

  @pub fun unwrapOr(alt: T): T {
    match self {
      Some(value) => value,
      None => alt,
    }
  }

  @pub fun has(val: T): Bool {
    match self {
      Some(actual) => actual === val,
      None => false,
    }
  }

  @pub fun all(fct: (T): Bool): Bool = match self {
    Some(val) => fct(val),
    None => true,
  };

  @pub fun any(fct: (T): Bool): Bool = match self {
    Some(val) => fct(val),
    None => false,
  };

  @pub fun or(alt: Option[T]): Option[T] = match self {
    Some(_) => self,
    None    => alt,
  };

  @pub fun each(fct: (T): Unit): Unit = match self {
    Some(val) => fct(val),
    None      => (),
  };

  @pub fun map[U](fct: (T): U): Option[U] = match self {
    Some(val) => Some[U](fct(val)),
    None      => None[U],
  };

  @pub fun flatMap[U](fct: (T): Option[U]): Option[U] = match self {
    Some(val) => fct(val),
    None      => None[U],
  };

  @pub fun retain(fct: (T): Bool): Option[T] = match self {
    Some(val) => if fct(val) { self } else { Option[T]::None },
    None      => self,
  };

  @pub fun reject(fct: (T): Bool): Option[T] = match self {
    Some(val) => if fct(val) { Option[T]::None } else { self },
    None      => self,
  };
}

impl[T] Option[Option[T]] {
  @pub fun flatten(): Option[T] = match self {
    Some(val) => val,
    None      => None[T],
  };
}

impl[T: Equals] Equals for Option[T] {
  @pub fun equals(rhs: Option[T]): Bool {
    if self.isSome() {
      if rhs.isSome() {
        let lhs = self.getOrPanic();
        let rhs = rhs.getOrPanic();
        lhs.equals(rhs)
      } else {
        false
      }
    } else {
      rhs.isNone()
    }
  }
}

impl[T: Equals] Option[T] {
  @pub fun contains(rhs: T): Bool = match self {
    Some(val) => val.equals(rhs),
    None      => false,
  };
}

impl[T: Hash] Hash for Option[T] {
  @pub fun hash(): Int32 = match self {
    Some(val) => 23i32.wrappingMul(val.hash()),
    None      => 31i32,
  };
}

impl[T: Stringable] Stringable for Option[T] {
  @pub fun toString(): String = match self {
    Some(value) => "Some(${value})",
    None        => "None",
  };
}

impl[T: Default] Option[T] {
  @pub fun getOrDefault(): T = match self {
    Some(val) => val,
    None      => T::default(),
  };
}

impl[T: Zero] Option[T] {
  @pub fun getOrZero(): T = match self {
    Some(val) => val,
    None      => T::zero(),
  };
}

@pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

use Result::Ok;
use Result::Err;

impl[T, E] Result[T, E] {
  @pub fun isOk(): Bool {
    match self {
      Ok(_) => true,
      Err(_) => false,
    }
  }

  @pub fun isErr(): Bool {
    match self {
      Ok(_) => false,
      Err(_) => true,
    }
  }

  @pub fun getOrPanic(): T {
    match self {
      Ok(value) => value,
      Err(_) => {
        fatalError("cannot unwrap Err.");
        unreachable[T]()
      }
    }
  }

  @pub fun getErrOrPanic(): E {
    match self {
      Ok(_) => {
        fatalError("cannot unwrap Ok.");
        unreachable[E]()
      },
      Err(value) => value,
    }
  }

  @pub fun has(val: T): Bool {
    match self {
      Ok(actual) => actual === val,
      Err(_) => false,
    }
  }

  @pub fun all(fct: (T): Bool): Bool = match self {
    Ok(val) => fct(val),
    Err(_)  => true,
  };

  @pub fun any(fct: (T): Bool): Bool = match self {
    Ok(val) => fct(val),
    Err(_)  => false,
  };

  @pub fun or(alt: Result[T, E]): Result[T, E] = match self {
    Ok(_)  => self,
    Err(_) => alt,
  };

  @pub fun each(fct: (T): Unit): Unit = match self {
    Ok(val) => fct(val),
    Err(_)  => (),
  };

  @pub fun map[U](fct: (T): U): Result[U, E] = match self {
    Ok(val)  => Ok[U, E](fct(val)),
    Err(err) => Err[U, E](err),
  };

  @pub fun flatMap[U](fct: (T): Result[U, E]): Result[U, E] = match self {
    Ok(val)  => fct(val),
    Err(err) => Err[U, E](err),
  };

  @pub fun retain(fct: (T): Bool, err: E): Result[T, E] = match self {
    Ok(val) => if fct(val) { self } else { Err[T, E](err) },
    Err(_)  => self,
  };

  @pub fun reject(fct: (T): Bool, err: E): Result[T, E] = match self {
    Ok(val) => if fct(val) { Err[T, E](err) } else { self },
    Err(_)  => self,
  };

  @pub fun swap(): Result[E, T] = match self {
    Ok(val) => Err[E, T](val),
    Err(err) => Ok[E, T](err),
  };

  @pub fun toOption(): Option[T] = match self {
    Ok(val) => Some[T](val),
    Err(_)  => None[T],
  };
}

impl[T: Equals, E] Result[T, E] {
  @pub fun contains(rhs: T): Bool = match self {
    Ok(val) => val.equals(rhs),
    Err(_)  => false,
  };
}

impl[T: Equals, E: Equals] Equals for Result[T, E] {
  @pub fun equals(rhs: Result[T, E]): Bool {
    if self.isOk() {
      if rhs.isOk() {
        let lhs = self.getOrPanic();
        let rhs = rhs.getOrPanic();
        lhs.equals(rhs)
      } else {
        false
      }
    } else {
      if rhs.isErr() {
        let lhs = self.getErrOrPanic();
        let rhs = rhs.getErrOrPanic();
        lhs.equals(rhs)
      } else {
        false
      }
    }
  }
}

impl[T: Hash, E: Hash] Hash for Result[T, E] {
  @pub fun hash(): Int32 = match self {
    Ok(val)  => 29i32.wrappingMul(val.hash()),
    Err(err) => 37i32.wrappingMul(err.hash()),
  };
}

impl[T: Stringable, E: Stringable] Stringable for Result[T, E] {
  @pub fun toString(): String = match self {
    Ok(val)  => "Ok(${val})",
    Err(err) => "Err(${err})",
  };
}

impl[T: Default, E] Result[T, E] {
  @pub fun getOrDefault(): T = match self {
    Ok(val) => val,
    Err(_)  => T::default(),
  };
}

impl[T, E: Default] Result[T, E] {
  @pub fun getErrOrDefault(): E = match self {
    Ok(_)    => E::default(),
    Err(err) => err,
  };
}

impl[T: Zero, E] Result[T, E] {
  @pub fun getOrZero(): T = match self {
    Ok(val) => val,
    Err(_)  => T::zero(),
  };
}

impl[T, E: Zero] Result[T, E] {
  @pub fun getErrOrZero(): E = match self {
    Ok(_)    => E::zero(),
    Err(err) => err,
  };
}
