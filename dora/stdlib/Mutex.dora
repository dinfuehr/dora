const UNLOCKED: Int32 = 0I;
const LOCKED: Int32 = 1I;
const SLEEPING: Int32 = 2I;

@pub class Mutex {
    let data: AtomicInt32 = AtomicInt32(0I);

    @pub fun lock() {
        let previous = self.data.compareExchange(UNLOCKED, LOCKED);

        if previous != UNLOCKED {
            self.lockSlow(previous);
        }
    }

    fun lockSlow(previous: Int32) {
        var previous = previous;
        var lockSuccess = false;

        while !lockSuccess {
            assert(previous == LOCKED || previous == SLEEPING);

            if self.transitionToSleepingState(previous) {
                self.wait(SLEEPING);
            }

            previous = self.data.compareExchange(UNLOCKED, SLEEPING);
            lockSuccess = previous == UNLOCKED;
        }
    }

    fun transitionToSleepingState(previous: Int32): Bool {
        if previous == SLEEPING { return true; }
        self.data.compareExchange(LOCKED, SLEEPING) != UNLOCKED
    }

    @pub fun unlock() {
        let previous = self.data.exchange(UNLOCKED);

        if previous != LOCKED {
            self.unlockSlow(previous);
        }
    }

    fun unlockSlow(previous: Int32) {
        assert(previous == SLEEPING);
        self.notify();
    }

    @internal fun wait(status: Int32);
    @internal fun notify();
}
