trait A[T, U] {
    static fn a_static(): T;
    static fn a_other(): U;
}

// B swaps the type parameters
trait B[X, Y]: A[Y, X] {
    static fn b_static(): X {
        Self::a_other()
    }
}

// C uses one concrete type
trait C[Z]: B[Z, Int64] {
    static fn c_static(): Z {
        Self::b_static()
    }
    static fn c_int(): Int64 {
        Self::a_static()
    }
}

class Foo

impl A[Int64, String] for Foo {
    static fn a_static(): Int64 { 42 }
    static fn a_other(): String { "hello" }
}

impl B[String, Int64] for Foo {}

impl C[String] for Foo {}

fn main() {
    // B[String, Int64]: A[Int64, String]
    // b_static returns X=String, calls a_other which returns U=String
    assert(Foo::b_static() == "hello");

    // C[String]: B[String, Int64]: A[Int64, String]
    // c_static returns Z=String, calls b_static which returns X=String
    assert(Foo::c_static() == "hello");

    // c_int returns Int64, calls a_static which returns T=Int64
    assert(Foo::c_int() == 42);
}
