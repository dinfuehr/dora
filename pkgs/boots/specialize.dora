use package::bytecode::BytecodeType;
use package::interface as iface;
use package::CompilationInfo;

pub fn specializeTy(ci: CompilationInfo, ty: BytecodeType, type_params: Array[BytecodeType]): BytecodeType {
    if !ty.isGeneric() {
        return ty;
    }

    match ty {
        BytecodeType::Unit
        | BytecodeType::Ptr
        | BytecodeType::UInt8
        | BytecodeType::Bool
        | BytecodeType::Char
        | BytecodeType::Int32
        | BytecodeType::Int64
        | BytecodeType::Float32
        | BytecodeType::Float64 => ty,
        BytecodeType::This => ci.specializeSelf.getOrPanic(),
        BytecodeType::Struct(struct_id, struct_type_params) => {
            BytecodeType::Struct(struct_id, specializeArray(ci, struct_type_params, type_params))
        },
        BytecodeType::Enum(enum_id, enum_type_params) => {
            BytecodeType::Enum(enum_id, specializeArray(ci, enum_type_params, type_params))
        },
        BytecodeType::Class(class_id, class_type_params) => {
            BytecodeType::Class(class_id, specializeArray(ci, class_type_params, type_params))
        },
        BytecodeType::TraitObject(trait_id, trait_type_params, assoc_types) => {
            BytecodeType::TraitObject(trait_id, specializeArray(ci, trait_type_params, type_params), specializeArray(ci, assoc_types, type_params))
        },
        BytecodeType::Tuple(subtypes) => {
            BytecodeType::Tuple(specializeArray(ci, subtypes, type_params))
        },
        BytecodeType::TypeParam(idx) => type_params(idx.toInt64()),
        BytecodeType::Lambda(params, ret) => {
            BytecodeType::Lambda(specializeArray(ci, params, type_params), specializeTy(ci, ret, type_params))
        },
        BytecodeType::GenericAssoc(typeParamId, ..) => {
            iface::specializeTy(ci, ty, type_params)
        }
        BytecodeType::TypeAlias(..) | BytecodeType::Assoc(..) => unreachable[BytecodeType](),
    }
}

pub fn specializeArray(ci: CompilationInfo, array: Array[BytecodeType], type_params: Array[BytecodeType]): Array[BytecodeType] {
    if array.isEmpty() || !array.isGeneric() {
        return array;
    }

    let result = Array[BytecodeType]::fill(array.size(), BytecodeType::Unit);

    for idx in std::range(0, array.size()) {
        result(idx) = specializeTy(ci, array(idx), type_params);
    }

    result
}
