use std::{Equals, Hash, HashSet, HashMap};

use package::bytecode::{ClassId, GlobalId};
use package::compilation::CompilationInfo;
use package::dominator::computePostOrder;
use package::graph::{ClassInfo, Graph, Inst, Op};

pub fn performLoadElimination(ci: CompilationInfo, graph: Graph) {
    computePostOrder(graph);

    for block in graph.reversePostOrderIterator() {
        let data = LoadData::new();

        for inst in block.instructionsIterator() {
            let op = inst.op();

            if op == Op::EnsureGlobalInitialized {
                let id = inst.getGlobalId();

                if !data.initializeGlobal(id) {
                    inst.remove();
                }

            } else if op == Op::LoadGlobal {
                let id = inst.getGlobalId();

                if data.getGlobalValue(id) is Some(value) {
                    inst.replaceAllUsesWith(value);
                    inst.remove();
                } else {
                    data.setGlobalValue(id, inst);
                }

            } else if op == Op::StoreGlobal {
                let id = inst.getGlobalId();
                let value = inst.getInput(0).getValue();
                data.setGlobalValue(id, value);

            } else if op == Op::Load {
                if inst.hasClassInfo() {
                    let class_info = inst.getClassInfo();
                    let object = inst.getInput(0).getValue();
                    let field = Field(object, class_info, inst.getOffset());

                    if data.class_values.get(field) is Some(value) {
                        inst.replaceAllUsesWith(value);
                        inst.remove();
                    } else {
                        data.class_values.insert(field, inst);
                    }
                }

            } else if op == Op::Store {
                data.class_values.clear();

            } else if op.isCall() {
                data.kill();
            }
        }
    }
}

struct Field {
    object: Inst,
    class_info: ClassInfo,
    field_offset: Int32,
}

impl Equals for Field {
    fn equals(other: Field): Bool {
        self.object == other.object && self.class_info == other.class_info && self.field_offset == other.field_offset
    }
}

impl Hash for Field {
    fn hash(): Int32 {
        self.object.hash() ^ self.class_info.hash() ^ self.field_offset
    }
}

class LoadData {
    initialized_globals: HashSet[Int32],
    global_values: HashMap[Int32, Inst],
    class_values: HashMap[Field, Inst],
}

impl LoadData {
    static fn new(): LoadData {
        LoadData(
            HashSet[Int32]::new(),
            HashMap[Int32, Inst]::new(),
            HashMap[Field, Inst]::new(),
        )
    }

    fn initializeGlobal(id: GlobalId): Bool {
        self.initialized_globals.insert(id.value)
    }

    fn getGlobalValue(id: GlobalId): Option[Inst] {
        self.global_values.get(id.value)
    }

    fn setGlobalValue(id: GlobalId, value: Inst) {
        self.global_values.insert(id.value, value);
    }

    fn loadClassField(field: Field, value: Inst) {
        self.class_values.insert(field, value);
    }

    fn kill() {
        self.global_values.clear();
        self.class_values.clear();
    }
}
