@internal fn readFileAsString(path: String): Option[String];
@internal fn readFileAsBytes(path: String): Option[Array[UInt8]];
@internal fn writeFileAsString(path: String, content: String): Bool;
@internal fn writeFileAsBytes(path: String, content: Array[UInt8]): Bool;

@internal fn fileCreate(path: String): Int64;
@internal fn fileOpen(path: String): Int64;
@internal fn fileWrite(fd: Int64, array: Array[UInt8], offset: Int64, len: Int64): Int64;
@internal fn fileRead(fd: Int64, array: Array[UInt8], offset: Int64, len: Int64): Int64;
@internal fn fileClose(fd: Int64);

@internal fn getStdHandle(stdFd: Int32): Int64;

pub class File {
    path: String,
}

impl File {
    pub static fn new(path: String): File {
        File(path)
    }

    pub static fn create(path: String): OpenFile {
        OpenFile(fileCreate(path))
    }

    pub static fn open(path: String): OpenFile {
        OpenFile(fileOpen(path))
    }

    pub fn readAsString(): Option[String] {
        readFileAsString(self.path)
    }

    pub fn readAsBytes(): Option[Array[UInt8]] {
        readFileAsBytes(self.path)
    }

    pub fn writeAsString(content: String): Result[(), ()] {
        if writeFileAsString(self.path, content) {
            Ok[(), ()](())
        } else {
            Err[(), ()](())
        }
    }

    pub fn writeAsBytes(content: Array[UInt8]): Result[(), ()] {
        if writeFileAsBytes(self.path, content) {
            Ok[(), ()](())
        } else {
            Err[(), ()](())
        }
    }
}

pub let stdin: OpenFile = OpenFile(getStdHandle(0i32));
pub let stdout: OpenFile = OpenFile(getStdHandle(1i32));
pub let stderr: OpenFile = OpenFile(getStdHandle(2i32));

pub class OpenFile {
    fd: Int64,
}

impl OpenFile {
    pub fn write(array: Array[UInt8]): Int64 {
        fileWrite(self.fd, array, 0, array.size())
    }

    pub fn read(array: Array[UInt8]): Int64 {
        fileRead(self.fd, array, 0, array.size())
    }

    pub fn writeString(text: String) {
        self.write(text.asBytes());
    }

    pub fn close() {
        if self.fd != -1 {
            fileClose(self.fd)
        }
    }
}

pub class Directory {
    path: String,
}

impl Directory {
    pub fn new(path: String): Directory {
        Directory(path)
    }
}

@internal fn socketConnect(addr: String): Int64;
@internal fn socketClose(fd: Int64);
@internal fn socketRead(fd: Int64, array: Array[UInt8], offset: Int64, len: Int64): Int64;
@internal fn socketWrite(fd: Int64, array: Array[UInt8], offset: Int64, len: Int64): Int64;

@internal fn socketBind(addr: String): Int64;
@internal fn socketAccept(fd: Int64): Int64;

pub class TcpListener {
    fd: Int64,
}

impl TcpListener {
    pub static fn bind(addr: String): Result[TcpListener, ()] {
        let fd = socketBind(addr);
        if fd != -1 {
            Ok[TcpListener, ()](TcpListener(fd))
        } else {
            Err[TcpListener, ()](())
        }
    }

    pub fn accept(): Result[TcpStream, ()] {
        let stream_fd = socketAccept(self.fd);

        if stream_fd != -1 {
            Ok[TcpStream, ()](TcpStream(stream_fd))
        } else {
            Err[TcpStream, ()](())
        }
    }

    pub fn close() {
        if self.fd != -1 {
            socketClose(self.fd);
            self.fd = -1;
        }
    }
}

pub class TcpStream {
    fd: Int64,
}

impl TcpStream {
    pub static fn connect(addr: String): Result[TcpStream, ()] {
        let fd = socketConnect(addr);
        if fd != -1 {
            Ok[TcpStream, ()](TcpStream(fd))
        } else {
            Err[TcpStream, ()](())
        }
    }

    pub fn close() {
        if self.fd != -1 {
            socketClose(self.fd);
            self.fd = -1;
        }
    }

    pub fn read(array: Array[UInt8]): Int64 {
        socketRead(self.fd, array, 0, array.size())
    }

    pub fn write(array: Array[UInt8]): Int64 {
        socketWrite(self.fd, array, 0, array.size())
    }
}
