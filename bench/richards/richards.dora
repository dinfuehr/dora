// Dora implementation of Richards benchmark. 
// Originally implemented in BCPL (http://www.cl.cam.ac.uk/~mr10/Bench.html)
// Used in Octane 2.0 (https://developers.google.com/octane/benchmark)

fun main() {
    var iterations = 8200I;

    if std::argc() > 0I {
        iterations = std::argv(0I).toInt32().getOrPanic();
    }  

    let bench = Benchmark();

    var i = 0I;
    while i < iterations {
        bench.runRichards();
        i = i + 1I;
    }
}

const COUNT: Int32 = 1000I;
const EXPECTED_QUEUE_COUNT: Int32 = 2322I;
const EXPECTED_HOLD_COUNT: Int32 = 928I;

class Benchmark() {
    fun runRichards() {
        let scheduler = Scheduler();
        scheduler.addIdleTask(ID_IDLE, 0I, Option[Packet]::None, COUNT);

        var queue = Packet::new(Option[Packet]::None, ID_WORKER, KIND_WORK);
        queue = Packet::new(Option[Packet]::Some(queue), ID_WORKER, KIND_WORK);
        scheduler.addWorkerTask(ID_WORKER, 1000I, Option[Packet]::Some(queue));

        queue = Packet::new(Option[Packet]::None, ID_DEVICE_A, KIND_DEVICE);
        queue = Packet::new(Option[Packet]::Some(queue), ID_DEVICE_A, KIND_DEVICE);
        queue = Packet::new(Option[Packet]::Some(queue), ID_DEVICE_A, KIND_DEVICE);
        scheduler.addHandlerTask(ID_HANDLER_A, 2000I, Option[Packet]::Some(queue));

        queue = Packet::new(Option[Packet]::None, ID_DEVICE_B, KIND_DEVICE);
        queue = Packet::new(Option[Packet]::Some(queue), ID_DEVICE_B, KIND_DEVICE);
        queue = Packet::new(Option[Packet]::Some(queue), ID_DEVICE_B, KIND_DEVICE);
        scheduler.addHandlerTask(ID_HANDLER_B, 3000I, Option[Packet]::Some(queue));

        scheduler.addDeviceTask(ID_DEVICE_A, 4000I, Option[Packet]::None);

        scheduler.addDeviceTask(ID_DEVICE_B, 5000I, Option[Packet]::None);

        scheduler.schedule();

        if scheduler.queueCount != EXPECTED_QUEUE_COUNT || scheduler.holdCount != EXPECTED_HOLD_COUNT {
            println("Error during execution: queueCount = ${scheduler.queueCount}, holdCount = ${scheduler.holdCount}.");
            std::exit(1I);
        }
    }
}

const ID_IDLE: Int32 = 0I;
const ID_WORKER: Int32 = 1I;
const ID_HANDLER_A: Int32 = 2I;
const ID_HANDLER_B: Int32 = 3I;
const ID_DEVICE_A: Int32 = 4I;
const ID_DEVICE_B: Int32 = 5I;
const NUMBER_OF_IDS: Int32 = 6I;

const KIND_DEVICE: Int32 = 0I;
const KIND_WORK: Int32 = 1I;

class Scheduler() {
    var queueCount: Int32 = 0I;
    var holdCount: Int32 = 0I;
    var blocks: Array[Option[TaskControlBlock]] = Array[Option[TaskControlBlock]]::fill(NUMBER_OF_IDS.toInt64(), Option[TaskControlBlock]::None);
    var currentTcb: Option[TaskControlBlock] = Option[TaskControlBlock]::None;
    var list: Option[TaskControlBlock] = Option[TaskControlBlock]::None;
    var currentId: Option[Int32] = Option[Int32]::None;

    fun addIdleTask(id: Int32, priority: Int32, queue: Option[Packet], count: Int32) {
        self.addRunningTask(id, priority, queue, IdleTask(self, 1I, count));
    }

    fun addWorkerTask(id: Int32, priority: Int32, queue: Option[Packet]) {
        self.addTask(id, priority, queue, WorkerTask(self, ID_HANDLER_A, 0I));
    }

    fun addHandlerTask(id: Int32, priority: Int32, queue: Option[Packet]) {
        self.addTask(id, priority, queue, HandlerTask(self));
    }

    fun addDeviceTask(id: Int32, priority: Int32, queue: Option[Packet]) {
        self.addTask(id, priority, queue, DeviceTask(self));
    }

    fun addRunningTask(id: Int32, priority: Int32, queue: Option[Packet], task: Task) {
        self.addTask(id, priority, queue, task);
        self.currentTcb.getOrPanic().setRunning();
    }

    fun addTask(id: Int32, priority: Int32, queue: Option[Packet], task: Task) {
        self.currentTcb = Option[TaskControlBlock]::Some(TaskControlBlock::new(self.list, id, priority, queue, task));
        self.list = self.currentTcb;
        self.blocks.set(id.toInt64(), self.currentTcb);
    }

    fun schedule() {
        self.currentTcb = self.list;
        while(self.currentTcb.isSome()) {
            let tcb = self.currentTcb.getOrPanic();
            if tcb.isHeldOrSuspended() {
                self.currentTcb = tcb.link;
            } else {
                self.currentId = Option[Int32]::Some(tcb.id);
                self.currentTcb = tcb.run();
            }
        }
    }

    fun release(id: Int32): Option[TaskControlBlock] {
        let blockTcb = self.blocks.get(id.toInt64());
        if blockTcb.isNone() {   
            return Option[TaskControlBlock]::None;
        }
        let tcb = blockTcb.getOrPanic();
        tcb.markAsNotHeld();
        if tcb.priority > self.currentTcb.getOrPanic().priority {
            return blockTcb;
        } else {
            return self.currentTcb;
        }
    }

    fun holdCurrent(): Option[TaskControlBlock] {
        let tcb = self.currentTcb.getOrPanic();
        self.holdCount = self.holdCount + 1I;
        tcb.markAsHeld();
        return tcb.link;
    }

    fun suspendCurrent(): Option[TaskControlBlock] {
        let tcb = self.currentTcb.getOrPanic();
        tcb.markAsSuspended();
        return Option[TaskControlBlock]::Some(tcb);
    }

    fun queue(packet: Packet): Option[TaskControlBlock] {
        let t = self.blocks.get(packet.id.toInt64());
        if t.isNone() {
            return Option[TaskControlBlock]::None;
        }
        self.queueCount = self.queueCount + 1I;
        packet.link = Option[Packet]::None;
        packet.id = self.currentId.getOrPanic();
        return Option[TaskControlBlock]::Some(t.getOrPanic().checkPriorityAdd(self.currentTcb.getOrPanic(), packet));
    }
}

const STATE_RUNNING: Int32 = 0I;
const STATE_RUNNABLE: Int32 = 1I;
const STATE_SUSPENDED: Int32 = 2I;
const STATE_HELD: Int32 = 4I;

var STATE_SUSPENDED_RUNNABLE: Int32 = STATE_SUSPENDED | STATE_RUNNABLE;
var STATE_NOT_HELD: Int32 = STATE_HELD.not();

class TaskControlBlock(let link: Option[TaskControlBlock], let id: Int32, let priority: Int32, var queue: Option[Packet], let task: Task, var state: Int32) {
    fun setRunning() { self.state = STATE_RUNNING; }
    fun markAsNotHeld() { self.state = self.state & STATE_NOT_HELD; }
    fun markAsHeld() { self.state = self.state | STATE_HELD; }
    fun isHeldOrSuspended(): Bool { return (self.state & STATE_HELD) != 0I || (self.state == STATE_SUSPENDED); }
    fun markAsSuspended() { self.state = self.state | STATE_SUSPENDED; }
    fun markAsRunnable() { self.state = self.state | STATE_RUNNABLE; }

    fun run(): Option[TaskControlBlock] {
        var packet: Option[Packet] = Option[Packet]::None;
        if self.state == STATE_SUSPENDED_RUNNABLE {
            packet = self.queue;
            self.queue = packet.getOrPanic().link;
            if self.queue.isNone() {
                self.state = STATE_RUNNING;
            } else {
                self.state = STATE_RUNNABLE;
            }
        }
        return self.task.run(packet);
    }

    fun checkPriorityAdd(task: TaskControlBlock, packet: Packet): TaskControlBlock {
        if self.queue.isNone() {
            self.queue = Option[Packet]::Some(packet);
            self.markAsRunnable();
            if self.priority > task.priority {
                return self;
            }
        } else {
            self.queue = Option[Packet]::Some(packet.addTo(self.queue));
        }
        return task;
    }

    @static fun new(link: Option[TaskControlBlock], id: Int32, priority: Int32, queue: Option[Packet], task: Task): TaskControlBlock {
        if queue.isNone() {
            return TaskControlBlock(link, id, priority, queue, task, STATE_SUSPENDED);
        } else {
            return TaskControlBlock(link, id, priority, queue, task, STATE_SUSPENDED_RUNNABLE);
        }
    }
}

impl std::Stringable for TaskControlBlock {
    fun toString(): String {
        return "tcb { ${self.task.toString()}@${self.state} }";
    }
}



@open @abstract class Task {
    @abstract fun run(packet: Option[Packet]): Option[TaskControlBlock];
    @abstract fun toString(): String;
}

class IdleTask(let scheduler: Scheduler, var seed: Int32, var count: Int32) extends Task {
    @override fun run(packet: Option[Packet]): Option[TaskControlBlock] {
        self.count = self.count - 1I;
        if self.count == 0I {
            return self.scheduler.holdCurrent();
        }
        if self.seed & 1I == 0I {
            self.seed = self.seed >> 1I;
            return self.scheduler.release(ID_DEVICE_A);
        } else {
            self.seed = (self.seed >> 1I) ^ 0xD008I;
            return self.scheduler.release(ID_DEVICE_B);
        }
    }

    @override fun toString(): String {
        return "IdleTask";
    }
}

class DeviceTask(let scheduler: Scheduler) extends Task {
    var seed: Option[Packet] = Option[Packet]::None;

    @override fun run(packet: Option[Packet]): Option[TaskControlBlock] {
        if packet.isNone() {
            if self.seed.isNone() {
                return self.scheduler.suspendCurrent();
            }
            let v = self.seed.getOrPanic();
            self.seed = Option[Packet]::None;
            return self.scheduler.queue(v);
        } else {
            self.seed = packet;
            return self.scheduler.holdCurrent();
        }
    }

    @override fun toString(): String {
        return "DeviceTask";
    }
}

class WorkerTask(let scheduler: Scheduler, var v1: Int32, var v2: Int32) extends Task {
    @override fun run(packet: Option[Packet]): Option[TaskControlBlock] {
        if packet.isNone() {
            return self.scheduler.suspendCurrent();
        } else {
            let p = packet.getOrPanic();
            if self.v1 == ID_HANDLER_A {
                self.v1 = ID_HANDLER_B;
            } else {
                self.v1 = ID_HANDLER_A;
            }
            p.id = self.v1;
            p.a1 = 0I;
            var i = 0I;
            while i < DATA_SIZE {
                self.v2 = self.v2 + 1I;
                if self.v2 > 26I {
                    self.v2 = 1I;
                }
                i = i + 1I;
            }
            return self.scheduler.queue(p);
        }
    }

    @override fun toString(): String {
        return "WorkerTask";
    }
}

class HandlerTask(let scheduler: Scheduler) extends Task {
    var v1: Option[Packet] = Option[Packet]::None;
    var v2: Option[Packet] = Option[Packet]::None;

    @override fun run(packet: Option[Packet]): Option[TaskControlBlock] {
        if packet.isSome() {
            let p = packet.getOrPanic();
            if p.kind == KIND_WORK {
                self.v1 = Option[Packet]::Some(p.addTo(self.v1));
            } else {
                self.v2 = Option[Packet]::Some(p.addTo(self.v2));
            }             
        }
        if self.v1.isSome() {
            let v1_p = self.v1.getOrPanic();
            let count = v1_p.a1;
            if count < DATA_SIZE {
                if self.v2.isSome() {                    
                    let v = self.v2.getOrPanic();
                    self.v2 = v.link;
                    v.a1 = v1_p.a2.get(count.toInt64());
                    v1_p.a1 = count + 1I;
                    return self.scheduler.queue(v);
                }
            } else {
                self.v1 = v1_p.link;
                return self.scheduler.queue(v1_p);
            }
        }
        return self.scheduler.suspendCurrent();
    }

    @override fun toString(): String {
        return "HandlerTask";
    }
}

var DATA_SIZE: Int32 = 4I;

class Packet(var link: Option[Packet], var id: Int32, let kind: Int32, var a1: Int32, let a2: Array[Int32]) {
    fun addTo(queue: Option[Packet]): Packet {
        self.link = Option[Packet]::None;
        if queue.isNone() {
            return self;
        }

        var next: Packet = queue.getOrPanic();
        var peek: Option[Packet] = next.link;

        while peek.isSome() {
            next = peek.getOrPanic();
            peek = next.link;
        }

        next.link = Option[Packet]::Some(self);
        return queue.getOrPanic();
    }

    @static fun new(link: Option[Packet], id: Int32, kind: Int32): Packet {
        let array: Array[Int32] = Array[Int32]::new(DATA_SIZE.toInt64());
        return Packet(link, id, kind, 0I, array);
    }
}
