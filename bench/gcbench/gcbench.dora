import std::argc;
import std::argv;
import std::timestamp;

class Node(var left: Option[Node], var right: Option[Node]) {
    var i: Int32 = 0I;
    var j: Int32 = 0I;

    @static fun leaf(): Node = Node(Option[Node]::None, Option[Node]::None);
}

var stretchTreeDepth: Int32 = 0I;
var longLivedTreeDepth: Int32 = 0I;
const kArraySize: Int32 = 500000I;
const kMinTreeDepth: Int32 = 4I;
const kMaxTreeDepth: Int32 = 16I;

fun treeSize (i: Int32): Int32 {
    return (1I << (i + 1I)) - 1I;
}

fun numIters(i: Int32): Int32 {
    return 4I * treeSize(stretchTreeDepth) / treeSize(i);
}

fun populate(depth: Int32, thisNode: Node) {
    var depth = depth;
    if depth <= 0I {
        return;
    } else {
        depth = depth - 1I;
        thisNode.left = Option[Node]::Some(Node::leaf());
        thisNode.right = Option[Node]::Some(Node::leaf());
        populate(depth, thisNode.left.getOrPanic());
        populate(depth, thisNode.right.getOrPanic());
    }
}

fun makeTree(iDepth: Int32): Node {
    if iDepth <= 0I {
        return Node::leaf();
    } else {
        return Node(Option[Node]::Some(makeTree(iDepth-1I)), Option[Node]::Some(makeTree(iDepth-1I)));
    }
}

fun timeConstruction(depth: Int32) {
    let iNumIters = numIters(depth);
    println("Creating " + iNumIters.toString() + " trees of depth " + depth.toString());
    let start = timestamp();

    var i = 0I;

    while i < iNumIters {
        let tempTree = Node::leaf();
        populate(depth, tempTree);
        i = i + 1I;
    }

    let finish = timestamp();
    let msecs = (finish - start).toFloat32() / 1000.0F / 1000.0F;
    println("\tTop down construction took " + msecs.toString() + "ms");

    let start = finish;

    var i = 0I;

    while i < iNumIters {
        let tempTree = makeTree(depth);
        i = i + 1I;
    }

    let finish = timestamp();
    let msecs = (finish - start).toFloat32() / 1000.0F / 1000.0F;
    println("\tBottom up construction took " + msecs.toString() + "ms");
}

fun main() {
    if argc() != 1I {
        println("usage: gcbench <depth>");
        std::exit(1I);
    }

    let depth = argv(0I).toInt32().getOrPanic();

    stretchTreeDepth = depth+1I;
    longLivedTreeDepth = depth;

    println("Stretching memory with a binary tree of depth " + stretchTreeDepth.toString());
    let start = timestamp();

    makeTree(stretchTreeDepth);

    println("Creating a long-lived binary tree of depth " + longLivedTreeDepth.toString());
    let longLivedTree = Node::leaf();
    populate(longLivedTreeDepth, longLivedTree);

    println("Creating a long-lived array of " + kArraySize.toString() + " doubles");
    let array = Array[Float64]::fill(kArraySize.toInt64(), 0.0);

    var i = 0I;

    while i < kArraySize / 2I {
        array(i.toInt64()) = 1.0/i.toFloat64();
        i = i + 1I;
    }

    var d = kMinTreeDepth;

    while d <= depth {
        timeConstruction(d);
        d = d + 2I;
    }

    assert(longLivedTree.i == 0I && array(1000L) == 1.0/1000.0);
    let finish = timestamp();
    let elapsed = (finish - start).toFloat32() / 1000.0F / 1000.0F;
    println("Completed in " + elapsed.toString() + "ms.");
}
