#!/usr/bin/env -S uv run
# /// script
# requires-python = ">=3.11"
# ///

"""
Generate opcode files from tools/bytecode.toml.

Usage: ./tools/bytecode-gen.py [--check]

Generates:
  - pkgs/boots/bytecode/opcode.dora
  - dora-bytecode/src/opcode.rs
"""

import argparse
import re
import sys
from pathlib import Path

# tomllib is in stdlib since 3.11
import tomllib


def to_screaming_snake(name: str) -> str:
    """Convert PascalCase to SCREAMING_SNAKE_CASE."""
    # Insert underscore before any uppercase letter that follows another character
    # This matches the Ruby behavior: UInt8 -> U_Int8 -> U_INT8
    return re.sub(r"(.)([A-Z])", r"\1_\2", name).upper()


def generate_dora(config: dict) -> str:
    lines = [
        "// Generated by tools/bytecode-gen.py",
        "// Do not edit manually - edit tools/bytecode.toml instead.",
        "",
    ]

    name_functions = []

    for section_name, section in config.items():
        prefix = to_screaming_snake(section_name)
        variants = section["variants"]

        # Generate constants
        for i, name in enumerate(variants):
            lines.append(f"pub const {prefix}_{to_screaming_snake(name)}: Int32 = {i};")
        lines.append("")

        # Collect name functions to generate later
        if "name_function" in section:
            name_functions.append((section["name_function"], prefix, variants))

    # Generate name functions
    for func_name, prefix, variants in name_functions:
        lines.append(f"pub fn {func_name}(opcode: Int32): String {{")
        for name in variants:
            lines.append(
                f'  if opcode == {prefix}_{to_screaming_snake(name)} {{ return "{name}"; }}'
            )
        lines.append("  unreachable[String]()")
        lines.append("}")
        lines.append("")

    lines.append("")

    return "\n".join(lines)


def generate_rust(config: dict) -> str:
    lines = [
        "// Generated by tools/bytecode-gen.py",
        "// Do not edit manually - edit tools/bytecode.toml instead.",
        "",
    ]

    for section_name, section in config.items():
        prefix = to_screaming_snake(section_name)
        variants = section["variants"]

        for i, variant in enumerate(variants):
            const_name = f"{prefix}_{to_screaming_snake(variant)}"
            lines.append(f"pub const {const_name}: u8 = {i};")
        lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Generate opcode files from bytecode.toml"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check that generated files match current files (for CI)",
    )
    args = parser.parse_args()

    script_dir = Path(__file__).parent
    repo_root = script_dir.parent

    toml_path = script_dir / "bytecode.toml"

    with open(toml_path, "rb") as f:
        config = tomllib.load(f)

    dora_path = repo_root / "pkgs" / "boots" / "bytecode" / "opcode.dora"
    rust_path = repo_root / "dora-bytecode" / "src" / "opcode.rs"

    dora_output = generate_dora(config)
    rust_output = generate_rust(config)

    if args.check:
        ok = True

        with open(dora_path) as f:
            if f.read() != dora_output:
                print(f"MISMATCH: {dora_path}")
                ok = False

        with open(rust_path) as f:
            if f.read() != rust_output:
                print(f"MISMATCH: {rust_path}")
                ok = False

        if ok:
            print("Generated files are up to date.")
            sys.exit(0)
        else:
            print("Run ./tools/bytecode-gen.py to regenerate.")
            sys.exit(1)
    else:
        with open(dora_path, "w") as f:
            f.write(dora_output)
        print(f"Generated {dora_path}")

        with open(rust_path, "w") as f:
            f.write(rust_output)
        print(f"Generated {rust_path}")


if __name__ == "__main__":
    main()
