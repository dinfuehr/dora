#!/usr/bin/env -S uv run --script

# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///

import argparse
import shlex
import subprocess
import sys
import tempfile
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent
TESTS_DIR = REPO_ROOT / "test" / "fmt"


def run_formatter(path: Path, verbose: bool, release: bool) -> str:
    rel_path = str(path.relative_to(REPO_ROOT))
    cmd = ["cargo", "run", "-p", "dora-format"]
    if release:
        cmd.append("--release")
    cmd.extend(["--", rel_path])
    if verbose:
        print("+", " ".join(shlex.quote(part) for part in cmd))
    result = subprocess.run(
        cmd,
        cwd=REPO_ROOT,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        print("+", " ".join(shlex.quote(part) for part in cmd))
        if result.stdout:
            print(result.stdout, end="")
        if result.stderr:
            print(result.stderr, end="", file=sys.stderr)
        raise subprocess.CalledProcessError(
            result.returncode, result.args, result.stdout, result.stderr
        )
    return result.stdout


def gather_pkg_files(pkg_name: str) -> list[Path]:
    pkgs_root = REPO_ROOT / "pkgs"
    candidates: list[Path] = []

    direct = pkgs_root / pkg_name
    if direct.is_dir():
        candidates.append(direct)
    else:
        for path in pkgs_root.rglob(pkg_name):
            if path.is_dir():
                candidates.append(path)

    if not candidates:
        return []

    files: list[Path] = []
    for base in sorted({path.resolve() for path in candidates}):
        files.extend(sorted(base.rglob("*.dora")))
    return files


def expected_output_path(input_path: Path) -> Path:
    name = input_path.name
    if name.endswith(".in.dora"):
        expected_name = name.replace(".in.dora", ".out.dora")
        return input_path.with_name(expected_name)
    return input_path.with_suffix(".out.dora")


def print_test_status(path: Path, status: str) -> None:
    rel_path = path.relative_to(REPO_ROOT)
    print(f"format/match {rel_path}: {status}")


def is_ignored(input_path: Path) -> bool:
    try:
        with input_path.open("r", encoding="utf-8") as handle:
            first_line = handle.readline().strip()
            return first_line == "//= ignore"
    except OSError:
        return False


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run Dora format golden tests.")
    parser.add_argument(
        "--force",
        action="store_true",
        help="Update .out files with current formatter output.",
    )
    parser.add_argument(
        "-r",
        "--release",
        action="store_true",
        help="Run formatter in release mode.",
    )
    parser.add_argument(
        "paths",
        nargs="*",
        type=Path,
        help="Optional .in.dora files to test.",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Print formatter command lines.",
    )
    parser.add_argument(
        "--ignored",
        action="store_true",
        help="Run tests marked as ignored.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    if not TESTS_DIR.is_dir():
        print(f"Missing test directory: {TESTS_DIR}", file=sys.stderr)
        return 1

    if args.paths:
        inputs = []
        for path in args.paths:
            resolved = path if path.is_absolute() else (REPO_ROOT / path)
            inputs.append(resolved)
    else:
        inputs = sorted(TESTS_DIR.rglob("*.in.dora"))
        if not inputs:
            print(f"No .in.dora files found in {TESTS_DIR}.", file=sys.stderr)
            return 1

    ignored = 0
    mismatches = 0
    matched = 0
    formatted_files = 0

    for input_path in inputs:
        if is_ignored(input_path) and not args.ignored:
            print_test_status(input_path, "ignore")
            ignored += 1
            continue

        expected_path = expected_output_path(input_path)
        actual = run_formatter(input_path, args.verbose, args.release)

        if args.force or not expected_path.exists():
            expected_path.write_text(actual)
            print_test_status(input_path, "OK")
            matched += 1
            continue

        expected = expected_path.read_text()
        if actual != expected:
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".out.dora", delete=False, encoding="utf-8"
            ) as tmp:
                tmp.write(actual)
                actual_path = Path(tmp.name)

            diff_cmd = ["diff", str(actual_path), str(expected_path)]
            print("+", " ".join(shlex.quote(part) for part in diff_cmd))
            subprocess.run(diff_cmd, cwd=REPO_ROOT)
            print(
                f"vimdiff {shlex.quote(str(actual_path))} {shlex.quote(str(expected_path))}"
            )
            print_test_status(input_path, "Error")
            mismatches += 1
        else:
            print_test_status(input_path, "OK")
            matched += 1

    if not args.paths:
        formatter_files = gather_pkg_files("std") + gather_pkg_files("boots")
        for path in formatter_files:
            rel_path = str(path.relative_to(REPO_ROOT))
            print(f"format {rel_path}")
            run_formatter(path, args.verbose, args.release)
            formatted_files += 1

    print(
        f"{matched} matched, {mismatches} mismatched, {ignored} ignored, {formatted_files} pkgs file(s) formatted"
    )
    return 1 if mismatches else 0


if __name__ == "__main__":
    sys.exit(main())
