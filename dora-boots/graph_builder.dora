use std::HashMap;
use std::BitSet;

use package::graph;
use package::graph::Graph;
use package::graph::Block;
use package::graph::Inst;
use package::graph::Op;
use package::graph::createBoolConst;
use package::graph::createInt32Const;
use package::graph::createInt64Const;
use package::graph::createFloat32Const;
use package::graph::createFloat64Const;
use package::graph::createIfInst;
use package::graph::createArrayLength;
use package::graph::createBoundsCheck;
use package::graph::createLoadArray;
use package::graph::createStoreArray;
use package::graph::createReturnInst;
use package::graph::createReturnVoidInst;
use package::graph::createGotoInst;
use package::graph::createTestInst;
use package::graph::createStoreGlobalInst;
use package::graph::createLoadGlobalInst;
use package::graph::createBinaryInst;
use package::graph::createDivZeroCheck;
use package::graph::createUnaryInst;
use package::graph::createUndefInst;
use package::graph::createPhiInst;
use package::graph::createArgInst;
use package::graph::createNewObject;
use package::graph::ty::Type;
use package::graph::{ClassInfo, FieldInfo, FunctionInfo, CallKind, VirtualFunctionInfo, LambdaFunctionInfo};
use package::bytecode::data::{BytecodeFunction, BytecodeRegister, BytecodeType, ClassId, FctId, FieldId};
use package::bytecode::data::{ConstPoolId, ConstPoolEntry, GlobalId};
use package::bytecode::instruction::BytecodeInstruction;
use package::bytecode::reader::BytecodeIterator;
use package::interface::{OBJECT_HEADER_LENGTH, hasGlobalInitialValue};

pub fn createGraph(bc: BytecodeFunction): Graph {
    let graph = Graph::new();

    // Create basic blocks for the bytecode.
    let blockMap = createBlocks(graph, bc);

    // Create edges for the blocks.
    createEdges(graph, bc, blockMap);

    // Fill basic blocks with instructions.
    let ssagen = SsaGen::new(graph, bc, blockMap);
    ssagen.run();

    graph
}

class SsaGen {
    graph: Graph,
    bc: BytecodeFunction,
    blockMap: BlockMap,
    currentBlock: Option[Block],
    offset: Int32,
    currentDef: Array[HashMap[Block, Inst]],
    blockTerminated: Bool,

    pushed_registers: Vec[BytecodeRegister],

    // a block is considered filled when all instructions are inserted
    filledBlocks: BitSet,

    // block is considered sealed when the set of predecessors is final
    sealedBlocks: BitSet,

    // tracks all incomplete phi instructions inserted into unsealed blocks
    incompletePhis: HashMap[Block, HashMap[BytecodeRegister, Inst]],
}

impl SsaGen {
    static fn new(graph: Graph, bc: BytecodeFunction, blockMap: BlockMap): SsaGen {
        SsaGen(
            graph,
            bc,
            blockMap,
            None[Block],
            0i32,
            Array[HashMap[Block, Inst]]::new(),
            false,
            Vec[BytecodeRegister]::new(),
            BitSet::new(0),
            BitSet::new(0),
            HashMap[Block, HashMap[BytecodeRegister, Inst]]::new(),
        )
    }

    fn run() {
        self.prepare();
        self.setupArguments();

        for inst in BytecodeIterator::new(self.bc.code) {
            self.instructionStart(inst.start.toInt32());
            self.processInstruction(inst.op);
        }

        assert(self.blockTerminated);
    }

    fn prepare() {
        self.currentBlock = None;
        let blockCount = self.graph.blockCount();

        self.filledBlocks = BitSet::new(blockCount.toInt64());
        self.sealedBlocks = BitSet::new(blockCount.toInt64());

        let data = Vec[HashMap[Block, Inst]]::new();

        for i in std::range(0, self.bc.registers.size()) {
            data.push(HashMap[Block, Inst]::new());
        }

        self.currentDef = data.toArray();
    }

    fn setupArguments() {
        let mut i = 0i32;
        let entryBlock = self.graph.getEntryBlock();
        while i < self.bc.arguments {
            let ty = Type::fromBytecodeType(self.bc.registers(i.toInt64()));
            let argInst = createArgInst(i, ty);
            entryBlock.appendInst(argInst);
            self.writeVariable(BytecodeRegister(i), entryBlock, argInst);
            i = i + 1i32;
        }
    }

    fn current(): Block {
        self.currentBlock.getOrPanic()
    }

    fn writeVariable(register: BytecodeRegister, block: Block, value: Inst) {
        self.currentDef(register.value.toInt64()).insert(block, value);
    }

    fn readVariable(register: BytecodeRegister, block: Block): Inst {
        if self.currentDef(register.value.toInt64()).contains(block) {
            self.currentDef(register.value.toInt64())(block).getOrPanic()
        } else {
            self.readVariableRecursive(register, block)
        }
    }

    fn readVariableRecursive(register: BytecodeRegister, block: Block): Inst {
        let ty = self.bc.registers(register.value.toInt64());
        let ty = Type::fromBytecodeType(ty);

        let value: Inst = if !self.sealedBlocks.contains(block.id().toInt64()) {
            // While all blocks are created with predecessors and successors before
            // this pass in the BlockBuilder already, we still need to handle unsealed blocks.
            // E.g. Register is accessed in while header and updated in the while body.
            // In this case the while header is filled before the while body. If we wouldn't
            // handle unsealed blocks we wouldn't create a Phi instruction, since the
            // while body predecessor is still empty.
            let incomplete = createPhiInst(ty);
            block.appendPhi(incomplete);

            if self.incompletePhis.contains(block) {
                self.incompletePhis(block).getOrPanic().insert(register, incomplete);
            } else {
                let map = HashMap[BytecodeRegister, Inst]::new();
                map.insert(register, incomplete);
                self.incompletePhis.insert(block, map);
            }

            incomplete
        } else if block.predecessors.size() == 1i64 {
            self.readVariable(register, block.predecessors.first().getOrPanic().source)
        } else {
            let phi = createPhiInst(ty);
            block.appendPhi(phi);
            self.writeVariable(register, block, phi);
            self.addPhiOperands(register, phi)
        };

        self.writeVariable(register, block, value);
        value
    }

    fn addPhiOperands(register: BytecodeRegister, phi: Inst): Inst {
        for pred in phi.getBlock().predecessors {
            let inst = self.readVariable(register, pred.source);
            phi.addInput(inst);
        }
        phi.registerUses();
        self.tryRemoveTrivialPhi(phi)
    }

    fn tryRemoveTrivialPhi(phi: Inst): Inst {
        let mut same = None[Inst];

        for inp in phi.getInputs() {
            let op = inp.getValue();

            if (same.isSome() && same.getOrPanic() === op) || op === phi {
                continue;
            }

            if same.isSome() {
                return phi;
            }

            same = Some(op);
        }

        if same.isNone() {
            same = Some(createUndefInst());
        }

        let users = phi.users();

        phi.replaceWith(same.getOrPanic());
        phi.remove();

        for i in std::range(0, users.size()) {
            let user = users(i);

            if user === phi {
                continue;
            }

            if user.isPhi() {
                self.tryRemoveTrivialPhi(user);
            }
        }

        same.getOrPanic()
    }

    fn markBlockTerminated() {
        self.blockTerminated = true;
    }

    fn instructionStart(offset: Int32) {
        self.offset = offset;

        let block = self.blockMap.blockAt(offset.toInt64());

        if block.isSome() {
            if self.currentBlock.isSome() {
                self.blockEndReached(block);
            } else {
                self.currentBlock = block;
            }
        }

        self.blockTerminated = false;
    }

    fn getRegisterType(reg: BytecodeRegister): BytecodeType {
        self.bc.registers(reg.value.toInt64())
    }

    fn processInstruction(inst: BytecodeInstruction) {
       match inst {
            BytecodeInstruction::Add(dest, lhs, rhs) => {
                if self.getRegisterType(dest).isAnyFloat() {
                    self.emitBin(dest, lhs, rhs, Op::Add);
                } else {
                    self.emitBin(dest, lhs, rhs, Op::CheckedAdd);
                }
            },
            BytecodeInstruction::Sub(dest, lhs, rhs) => {
                if self.getRegisterType(dest).isAnyFloat() {
                    self.emitBin(dest, lhs, rhs, Op::Sub);
                } else {
                    self.emitBin(dest, lhs, rhs, Op::CheckedSub);
                }
            },
            BytecodeInstruction::Neg(dest, src) => {
                if self.getRegisterType(dest).isAnyFloat() {
                    self.emitUn(dest, src, Op::Neg);
                } else {
                    self.emitUn(dest, src, Op::CheckedNeg);
                }
            },
            BytecodeInstruction::Mul(dest, lhs, rhs) => {
                if self.getRegisterType(dest).isAnyFloat() {
                    self.emitBin(dest, lhs, rhs, Op::Mul);
                } else {
                    self.emitBin(dest, lhs, rhs, Op::CheckedMul);
                }
            },
            BytecodeInstruction::Div(dest, lhs, rhs) => {
                if self.getRegisterType(dest).isAnyFloat() {
                    self.emitDivMod(dest, lhs, rhs, Op::Div);
                } else {
                    self.emitDivMod(dest, lhs, rhs, Op::CheckedDiv);
                }
            },
            BytecodeInstruction::Mod(dest, lhs, rhs) => {
                if self.getRegisterType(dest).isAnyFloat() {
                    self.emitDivMod(dest, lhs, rhs, Op::Mod);
                } else {
                    self.emitDivMod(dest, lhs, rhs, Op::CheckedMod);
                }
            },
            BytecodeInstruction::And(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::And);
            },
            BytecodeInstruction::Or(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Or);
            },
            BytecodeInstruction::Xor(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Xor);
            },
            BytecodeInstruction::Not(dest, src) => {
                self.emitUn(dest, src, Op::Not);
            },
            BytecodeInstruction::Shl(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Shl);
            },
            BytecodeInstruction::Shr(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Shr);
            },
            BytecodeInstruction::Sar(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Sar);
            },

            BytecodeInstruction::Mov(dest, src) => {
                self.emitMov(dest, src);
            },

            BytecodeInstruction::LoadTupleElement(dest, src, idx)  => {
                unimplemented();
            },
            BytecodeInstruction::LoadEnumElement(dest, src, idx) => {                
                unimplemented();

            },
            BytecodeInstruction::LoadEnumVariant(dest, src, idx) => {
                unimplemented();
            },
            BytecodeInstruction::LoadStructField(dest, src, idx) => {
                unimplemented();
            },

            BytecodeInstruction::LoadField(dest, obj, idx) => {
                self.emitLoadField(dest, obj, idx);
            },
            BytecodeInstruction::StoreField(src, obj, idx) => {
                self.emitStoreField(src, obj, idx);
            },

            BytecodeInstruction::LoadGlobal(dest, global_id) => {
                self.emitLoadGlobal(dest, global_id);
            },
            BytecodeInstruction::StoreGlobal(src, global_id) => {
                self.emitStoreGlobal(src, global_id);
            },

            BytecodeInstruction::PushRegister(src) => {
                self.pushed_registers.push(src);
            },
            
            BytecodeInstruction::ConstTrue(dest) => {
                let inst = createBoolConst(true);
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);
            },
            BytecodeInstruction::ConstFalse(dest) => {
                let inst = createBoolConst(false);
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);
            },
            BytecodeInstruction::ConstUInt8(dest, value) => {
                unimplemented();
            },
            BytecodeInstruction::ConstChar(dest, idx) => {
                let value = self.bc.constPool(idx).toChar().getOrPanic();
                let inst = createInt32Const(value.toInt32());
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);
            },
            BytecodeInstruction::ConstInt32(dest, idx) => {
                let value = self.bc.constPool(idx).toInt32().getOrPanic();
                let inst = createInt32Const(value);
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);
            },
            BytecodeInstruction::ConstInt64(dest, idx) => {
                let value = self.bc.constPool(idx).toInt64().getOrPanic();
                let inst = createInt64Const(value);
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);
            },
            BytecodeInstruction::ConstFloat32(dest, idx) => {
                let value = self.bc.constPool(idx).toFloat32().getOrPanic();
                let inst = createFloat32Const(value);
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);

            },
            BytecodeInstruction::ConstFloat64(dest, idx) => {
                let value = self.bc.constPool(idx).toFloat64().getOrPanic();
                let inst = createFloat64Const(value);
                self.current().appendInst(inst);
                self.writeVariable(dest, self.current(), inst);
            },
            BytecodeInstruction::ConstString(dest, idx) => {
                unimplemented();
            },

            BytecodeInstruction::TestIdentity(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::TestIdentity);
            },
            BytecodeInstruction::TestEq(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Equal);
            },
            BytecodeInstruction::TestNe(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::NotEqual);
            },
            BytecodeInstruction::TestGt(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Greater);
            },
            BytecodeInstruction::TestGe(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::GreaterOrEqual);
            },
            BytecodeInstruction::TestLt(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::Less);
            },
            BytecodeInstruction::TestLe(dest, lhs, rhs) => {
                self.emitBin(dest, lhs, rhs, Op::LessOrEqual);
            },

            BytecodeInstruction::JumpLoop(distance) => {
                let targetBlock = self.blockMap.blockAt((self.offset - distance).toInt64()).getOrPanic();
                let gotoInst = createGotoInst(targetBlock);
                self.current().appendInst(gotoInst);
                self.markBlockTerminated();
            },
            BytecodeInstruction::LoopStart => {
                // nothing to do
            },
            BytecodeInstruction::Jump(distance) => {
                self.emitJump(distance);
            },
            BytecodeInstruction::JumpIfFalse(opnd, distance) => {
                self.emitConditionalJump(opnd, distance, false);
            },
            BytecodeInstruction::JumpIfTrue(opnd, distance) => {
                self.emitConditionalJump(opnd, distance, true);
            },

            BytecodeInstruction::InvokeDirect(dest, idx) => {
                self.emitCall(dest, CallKind::Direct, idx);
            },
            BytecodeInstruction::InvokeVirtual(dest, idx) => {
                self.emitVirtualCall(dest, idx);
            },
            BytecodeInstruction::InvokeStatic(dest, idx) => {
                self.emitCall(dest, CallKind::Static, idx);
            },
            BytecodeInstruction::InvokeLambda(dest, idx) => {
                self.emitLambdaCall(dest, idx);
            },
            BytecodeInstruction::InvokeGenericStatic(dest, idx) => {
                unimplemented();
            },
            BytecodeInstruction::InvokeGenericDirect(dest, idx) => {
                unimplemented();
            },

            BytecodeInstruction::NewObject(dest, idx) => {
                self.emitNewObject(dest, idx);
            },
            BytecodeInstruction::NewObjectInitialized(dest, idx) => {
                self.emitNewObject(dest, idx);
            },
            BytecodeInstruction::NewArray(dest, idx, length) => {
                self.emitNewArray(dest, idx, length);
            },
            BytecodeInstruction::NewTuple(dest, idx) => {
                unimplemented();
            },
            BytecodeInstruction::NewEnum(dest, idx) => {
                unimplemented();
            },
            BytecodeInstruction::NewStruct(dest, idx) => {
                unimplemented();
            },
            BytecodeInstruction::NewTraitObject(dest, idx, obj) => {
                unimplemented();
            },
            BytecodeInstruction::NewLambda(dest, idx) => {
                self.emitNewLambda(dest, idx);
            },
            BytecodeInstruction::ArrayLength(dest, src) => {
                let srcInst = self.readVariable(src, self.current());
                let destInst = createArrayLength(srcInst);
                destInst.set_bytecode_position(self.offset);
                self.current().appendInst(destInst);
                self.writeVariable(dest, self.current(), destInst);
            },
            BytecodeInstruction::LoadArray(dest, arr, idx) => {
                self.emitLoadArray(dest, arr, idx);
            },
            BytecodeInstruction::StoreArray(src, arr, idx) => {
                self.emitStoreArray(src, arr, idx);
            },
            BytecodeInstruction::LoadTraitObjectValue(dest, src) => {
                unimplemented();
            },
            BytecodeInstruction::Ret(opnd) => {
                let ty = self.bc.registers(opnd.value.toInt64());
                let ty = Type::fromBytecodeType(ty);
                self.emitRet(opnd, ty);
            },
        }
    }

    fn blockEndReached(next: Option[Block]) {
        let block = self.current();

        if !self.blockTerminated {
            let gotoInst = createGotoInst(next.getOrPanic());
            block.appendInst(gotoInst);
        }

        // We change the current block, that means all instructions
        // are inserted. The block is now filled.
        self.fillBlock(block);

        // We don't really know when to seal a block from the bytecode
        // Try to seal this block if all predecessors are filled.
        self.trySealBlock(block);

        // This block might have a back edge to a loop header. Since this
        // block is now filled, we might be able to seal another block.
        for succ in block.successors {
            self.trySealBlock(succ.target);
        }

        self.currentBlock = next;
    }

    fn fillBlock(block: Block) {
        assert(!self.filledBlocks.contains(block.id().toInt64()));
        self.filledBlocks.insert(block.id().toInt64());
    }

    fn trySealBlock(block: Block) {
        if self.sealedBlocks.contains(block.id().toInt64()) {
            return;
        }

        // all predecessors need to be filled
        for edge in block.predecessors {
            if !self.filledBlocks.contains(edge.source.id().toInt64()) {
                return;
            }
        }

        self.sealBlock(block);
    }

    fn sealBlock(block: Block) {
        assert(!self.sealedBlocks.contains(block.id().toInt64()));
        self.sealedBlocks.insert(block.id().toInt64());

        let map = self.incompletePhis(block);
        if map.isNone() { return; }

        for variableAndPhi in map.getOrPanic() {
            self.addPhiOperands(variableAndPhi.0, variableAndPhi.1);
        }
    }

    fn emitLoadField(dest: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) {
        let objInst = self.readVariable(obj, self.current());
        let destType = self.bc.registers(dest.value.toInt64());
        let destType = Type::fromBytecodeType(destType);

        let (cls_id, type_params, field_id) = match self.bc.constPool(idx) {
            ConstPoolEntry::Field(cls_id, type_params, field_id) => (cls_id, type_params, field_id),
            _ => unreachable[(ClassId, Array[BytecodeType], FieldId)](),
        };

        let fieldInfo = FieldInfo(
            cls_id,
            type_params,
            field_id,
            None[Int32]
        );

        let destInst = graph::createLoadFieldInst(objInst, fieldInfo, destType);
        destInst.set_bytecode_position(self.offset);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    fn emitStoreField(src: BytecodeRegister, obj: BytecodeRegister, idx: ConstPoolId) {
        let srcInst = self.readVariable(src, self.current());
        let srcType = self.bc.registers(src.value.toInt64());
        let srcType = Type::fromBytecodeType(srcType);

        let objInst = self.readVariable(obj, self.current());

        let (cls_id, type_params, field_id) = match self.bc.constPool(idx) {
            ConstPoolEntry::Field(cls_id, type_params, field_id) => (cls_id, type_params, field_id),
            _ => unreachable[(ClassId, Array[BytecodeType], FieldId)](),
        };

        let fieldInfo = FieldInfo(
            cls_id,
            type_params,
            field_id,
            None[Int32]
        );

        let destInst = graph::createStoreFieldInst(objInst, fieldInfo, srcInst, srcType);
        destInst.set_bytecode_position(self.offset);
        self.current().appendInst(destInst);
    }

    fn emitBin(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(lhs.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };

        let mut lhsInst = self.readVariable(lhs, self.current());
        let mut rhsInst = self.readVariable(rhs, self.current());

        if op.isCommutative() && lhsInst.isConst() {
            let tmp = lhsInst;
            lhsInst = rhsInst;
            rhsInst = tmp;
        }

        let destInst = createBinaryInst(op, ty, lhsInst, rhsInst);
        destInst.set_bytecode_position(self.offset);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    fn emitUn(dest: BytecodeRegister, src: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(dest.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };

        let srcInst = self.readVariable(src, self.current());
        let destInst = createUnaryInst(op, ty, srcInst);
        destInst.set_bytecode_position(self.offset);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    fn emitDivMod(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(dest.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };
        
        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());

        if !registerType.isAnyFloat() {
            let divZeroCheck = createDivZeroCheck(rhsInst);
            divZeroCheck.set_bytecode_position(self.offset);
            self.current().appendInst(divZeroCheck);
        }

        let destInst = createBinaryInst(op, ty, lhsInst, rhsInst);
        destInst.set_bytecode_position(self.offset);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    fn emitMov(dest: BytecodeRegister, src: BytecodeRegister) {
        let srcInst = self.readVariable(src, self.current());
        self.writeVariable(dest, self.current(), srcInst);
    }

    fn emitLoadGlobal(dest: BytecodeRegister, glob: GlobalId) {
        let destType = self.bc.registers(dest.value.toInt64());
        let destType = Type::fromBytecodeType(destType);

        if hasGlobalInitialValue(glob) {
            let inst = graph::createEnsureGlobalInitializedInst(glob, destType);
            self.current().appendInst(inst);
            inst.set_bytecode_position(self.offset);
        }

        let globInst = createLoadGlobalInst(destType, glob);
        self.current().appendInst(globInst);
        self.writeVariable(dest, self.current(), globInst);
    }

    fn emitStoreGlobal(src: BytecodeRegister, glob: GlobalId) {
        let srcType = self.bc.registers(src.value.toInt64());
        let srcType = Type::fromBytecodeType(srcType);

        let srcInst = self.readVariable(src, self.current());
        let globInst = createStoreGlobalInst(srcType, glob, srcInst);
        self.current().appendInst(globInst);

        if hasGlobalInitialValue(glob) {
            let inst = graph::createMarkGlobalInitialized(glob);
            self.current().appendInst(inst);
        }
    }

    fn emitTest(dest: BytecodeRegister, lhs: BytecodeRegister, rhs: BytecodeRegister, op: Op) {
        let registerType = self.bc.registers(lhs.value.toInt64());

        let ty = match registerType {
            BytecodeType::Int32 => Type::int32(),
            BytecodeType::Int64 => Type::int64(),
            BytecodeType::Float32 => Type::float32(),
            BytecodeType::Float64 => Type::float64(),
            _ => unreachable[Type](),
        };

        let lhsInst = self.readVariable(lhs, self.current());
        let rhsInst = self.readVariable(rhs, self.current());
        let destInst = createTestInst(op, ty, lhsInst, rhsInst);
        self.current().appendInst(destInst);
        self.writeVariable(dest, self.current(), destInst);
    }

    fn emitJump(offset: Int32) {
        let targetBlock = self.blockMap.blockAt((self.offset + offset).toInt64()).getOrPanic();
        let gotoInst = createGotoInst(targetBlock);
        self.current().appendInst(gotoInst);
        self.markBlockTerminated();
    }

    fn emitConditionalJump(opnd: BytecodeRegister, distance: Int32, value: Bool) {
        let opndInst = self.readVariable(opnd, self.current());
        let targetBlock = self.blockMap.blockAt((self.offset + distance).toInt64()).getOrPanic();
        let fallthroughBlock = self.blockMap.nextBlockAt((self.offset+1i32).toInt64()).getOrPanic();

        let cond = if value {
            createIfInst(opndInst, targetBlock, fallthroughBlock)
        } else {
            createIfInst(opndInst, fallthroughBlock, targetBlock)
        };

        self.current().appendInst(cond);
        self.markBlockTerminated();
    }

    fn emitLoadArray(dest: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {
        let arrInst = self.readVariable(arr, self.current());
        let idxInst = self.readVariable(idx, self.current());

        let arrayLengthInst = createArrayLength(arrInst);
        self.current().appendInst(arrayLengthInst);

        let boundsCheckInst = createBoundsCheck(idxInst, arrayLengthInst);
        boundsCheckInst.set_bytecode_position(self.offset);
        self.current().appendInst(boundsCheckInst);

        let destType = self.bc.registers(dest.value.toInt64());
        let destType = Type::fromBytecodeType(destType);
        let arrayLoadInst = createLoadArray(arrInst, idxInst, destType);
        self.current().appendInst(arrayLoadInst);

        self.writeVariable(dest, self.current(), arrayLoadInst);
    }

    fn emitStoreArray(src: BytecodeRegister, arr: BytecodeRegister, idx: BytecodeRegister) {
        let srcInst = self.readVariable(src, self.current());
        let arrInst = self.readVariable(arr, self.current());
        let idxInst = self.readVariable(idx, self.current());

        let arrayLengthInst = createArrayLength(arrInst);
        self.current().appendInst(arrayLengthInst);

        let boundsCheckInst = createBoundsCheck(idxInst, arrayLengthInst);
        boundsCheckInst.set_bytecode_position(self.offset);
        self.current().appendInst(boundsCheckInst);

        let arrayStoreInst = createStoreArray(arrInst, idxInst, srcInst, srcInst.getValueType());
        self.current().appendInst(arrayStoreInst);
    }

    fn emitRet(opnd: BytecodeRegister, ty: Type) {
        if ty.isUnit() {
            let inst = createReturnVoidInst();
            self.current().appendInst(inst);
            self.markBlockTerminated();
        } else {
            let value = self.readVariable(opnd, self.current());
            let inst = createReturnInst(value, ty);
            self.current().appendInst(inst);
            self.markBlockTerminated();
        }
    }

    fn emitCall(dest: BytecodeRegister, kind: CallKind, idx: ConstPoolId) {
        let args = Vec[Inst]::new();

        for reg in self.pushed_registers {
            let arg = self.readVariable(reg, self.current());
            args.push(arg);
        }

        self.pushed_registers.clear();

        let ty = Type::fromBytecodeType(self.bc.registers(dest.value.toInt64()));

        let (fct_id, type_params) = match self.bc.constPool(idx) {
            ConstPoolEntry::Fct(fct_id, type_params) => (fct_id, type_params),
            _ => unreachable[(FctId, Array[BytecodeType])](),
        };

        let info = FunctionInfo(fct_id, type_params);

        let inst = graph::createCall(info, kind, args, ty);
        inst.set_bytecode_position(self.offset);
        self.current().appendInst(inst);

        if !ty.isUnit() {
            self.writeVariable(dest, self.current(), inst);
        }
    }

    fn emitVirtualCall(dest: BytecodeRegister, idx: ConstPoolId) {
        let args = Vec[Inst]::new();

        for reg in self.pushed_registers {
            let arg = self.readVariable(reg, self.current());
            args.push(arg);
        }

        self.pushed_registers.clear();

        let ty = Type::fromBytecodeType(self.bc.registers(dest.value.toInt64()));

        let (trait_object_ty, fct_id, type_params) = match self.bc.constPool(idx) {
            ConstPoolEntry::TraitObjectMethod(trait_object_ty, fct_id, type_params) => (trait_object_ty, fct_id, type_params),
            _ => unreachable[(BytecodeType, FctId, Array[BytecodeType])](),
        };

        let info = VirtualFunctionInfo(trait_object_ty, fct_id, type_params);

        let inst = graph::createVirtualCall(info, args, ty);
        inst.set_bytecode_position(self.offset);
        self.current().appendInst(inst);

        if !ty.isUnit() {
            self.writeVariable(dest, self.current(), inst);
        }
    }

    fn emitLambdaCall(dest: BytecodeRegister, idx: ConstPoolId) {
        let args = Vec[Inst]::new();

        for reg in self.pushed_registers {
            let arg = self.readVariable(reg, self.current());
            args.push(arg);
        }

        self.pushed_registers.clear();

        let ty = Type::fromBytecodeType(self.bc.registers(dest.value.toInt64()));

        let (params, return_type) = match self.bc.constPool(idx) {
            ConstPoolEntry::Lambda(params, return_type) => (params, return_type),
            _ => unreachable[(Array[BytecodeType], BytecodeType)](),
        };

        let info = LambdaFunctionInfo(params, return_type);

        let inst = graph::createLambdaCall(info, args, ty);
        inst.set_bytecode_position(self.offset);
        self.current().appendInst(inst);

        if !ty.isUnit() {
            self.writeVariable(dest, self.current(), inst);
        }
    }

    fn emitNewObject(dest: BytecodeRegister, idx: ConstPoolId) {
        let (class_id, type_params) = match self.bc.constPool(idx) {
            ConstPoolEntry::Class(class_id, type_params) => (class_id, type_params),
            _ => unreachable[(ClassId, Array[BytecodeType])](),
        };

        let info = ClassInfo(class_id, type_params);

        let objInst = graph::createNewObject(info);
        objInst.set_bytecode_position(self.offset);
        self.current().appendInst(objInst);

        self.writeVariable(dest, self.current(), objInst);
        let mut field_id = 0i32;

        for reg in self.pushed_registers {
            let arg = self.readVariable(reg, self.current());
            let argTy = Type::fromBytecodeType(self.bc.registers(reg.value.toInt64()));

            let fieldInfo = FieldInfo(
                class_id,
                type_params,
                FieldId(field_id),
                None[Int32]
            );

            let destInst = graph::createStoreFieldInst(objInst, fieldInfo, arg, argTy);
            destInst.set_bytecode_position(self.offset);
            self.current().appendInst(destInst);

            field_id = field_id + 1i32;
        }

        self.pushed_registers.clear();
    }

    fn emitNewLambda(dest: BytecodeRegister, idx: ConstPoolId) {
        let (fct_id, type_params) = match self.bc.constPool(idx) {
            ConstPoolEntry::Fct(fct_id, type_params) => (fct_id, type_params),
            _ => unreachable[(FctId, Array[BytecodeType])](),
        };

        let info = FunctionInfo(fct_id, type_params);

        let objInst = graph::createNewLambda(info);
        objInst.set_bytecode_position(self.offset);
        self.current().appendInst(objInst);

        self.writeVariable(dest, self.current(), objInst);

        if !self.pushed_registers.isEmpty() {
            assert(self.pushed_registers.size() == 1);
            let reg = self.pushed_registers.first().getOrPanic();
            let arg = self.readVariable(reg, self.current());
            let argTy = Type::fromBytecodeType(self.bc.registers(reg.value.toInt64()));

            let fieldInfo = FieldInfo(
                ClassId(0i32),
                Array[BytecodeType]::new(),
                FieldId(0i32),
                Some[Int32](OBJECT_HEADER_LENGTH)
            );

            let destInst = graph::createStoreFieldInst(objInst, fieldInfo, arg, argTy);
            destInst.set_bytecode_position(self.offset);
            self.current().appendInst(destInst);
        }

        self.pushed_registers.clear();
    }

    fn emitNewArray(dest: BytecodeRegister, idx: ConstPoolId, length: BytecodeRegister) {
        let (class_id, type_params) = match self.bc.constPool(idx) {
            ConstPoolEntry::Class(class_id, type_params) => (class_id, type_params),
            _ => unreachable[(ClassId, Array[BytecodeType])](),
        };

        let info = ClassInfo(class_id, type_params);
        let lengthInst = self.readVariable(length, self.current());

        let objInst = graph::createNewArray(info, lengthInst);
        objInst.set_bytecode_position(self.offset);
        self.current().appendInst(objInst);

        self.writeVariable(dest, self.current(), objInst);
    }
}

fn createBlocks(graph: Graph, bc: BytecodeFunction): BlockMap {
    let blockMap = BlockMap::new(bc);

    // The first pass creates blocks
    BlockCreator::new(graph, bc, blockMap).run();

    blockMap
}

fn createEdges(graph: Graph, bc: BytecodeFunction, blockMap: BlockMap) {
    // The second pass creates edges between blocks
    EdgeCreator::new(graph, bc, blockMap).run();
}

class BlockMap {
    bc: BytecodeFunction,
    blocks: HashMap[Int64, Block],
}

impl BlockMap {
    static fn new(bc: BytecodeFunction): BlockMap {
        BlockMap(bc, HashMap[Int64, Block]::new())
    }

    fn insert(offset: Int64, block: Block) {
        self.blocks.insert(offset, block);
    }

    fn blockAt(offset: Int64): Option[Block] {
        self.blocks(offset)
    }

    fn nextBlockAt(offset: Int64): Option[Block] {
        let mut offset = offset;

        while offset < self.bc.code.size() {
            let result = self.blockAt(offset);
            if result.isSome() { return result; }
            offset = offset + 1i64;
        }

        None
    }
}

class EdgeCreator {
    graph: Graph,
    bc: BytecodeFunction,
    blockMap: BlockMap,
    currentBlock: Option[Block],
    blockTerminated: Bool,
}

impl EdgeCreator {
    static fn new(graph: Graph, bc: BytecodeFunction, blockMap: BlockMap): EdgeCreator {
        EdgeCreator(graph, bc, blockMap, None[Block], false)
    }

    fn run() {
        for inst in BytecodeIterator::new(self.bc.code) {
            self.instructionStart(inst.start);
            self.processInstruction(inst.start, inst.size, inst.op);
        }
    }

    fn processInstruction(offset: Int64, size: Int64, inst: BytecodeInstruction) {
        match inst {
            BytecodeInstruction::JumpLoop(distance) => {
                let targetBlock = self.blockMap.blockAt(offset - distance.toInt64()).getOrPanic();
                self.currentBlock.getOrPanic().addSuccessor(targetBlock);
                self.markBlockTerminated();
            },
            BytecodeInstruction::JumpIfFalse(_opnd, distance) => {
                let targetBlock = self.blockMap.blockAt(offset + distance.toInt64()).getOrPanic();
                self.currentBlock.getOrPanic().addSuccessor(targetBlock);
            },
            BytecodeInstruction::JumpIfTrue(_opnd, distance) => {
                let targetBlock = self.blockMap.blockAt(offset + distance.toInt64()).getOrPanic();
                self.currentBlock.getOrPanic().addSuccessor(targetBlock);
            },
            BytecodeInstruction::Jump(distance) => {
                let targetBlock = self.blockMap.blockAt(offset + distance.toInt64()).getOrPanic();
                self.currentBlock.getOrPanic().addSuccessor(targetBlock);
                self.markBlockTerminated();
            },
            BytecodeInstruction::Ret(_) => {
                self.markBlockTerminated();
            },

            _ => {
                // Non-terminator instruction
            },
        }
    }

    fn instructionStart(offset: Int64) {
        let result = self.blockMap.blocks(offset);

        if result.isSome() {
            let nextBlock = result.getOrPanic();

            if self.currentBlock.isSome() {
                if !self.blockTerminated {
                    self.currentBlock.getOrPanic().addSuccessor(nextBlock);
                }
            }

            self.currentBlock = Some(nextBlock);
        }

        self.blockTerminated = false;
    }

    fn markBlockTerminated() {
        self.blockTerminated = true;
    }
}

class BlockCreator {
    graph: Graph,
    bc: BytecodeFunction,
    blockMap: BlockMap,
    blockStarts: BitSet,
}

impl BlockCreator {
    static fn new(graph: Graph, bc: BytecodeFunction, blockMap: BlockMap): BlockCreator {
        BlockCreator(
            graph,
            bc,
            blockMap,
            BitSet::new(bc.code.size())
        )
    }

    fn run() {
        // create block for first instruction
        let entryBlock = self.ensureBlock(0).getOrPanic();
        self.graph.setEntryBlock(entryBlock);

        for instInfo in BytecodeIterator::new(self.bc.code) {
            let start = instInfo.start;

            if self.blockStarts.contains(start) {
                self.ensureBlock(start);
            }

            self.processInstruction(start, instInfo.size, instInfo.op);
        }
    }

    fn processInstruction(start: Int64, size: Int64, inst: BytecodeInstruction) {
        match inst {
            BytecodeInstruction::Ret(_) => {
                self.ensureBlock(start + size);
            },
            BytecodeInstruction::LoopStart => {
                self.ensureBlock(start);
            },
            BytecodeInstruction::JumpLoop(distance) => {
                let target = start - distance.toInt64();
                assert(self.blockMap.blockAt(target).isSome());
            },
            BytecodeInstruction::JumpIfFalse(_opnd, distance) => {
                self.ensureBlockLazy(start + distance.toInt64());
                self.ensureBlock(start + size);
            },
            BytecodeInstruction::JumpIfTrue(_opnd, distance) => {
                self.ensureBlockLazy(start + distance.toInt64());
                self.ensureBlock(start + size);
            },
            BytecodeInstruction::Jump(distance) => {
                self.ensureBlockLazy(start + distance.toInt64());
                self.ensureBlock(start + size);
            },

            _ => {
                // Non-terminator instruction
            },
        }
    }

    fn ensureBlock(offset: Int64): Option[Block] {
        assert(offset <= self.bc.code.size());
        if offset == self.bc.code.size() {
            return None;
        }

        let result = self.blockMap.blockAt(offset);
        if result.isSome() { return result; }

        let block = Block::new();
        self.graph.addBlock(block);
        self.blockMap.insert(offset, block);
        Some(block)
    }

    fn ensureBlockLazy(offset: Int64) {
        self.blockStarts.insert(offset);
    }
}
