use package::interface::{Architecture, CompilationInfo, config, TRAP_DIV0};
use package::codegen::{CODE_SIZE_ALIGNMENT, CodeGen, CodeDescriptor, CommentTable, Location, LocationTable};
use package::assembler::arm64::AssemblerArm64;
use package::assembler::arm64::{R0, R1, R2, R3, R4, R5, R6, R7, R10, R11};
use package::assembler::arm64::{REG_FP, REG_SP, REG_LR};
use package::assembler::{Label, RegSet, Register};
use package::graph::{Inst, Op, LocationData};

pub class CodeGenArm64 {
    info: CompilationInfo,
    asm: AssemblerArm64,
    locations: LocationTable,
    comments: CommentTable,
    deferred: Vec[(): ()],
}

impl CodeGenArm64 {
    pub static fn new(info: CompilationInfo): CodeGenArm64 {
        CodeGenArm64(
            info,
            AssemblerArm64::new(),
            LocationTable::new(),
            CommentTable::new(),
            Vec[(): ()]::new(),
        )
    }

    pub fn generate(): Array[UInt8] {
        self.asm.ret();
        self.asm.finalize()
    }

    fn epilog() {
        self.emitComment("epilog");
        self.asm.mov(REG_SP, REG_FP);
        self.asm.ldp_post(REG_FP, REG_LR, REG_SP, 16i32);
        self.asm.ret();
    }

    fn trap(tmp: Register, trap: Int32, loc: Location) {
        self.asm.movz(CCALL_REG_PARAMS(0), trap, 0i32);
        self.mov_imm(tmp, config.trap_trampoline.toInt64());
        self.asm.bl_r(tmp);
        self.locations.insert(self.asm.position(), loc);
    }

    fn mov_imm(dest: Register, imm: Int64) {
        self.asm.movz(dest, (imm & 0xFF_FF).toInt32(), 0i32);
        self.asm.movk(dest, ((imm >> 16i32) & 0xFF_FF).toInt32(), 16i32);
        self.asm.movk(dest, ((imm >> 32i32) & 0xFF_FF).toInt32(), 32i32);
        self.asm.movk(dest, ((imm >> 48i32) & 0xFF_FF).toInt32(), 48i32);
    }

    fn emitComment(comment: String) {
        self.comments.insert(self.asm.position(), comment);
    }

    fn emitDeferredCode() {
        for code in self.deferred {
            code();
        }
    }
}

let REG_PARAMS: Array[Register] = Array[Register]::new(R0, R1, R2, R3, R4, R5, R6, R7);
let CCALL_REG_PARAMS: Array[Register] = REG_PARAMS;

let REG_TMP1: Register = R10;
let REG_TMP2: Register = R11;

impl CodeGen for CodeGenArm64 {
    fn allocatableRegisters(): RegSet {
        RegSet::new(R0, R1, R2, R3, R4, R5, R6, R7)
    }

    fn argumentRegister(idx: Int64): Register {
        REG_PARAMS(idx)
    }

    fn prolog() {
        self.asm.stp_pre(REG_FP, REG_LR, REG_SP, -16i32);
        self.asm.mov(REG_FP, REG_SP);
    }

    fn emitInt64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movz(register, inst.auxAsInt64().toInt32(), 0i32);
    }

    fn emitCheckedAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();

        self.asm.add(output, lhs, rhs);
    }

    fn emitCheckedSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();

        self.asm.sub(output, lhs, rhs);
    }

    fn emitCheckedMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();

        self.asm.mul(output, lhs, rhs);
    }

    fn emitCheckedDiv(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();

        self.asm.sdiv(output, lhs, rhs);
    }

    fn emitCheckedMod(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();

        self.emitComment("CheckedMod");
        self.asm.sdiv(output, lhs, rhs);
        self.asm.msub(output, REG_TMP1, rhs, lhs);
    }

    fn emitDivZeroCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let op = loc.getInput(0).getRegister();

        let lbl_failure = self.asm.createLabel();
        self.emitComment("div-by-0 check");
        self.asm.cbz(op, lbl_failure);

        self.deferred.push(|| {
            self.emitComment("slow path for div-by-0 check");
            self.asm.bindLabel(lbl_failure);
            self.trap(REG_TMP1, TRAP_DIV0, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitReturn(inst: Inst) {
        if inst.hasInput() {
            let loc = inst.getLocationData();
            let register = loc.getInput(0).getRegister();

            if R0 != register {
                self.asm.mov(R0, register);
            }
        }

        self.epilog();
    }

    fn finalize(): CodeDescriptor {
        self.emitDeferredCode();
        self.asm.resolveJumps();
        if self.asm.size() % CODE_SIZE_ALIGNMENT != 0 {
            self.emitComment("align code");
            self.asm.alignCodeSize(CODE_SIZE_ALIGNMENT);
        }
        let code = self.asm.finalize();

        CodeDescriptor(
            code,
            self.comments,
            self.locations,
        )
    }
}
