use package::interface::CompilationInfo;
use package::interface::Architecture;
use package::codegen::{CodeGen, CodeDescriptor, CommentTable};
use package::assembler::arm64::AssemblerArm64;
use package::assembler::arm64::{R0, R1, R2, R3, R4, R5, R6, R7};
use package::assembler::arm64::{REG_FP, REG_SP, REG_LR};
use package::assembler::{Label, RegSet, Register};
use package::graph::{Inst, Op, LocationData};

pub class CodeGenArm64 {
  info: CompilationInfo,
  asm: AssemblerArm64,
}

impl CodeGenArm64 {
  pub static fn new(info: CompilationInfo): CodeGenArm64 {
    CodeGenArm64(info, AssemblerArm64::new())
  }

  pub fn generate(): Array[UInt8] {
    assert(self.info.arch == Architecture::Arm64);
    self.asm.ret();
    self.asm.finalize()
  }

  fn epilog() {
    self.asm.mov(REG_SP, REG_FP);
    self.asm
        .ldp_post(REG_FP, REG_LR, REG_SP, 16i32);
    self.asm.ret();
  }
}

let REG_PARAMS: Array[Register] = Array[Register]::new(R0, R1, R2, R3, R4, R5, R6, R7);

impl CodeGen for CodeGenArm64 {
  fn allocatableRegisters(): RegSet {
    RegSet::new(R0, R1, R2, R3, R4, R5, R6, R7)
  }

  fn prolog() {
    self.asm
        .stp_pre(REG_FP, REG_LR, REG_SP, -16i32);
    self.asm.mov(REG_FP, REG_SP);
  }

  fn setLocationConstraints(inst: Inst) {
    let loc = LocationData::new();

    match inst.op() {
        Op::Arg => {
            let idx = inst.auxAsInt32().toInt64();
            loc.setOutputRegister(REG_PARAMS(idx));
        },

        Op::Int64Const => {
            loc.setOutputNeeded();
        },

        Op::Add => {
            loc.setOutputNeeded();
        },

        Op::Return => {
            // no output needed
        },

        _ => {}
    }

    inst.setLocationData(loc);
  }

  fn emit(inst: Inst) {
    let loc = inst.getLocationData();

    match inst.op() {
      Op::Arg => {},

      Op::Int64Const => {
        let register = loc.output().getOrPanic().getRegister();
        self.asm.movz(register, inst.auxAsInt64().toInt32(), 0i32);
      },

      Op::Add => {
          let lhs = inst.getInput(0).getValue();
          let lhs = lhs.getLocationData().output().getOrPanic().getRegister();

          let rhs = inst.getInput(1).getValue();
          let rhs = rhs.getLocationData().output().getOrPanic().getRegister();

          let output = loc.output().getOrPanic().getRegister();

          self.asm.add(output, lhs, rhs);
      },

      Op::Return => {
        if !inst.getInputs().isEmpty() {
            let value = inst.getInput(0).getValue();
            let register = value.getLocationData().output().getOrPanic().getRegister();

            if R0 != register {
              self.asm.mov(R0, register);
            }
        }

        self.epilog();
      },

      _ => {
        unreachable[()]();
      }
    }
  }

  fn finalize(): CodeDescriptor {
    let code = self.asm.finalize();

    CodeDescriptor(
      code,
      CommentTable::new(),
    )
  }
}
