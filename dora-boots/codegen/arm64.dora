use package::bytecode::{ConstPoolId, Location};
use package::interface::{Address, Architecture, CompilationInfo, ConstPool, ConstPoolEntry, ConstPoolValue, config, getFunctionAddress, getFieldOffset, getClassSize, getClassPointer};
use package::interface::{THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET, THREAD_LOCAL_DATA_STATE_OFFSET, THREAD_LOCAL_DATA_MARKING_OFFSET, OBJECT_HEADER_LENGTH, OBJECT_METADATA_OFFSET, METADATA_REMEMBERED_BIT, ARRAY_HEADER_LENGTH};
use package::interface::{THREAD_LOCAL_DATA_TLAB_TOP_OFFSET, THREAD_LOCAL_DATA_TLAB_END_OFFSET};
use package::interface::{TRAP_DIV0, TRAP_OVERFLOW, TRAP_INDEX_OUT_OF_BOUNDS};
use package::codegen::{CODE_SIZE_ALIGNMENT, CodeGen};
use package::assembler::arm64::{F0, F1, F2, F3, F4, F5, F6, F7, F31};
use package::assembler::arm64::{AssemblerArm64, Cond, Extend, Shift, registerName, fitsMovz, fitsMovn};
use package::assembler::arm64::{R0, R1, R2, R3, R4, R5, R6, R7};
use package::assembler::arm64::{R8, R9, R10, R11, R12, R13, R14};
use package::assembler::arm64::{R15, R16, R19, R20, R21, R22, R23};
use package::assembler::arm64::{R24, R25, R26, R27, R28};
use package::assembler::arm64::{REG_FP, REG_SP, REG_LR, REG_ZERO};
use package::assembler::{FloatRegister, Label, RegSet, Register};
use package::graph::{Inst, Op, LocationData, RegisterSnapshot, Type};
use package::location::{useInputFloatRegisterFixed, useInputRegister, useInputRegisterFixed, useOutputRegister};
use package::{CodeDescriptor, CommentTable, GcPointTable, LazyCompilationData, LazyCompilationSite, LazyCompilationSiteDirect, LocationTable};

let REG_PARAMS: Array[Register] = Array[Register]::new(R0, R1, R2, R3, R4, R5, R6, R7);
let FLOAT_REG_PARAMS: Array[FloatRegister] = Array[FloatRegister]::new(F0, F1, F2, F3, F4, F5, F6, F7);

let CCALL_REG_PARAMS: Array[Register] = REG_PARAMS;

let REG_TEMP: Register = R16;
let FREG_TEMP: FloatRegister = F31;
let REG_THREAD: Register = R28;

let ALLOCATABLE_REGS: RegSet[Register] = RegSet[Register]::new(
    R0 , R1 , R2 , R3 ,
    R4 , R5 , R6 , R7 ,
    R8 , R9 , R10, R11,
    R12, R13, R14, R15,
                   R19,
    // R16 is REG_TEMP
    // R17 and R18 are platform registers
    R20, R21, R22, R23,
    R24, R25, R26, R27,
    // R28 is REG_THREAD
    // R29 is FP
    // R30 is LR
);

// The last register F31 is used as FREG_TEMP.
let ALLOCATABLE_FREGS: RegSet[FloatRegister] = RegSet[FloatRegister]::firstN(31i32);

let CALLEE_SAVED_REGS: RegSet[Register] = RegSet[Register]::new(
    R19, R20, R21, R22, R23, R24, R25, R26, R27, R28
);

pub class CodeGenArm64 {
    ci: CompilationInfo,
    asm: AssemblerArm64,
    constPool: ConstPool,
    lazyCompilation: LazyCompilationData,
    gcPoints: GcPointTable,
    locations: LocationTable,
    comments: CommentTable,
    deferred: Vec[(): ()],
}

impl CodeGenArm64 {
    pub static fn new(ci: CompilationInfo): CodeGenArm64 {
        CodeGenArm64(
            ci,
            AssemblerArm64::new(),
            ConstPool::new(),
            LazyCompilationData::new(),
            GcPointTable::new(),
            LocationTable::new(),
            CommentTable::new(),
            Vec[(): ()]::new(),
        )
    }

    pub fn generate(): Array[UInt8] {
        self.asm.ret();
        self.asm.finalize()
    }

    fn epilog() {
        self.emitComment("epilog");
        self.asm.mov(REG_SP, REG_FP);
        self.asm.ldp_post(REG_FP, REG_LR, REG_SP, 16i32);
        self.asm.ret();
    }

    fn trap(tmp: Register, trap: Int32, loc: Location) {
        self.asm.movz(CCALL_REG_PARAMS(0), trap, 0i32);
        self.mov_imm(tmp, config.trap_trampoline.toInt64());
        self.asm.bl_r(tmp);
        self.locations.insert(self.asm.position(), loc);
    }

    fn mov_imm(dest: Register, imm: Int64) {
        let fits_movz = fitsMovz(imm, 64);

        if fits_movz.isSome() {
            let (value, shift) = fits_movz.getOrPanic();
            self.asm.movz(dest, value.toInt32(), shift.toInt32());
        } else {
            let fits_movn = fitsMovn(imm, 64);

            if fits_movn.isSome() {
                let (value, shift) = fits_movn.getOrPanic();
                self.asm.movn(dest, value.toInt32(), shift.toInt32());
            } else {
                self.asm.movz(dest, (imm & 0xFF_FF).toInt32(), 0i32);
                self.asm.movk(dest, ((imm >> 16i32) & 0xFF_FF).toInt32(), 16i32);
                self.asm.movk(dest, ((imm >> 32i32) & 0xFF_FF).toInt32(), 32i32);
                self.asm.movk(dest, ((imm >> 48i32) & 0xFF_FF).toInt32(), 48i32);
            }
        }
    }

    fn mov_imm_w(dest: Register, imm: Int32) {
        let fits_movz = fitsMovz(imm.toInt64(), 32);

        if fits_movz.isSome() {
            let (value, shift) = fits_movz.getOrPanic();
            self.asm.movz(dest, value.toInt32(), shift.toInt32());
        } else {
            let fits_movn = fitsMovn(imm.toInt64(), 32);

            if fits_movn.isSome() {
                let (value, shift) = fits_movn.getOrPanic();
                self.asm.movn(dest, value.toInt32(), shift.toInt32());
            } else {
                self.asm.movz_w(dest, imm & 0xFF_FFi32, 0i32);
                self.asm.movk_w(dest, (imm >> 16i32) & 0xFF_FFi32, 16i32);
            }
        }
    }

    fn mov_imm_f32(dest: FloatRegister, scratch: Register, value: Float32) {
        let entry = self.constPool.push(ConstPoolValue::Float32(value));
        let disp = self.asm.position() + entry.disp;
        self.asm.adr_imm(scratch, -disp);
        self.asm.ldr_imm_s(dest, scratch, 0i32);
    }

    fn mov_imm_f64(dest: FloatRegister, scratch: Register, value: Float64) {
        let entry = self.constPool.push(ConstPoolValue::Float64(value));
        let disp = self.asm.position() + entry.disp;
        self.asm.adr_imm(scratch, -disp);
        self.asm.ldr_imm_d(dest, scratch, 0i32);
    }

    fn loadConstPool(dest: Register, entry: ConstPoolEntry) {
        let offset = -(self.asm.position() + entry.disp);
        self.asm.adr_imm(dest, offset);
        self.asm.ldr_imm(dest, dest, 0i32);
    }

    fn emitDeferredCode() {
        for code in self.deferred {
            code();
        }
    }

    fn emitCheckedDivModCommon(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        assert(inst.op() == Op::CheckedDiv || inst.op() == Op::CheckedMod);
        let is_div = inst.op() == Op::CheckedDiv;

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();
        let lbl_div = self.asm.createLabel();

        self.asm.movz(REG_TEMP, 0x8000i32, 48i32);
        self.asm.cmp(lhs, REG_TEMP);
        self.asm.bc(Cond::NE, lbl_div);
        self.asm.cmn_imm(rhs, 1i32);
        self.asm.bc(Cond::EQ, lbl_overflow);

        self.asm.bindLabel(lbl_div);
        if is_div {
            self.asm.sdiv(dest, lhs, rhs);
        } else {
            self.asm.sdiv(REG_TEMP, lhs, rhs);
            self.asm.msub(dest, REG_TEMP, rhs, lhs);
        }

        self.deferred.push(|| {
            let op = if is_div { "CheckedDiv" } else { "CheckedMod" };
            self.emitComment("slow path for ${op} overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitWriteBarrier(host: Register, value: Register, scratch: Register, snapshot: RegisterSnapshot) {
        let lbl_object_slow_path = self.asm.createLabel();
        let lbl_marking_slow_path = self.asm.createLabel();

        self.asm.ldrb_imm(scratch, REG_THREAD, THREAD_LOCAL_DATA_MARKING_OFFSET);
        self.asm.cbnz_w(scratch, lbl_marking_slow_path);

        self.asm.ldrb_imm(scratch, host, OBJECT_METADATA_OFFSET);
        self.asm.tbz(scratch, METADATA_REMEMBERED_BIT, lbl_object_slow_path);
        let lbl_return = self.asm.createAndBindLabel();

        self.deferred.push(|| {
            self.emitComment("marking barrier slow path");
            self.asm.bindLabel(lbl_marking_slow_path);
            self.asm.brk(0i32);
            self.asm.b(lbl_return);
        });

        self.deferred.push(|| {
            self.emitComment("object barrier slow path");
            self.asm.bindLabel(lbl_object_slow_path);
            self.asm.cbz(value, lbl_return);
            self.saveRegistersForCall(snapshot);
            self.asm.mov(CCALL_REG_PARAMS(0), host);
            self.asm.mov(CCALL_REG_PARAMS(1), value);
            self.mov_imm(REG_TEMP, config.object_write_barrier_slow_path.toInt64());
            self.asm.bl_r(REG_TEMP);
            self.restoreRegistersForCall(snapshot);
            self.asm.b(lbl_return);
        });
    }

    fn emitObjectAllocate(obj: Register, size: Int32, tmp1: Register, tmp2: Register, snapshot: RegisterSnapshot) {
        let lbl_alloc_slow_path = self.asm.createLabel();

        self.asm.ldr_imm(obj, REG_THREAD, THREAD_LOCAL_DATA_TLAB_TOP_OFFSET);
        self.asm.ldr_imm(tmp1, REG_THREAD, THREAD_LOCAL_DATA_TLAB_END_OFFSET);

        self.asm.add_imm(tmp2, obj, size);
        self.asm.cmp(tmp2, tmp1);
        self.asm.bc(Cond::GT, lbl_alloc_slow_path);
        self.asm.str_imm(tmp2, REG_THREAD, THREAD_LOCAL_DATA_TLAB_TOP_OFFSET);
        let lbl_return = self.asm.createAndBindLabel();

        assert(snapshot.gp.remove(obj));

        self.deferred.push(|| {
            self.emitComment("allocation slow path");
            self.asm.bindLabel(lbl_alloc_slow_path);
            self.saveRegistersForCall(snapshot);
            self.mov_imm(CCALL_REG_PARAMS(0), size.toInt64());
            self.mov_imm(REG_TEMP, config.allocation_slow_path.toInt64());
            self.asm.bl_r(REG_TEMP);
            self.asm.mov(obj, R0);
            self.restoreRegistersForCall(snapshot);
            self.asm.b(lbl_return);
        });
    }

    fn emitObjectInitialization(obj: Register, classptr: Address, tmp: Register) {
        let metadata_part = 0xFF_FF_FF_FCi32 | 1i32 << METADATA_REMEMBERED_BIT;
        let classptr_part = classptr.value - config.meta_space_start.value;

        let header_word = metadata_part.toInt64() << 32i32 | classptr_part;
        self.mov_imm(tmp, header_word);
        self.asm.str_imm(tmp, obj, 0i32);
    }

    fn saveRegistersForCall(snapshot: RegisterSnapshot) {
        let regs = snapshot.gp.clone().difference(CALLEE_SAVED_REGS);

        if regs.size() % 2 != 0 {
            let zero = REG_ZERO;
            assert(!regs.contains(zero));
            regs.add(zero);
        }

        while !regs.isEmpty() {
            let rt = regs.popLowestIndex().getOrPanic();
            let rt2 = regs.popLowestIndex().getOrPanic();
            self.asm.stp_pre(rt, rt2, REG_SP, -16i32);
        }

        let regs = snapshot.fp.clone();

        if regs.size() % 2 != 0 {
            assert(!regs.contains(FREG_TEMP));
            regs.add(FREG_TEMP);
        }

        while !regs.isEmpty() {
            let rt = regs.popLowestIndex().getOrPanic();
            let rt2 = regs.popLowestIndex().getOrPanic();
            self.asm.stp_pre_d(rt, rt2, REG_SP, -16i32);
        }
    }

    fn restoreRegistersForCall(snapshot: RegisterSnapshot) {
        let regs = snapshot.gp.clone().difference(CALLEE_SAVED_REGS);

        if regs.size() % 2 != 0 {
            let zero = REG_ZERO;
            assert(!regs.contains(zero));
            regs.add(zero);
        }

        while !regs.isEmpty() {
            let rt2 = regs.popHighestIndex().getOrPanic();
            let rt = regs.popHighestIndex().getOrPanic();
            self.asm.ldp_post(rt, rt2, REG_SP, 16i32);
        }

        let regs = snapshot.fp.clone();

        if regs.size() % 2 != 0 {
            assert(!regs.contains(FREG_TEMP));
            regs.add(FREG_TEMP);
        }

        while !regs.isEmpty() {
            let rt2 = regs.popHighestIndex().getOrPanic();
            let rt = regs.popHighestIndex().getOrPanic();
            self.asm.ldp_post_d(rt, rt2, REG_SP, 16i32);
        }
    }
}

impl CodeGen for CodeGenArm64 {
    fn allocatableRegisters(): RegSet[Register] {
        ALLOCATABLE_REGS
    }

    fn allocatableFloatRegisters(): RegSet[FloatRegister] {
        ALLOCATABLE_FREGS
    }

    fn argumentRegister(idx: Int64): Register {
        REG_PARAMS(idx)
    }

    fn argumentRegisters(): Array[Register] {
        REG_PARAMS
    }

    fn argumentFloatRegisters(): Array[FloatRegister] {
        FLOAT_REG_PARAMS
    }

    fn getScratchRegister(): Register {
        REG_TEMP
    }

    fn getFloatScratchRegister(): FloatRegister {
        FREG_TEMP
    }

    fn getReturnRegister(): Register {
        R0
    }

    fn getFloatReturnRegister(): FloatRegister {
        F0
    }

    fn emitDebug() {
        self.asm.brk(0i32);
    }

    fn emitProlog(stackSize: Int32) {
        self.asm.stp_pre(REG_FP, REG_LR, REG_SP, -16i32);
        self.asm.mov(REG_FP, REG_SP);

        if stackSize > 0i32 {
            self.asm.sub_imm(REG_SP, REG_SP, stackSize);
        }
    }

    fn emitStackLimitCheck() {
        let lbl_stack_overflow = self.asm.createLabel();
        self.asm.ldr_imm(REG_TEMP, REG_THREAD, THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET);
        self.asm.cmp_ext(REG_SP, REG_TEMP, Extend::UXTX, 0i32);
        self.asm.bc(Cond::CC, lbl_stack_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for stack limit check");
            self.asm.bindLabel(lbl_stack_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.loc);
        });
    }

    fn emitSafepointCheck() {
        let lbl_safepoint = self.asm.createLabel();
        self.asm.ldrb_imm(REG_TEMP, REG_THREAD, THREAD_LOCAL_DATA_STATE_OFFSET);
        self.asm.cbnz(REG_TEMP, lbl_safepoint);

        self.deferred.push(|| {
            self.emitComment("slow path safepoint");
            self.asm.bindLabel(lbl_safepoint);

            self.mov_imm(REG_TEMP, config.safepoint_trampoline.toInt64());
            self.asm.bl_r(REG_TEMP);
            self.locations.insert(self.asm.position(), self.ci.loc);
        });
    }

    fn emitComment(comment: String) {
        self.comments.insert(self.asm.position(), comment);
    }

    fn registerName(register: Register): String {
        registerName(register)
    }

    fn createLabel(): Label {
        self.asm.createLabel()
    }

    fn bindLabel(label: Label) {
        self.asm.bindLabel(label);
    }

    fn spill(inst: Inst) {
        let loc = inst.getLocationData();
        let slot = loc.getSpillSlot();
        let ty = inst.getValueType();

        if ty.isAnyFloat() {
            let reg = loc.getOutput().getFloatRegister();

            if ty == Type::Float32 {
                self.asm.stur_s(reg, REG_FP, slot);
            } else {
                assert(ty == Type::Float64);
                self.asm.stur_d(reg, REG_FP, slot);
            }
        } else {
            let reg = loc.getOutput().getRegister();

            if ty == Type::Int32 {
                self.asm.stur_w(reg, REG_FP, slot);
            } else {
                assert(ty == Type::Int64);
                self.asm.stur(reg, REG_FP, slot);
            }
        }
    }

    fn setLocationConstraintsCheckedAdd(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegister(inst);
    }

    fn setLocationConstraintsCheckedSub(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegister(inst);
    }

    fn setLocationConstraintsCheckedMul(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegister(inst);
    }

    fn setLocationConstraintsCheckedDiv(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegister(inst);
    }

    fn setLocationConstraintsCheckedMod(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegister(inst);
    }

    fn setLocationConstraintsReturn(inst: Inst, loc: LocationData) {
        if inst.hasInput() {
            if inst.getOperationType().isAnyFloat() {
                useInputFloatRegisterFixed(inst, 0, F0);
            } else {
                useInputRegisterFixed(inst, 0, R0);
            }
        }
    }

    fn emitTrueConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movz_w(register, 1i32, 0i32);
    }

    fn emitFalseConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movz_w(register, 0i32, 0i32);
    }

    fn emitInt32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.mov_imm_w(register, inst.getValueAsInt32());
    }

    fn emitInt64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.mov_imm(register, inst.getValueAsInt64());
    }

    fn emitFloat32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getFloatRegister();
        self.mov_imm_f32(register, REG_TEMP, inst.getValueAsFloat32());
    }

    fn emitFloat64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getFloatRegister();
        self.mov_imm_f64(register, REG_TEMP, inst.getValueAsFloat64());
    }

    fn emitAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.fadd_s(output, lhs, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.fadd_d(output, lhs, rhs);
        }
    }

    fn emitSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.fsub_s(output, lhs, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.fsub_d(output, lhs, rhs);
        }
    }

    fn emitMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.fmul_s(output, lhs, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.fmul_d(output, lhs, rhs);
        }
    }

    fn emitDiv(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.fdiv_s(output, lhs, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.fdiv_d(output, lhs, rhs);
        }
    }

    fn emitNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getFloatRegister();
        let dest = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.fneg_s(dest, src);
        } else {
            assert(ty == Type::Float64);
            self.asm.fneg_d(dest, src);
        }
    }

    fn emitCheckedAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        if inst.getValueType() == Type::Int32 {
            self.asm.adds_w(output, lhs, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.adds(output, lhs, rhs);
        }

        self.asm.bc(Cond::VS, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedAdd overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        if inst.getValueType() == Type::Int32 {
            self.asm.subs_w(output, lhs, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.subs(output, lhs, rhs);
        }

        self.asm.bc(Cond::VS, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedSub overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();
        assert(dest != lhs && dest != rhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.smull(dest, lhs, rhs);
            self.asm.cmp_ext(dest, dest, Extend::SXTW, 0i32);
            self.asm.bc(Cond::NE, lbl_overflow);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.mul(dest, lhs, rhs);
            self.asm.smulh(REG_TEMP, lhs, rhs);
            self.asm.cmp_sh(REG_TEMP, dest, Shift::ASR, 63i32);
            self.asm.bc(Cond::NE, lbl_overflow);
        }

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedMul overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedDiv(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitCheckedMod(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitDivZeroCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let op = loc.getInput(0).getRegister();

        let lbl_failure = self.asm.createLabel();
        self.asm.cbz(op, lbl_failure);

        self.deferred.push(|| {
            self.emitComment("slow path for div-by-0 check");
            self.asm.bindLabel(lbl_failure);
            self.trap(REG_TEMP, TRAP_DIV0, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();
        let dest = loc.getOutput().getRegister();

        let lbl_overflow = self.asm.createLabel();

        if inst.getValueType() == Type::Int32 {
            self.asm.subs_w(dest, REG_ZERO, src);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.subs(dest, REG_ZERO, src);
        }

        self.asm.bc(Cond::VS, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedNeg overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitIf(inst: Inst) {
        let loc = inst.getLocationData();
        let opnd = loc.getInput(0).getRegister();

        let currentBlock = inst.getBlock();
        let trueBlock = inst.getTrueBlock();
        let falseBlock = inst.getFalseBlock();

        if currentBlock.postOrderIdx == trueBlock.postOrderIdx + 1i32 {
            self.asm.cbz(opnd, falseBlock.getLabel());
        } else {
            assert(currentBlock.postOrderIdx == falseBlock.postOrderIdx + 1i32);
            self.asm.cbnz(opnd, trueBlock.getLabel());
        }
    }

    fn emitGoto(inst: Inst) {
        let currentBlock = inst.getBlock();
        let targetBlock = inst.getTargetBlock();

        assert(currentBlock.successors.size() == 1);

        if currentBlock.successors(0).isBackward() {
            self.emitSafepointCheck();
        }

        if currentBlock.postOrderIdx != targetBlock.postOrderIdx + 1i32 {
            self.asm.b(targetBlock.getLabel());
        }
    }

    fn emitReturn(inst: Inst) {
        if inst.hasInput() {
            let loc = inst.getLocationData();

            if inst.getOperationType().isAnyFloat() {
                let register = loc.getInput(0).getFloatRegister();
                assert(register == F0);
            } else {
                let register = loc.getInput(0).getRegister();
                assert(register == R0);
            }
        }

        self.epilog();
    }

    fn emitMove(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getLocation();
        let src = loc.getInput(0).getLocation();
        let ty = inst.getValueType();

        if dest.isRegister() {
            if src.isRegister() {
                // Register-to-Register
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.mov(dest.getRegister(), src.getRegister());
                } else {
                    assert(ty == Type::UInt8 || ty == Type::Int32 || ty == Type::Bool);
                    self.asm.mov_w(dest.getRegister(), src.getRegister());
                }
            } else {
                // Reload
                assert(src.isStack());
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.ldur(dest.getRegister(), REG_FP, src.getStack());
                } else if ty == Type::Int32 {
                    self.asm.ldur_w(dest.getRegister(), REG_FP, src.getStack());
                } else {
                    assert(ty == Type::Bool);
                    self.asm.ldrb_imm(dest.getRegister(), REG_FP, src.getStack());
                }
            }
        } else if dest.isFloatRegister() {
            if src.isFloatRegister() {
                // Register-to-Register
                if ty == Type::Float32 {
                    self.asm.fmov_s(dest.getFloatRegister(), src.getFloatRegister());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.fmov_d(dest.getFloatRegister(), src.getFloatRegister());
                }
            } else {
                // Reload
                assert(src.isStack());
                if ty == Type::Float32 {
                    self.asm.ldr_imm_s(dest.getFloatRegister(), REG_FP, src.getStack());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.ldr_imm_d(dest.getFloatRegister(), REG_FP, src.getStack());
                }
            }
        } else {
            // Spill
            assert(dest.isStack());

            if src.isFloatRegister() {
                if ty == Type::Float32 {
                    self.asm.str_imm_s(src.getFloatRegister(), REG_FP, dest.getStack());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.str_imm_d(src.getFloatRegister(), REG_FP, dest.getStack());
                }
            } else {
                assert(src.isRegister());
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.stur(src.getRegister(), REG_FP, dest.getStack());
                } else if ty == Type::Int32 {
                    self.asm.stur_w(src.getRegister(), REG_FP, dest.getStack());
                } else {
                    assert(ty == Type::Bool);
                    self.asm.strb_imm(src.getRegister(), REG_FP, dest.getStack());
                }
            }
        }
    }

    fn emitCompare(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();
        let dest = loc.getOutput().getRegister();

        let cond = match inst.op() {
            Op::Greater => Cond::GT,
            Op::GreaterOrEqual => Cond::GE,
            Op::Less => Cond::LT,
            Op::LessOrEqual => Cond::LE,
            Op::Equal => Cond::EQ,
            Op::NotEqual => Cond::NE,
            _ => unreachable[Cond](),
        };

        self.asm.cmp(lhs, rhs);
        self.asm.cset_w(dest, cond);
    }

    fn emitInvokeStatic(inst: Inst) {
        let fct_info = inst.getFunctionInfo();
        let address = getFunctionAddress(fct_info.fct_id, fct_info.type_params);
        let cp_entry = self.constPool.push(ConstPoolValue::Address(address));
        self.loadConstPool(REG_TEMP, cp_entry);
        self.asm.bl_r(REG_TEMP);

        let pos = self.asm.position();
        let site = LazyCompilationSiteDirect(
            fct_info.fct_id,
            fct_info.type_params,
            pos + cp_entry.disp,
        );
        let location = self.ci.bc.getLocationAt(inst.bytecode_position());

        self.lazyCompilation.insert(pos, LazyCompilationSite::Direct(site));
        self.locations.insert(pos, location);
    }

    fn emitLoadField(inst: Inst) {
        let field_info = inst.getFieldInfo();
        let offset = getFieldOffset(field_info.cls_id, field_info.type_params, field_info.field_id);

        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();

        let ty = inst.getValueType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let dest = loc.getOutput().getRegister();
                self.asm.ldrb_imm(dest, src, offset);
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.ldr_imm_w(dest, src, offset);
            },

            Type::Ptr | Type::Int64 => {
                let dest = loc.getOutput().getRegister();
                self.asm.ldr_imm(dest, src, offset);
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.ldr_imm_s(dest, src, offset);
            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.ldr_imm_d(dest, src, offset);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitStoreField(inst: Inst) {
        let field_info = inst.getFieldInfo();
        let offset = getFieldOffset(field_info.cls_id, field_info.type_params, field_info.field_id);

        let loc = inst.getLocationData();
        let obj = loc.getInput(0).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let src = loc.getInput(1).getRegister();
                self.asm.strb_imm(src, obj, offset);
            },

            Type::Int32 => {
                let src = loc.getInput(1).getRegister();
                self.asm.str_imm_w(src, obj, offset);
            },

            Type::Int64 => {
                let src = loc.getInput(1).getRegister();
                self.asm.str_imm(src, obj, offset);
            },

            Type::Ptr => {
                let src = loc.getInput(1).getRegister();
                self.asm.str_imm(src, obj, offset);
                self.emitWriteBarrier(obj, src, REG_TEMP, loc.getRegisterSnapshot());
            },

            Type::Float32 => {
                let src = loc.getInput(1).getFloatRegister();
                self.asm.str_imm_s(src, obj, offset);
            },

            Type::Float64 => {
                let src = loc.getInput(1).getFloatRegister();
                self.asm.str_imm_d(src, obj, offset);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitArrayLength(inst: Inst) {
        let loc = inst.getLocationData();
        let arr = loc.getInput(0).getRegister();

        let dest = loc.getOutput().getRegister();
        self.asm.ldr_imm(dest, arr, OBJECT_HEADER_LENGTH);
    }

    fn emitBoundsCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let idx = loc.getInput(0).getRegister();
        let length = loc.getInput(1).getRegister();

        let label_oob = self.asm.createLabel();

        self.asm.cmp(idx, length);
        self.asm.bc(Cond::HS, label_oob);

        self.deferred.push(|| {
            self.emitComment("slow path for BoundsCheck");
            self.asm.bindLabel(label_oob);
            self.trap(REG_TEMP, TRAP_INDEX_OUT_OF_BOUNDS, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitLoadArray(inst: Inst) {
        let loc = inst.getLocationData();
        let array = loc.getInput(0).getRegister();
        let idx = loc.getInput(1).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let dest = loc.getOutput().getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.ldr_reg_w(dest, REG_TEMP, idx, Extend::LSL, 0i32);
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.ldr_reg_w(dest, REG_TEMP, idx, Extend::LSL, 2i32);
            },

            Type::Int64 | Type::Ptr => {
                let dest = loc.getOutput().getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.ldr_reg(dest, REG_TEMP, idx, Extend::LSL, 3i32);
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.ldr_reg_s(dest, REG_TEMP, idx, Extend::LSL, 2i32);
            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.ldr_reg_d(dest, REG_TEMP, idx, Extend::LSL, 3i32);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitStoreArray(inst: Inst) {
        let loc = inst.getLocationData();
        let array = loc.getInput(0).getRegister();
        let idx = loc.getInput(1).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let value = loc.getInput(2).getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.str_reg_w(value, REG_TEMP, idx, Extend::LSL, 0i32);
            },

            Type::Int32 => {
                let value = loc.getInput(2).getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.str_reg_w(value, REG_TEMP, idx, Extend::LSL, 2i32);
            },

            Type::Int64 => {
                let value = loc.getInput(2).getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.str_reg(value, REG_TEMP, idx, Extend::LSL, 3i32);
            },

            Type::Ptr => {
                let value = loc.getInput(2).getRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.str_reg(value, REG_TEMP, idx, Extend::LSL, 3i32);
                self.emitWriteBarrier(array, value, REG_TEMP, loc.getRegisterSnapshot());
            },

            Type::Float32 => {
                let value = loc.getInput(2).getFloatRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.str_reg_s(value, REG_TEMP, idx, Extend::LSL, 2i32);

            },

            Type::Float64 => {
                let value = loc.getInput(2).getFloatRegister();
                self.asm.add_imm(REG_TEMP, array, ARRAY_HEADER_LENGTH);
                self.asm.str_reg_d(value, REG_TEMP, idx, Extend::LSL, 3i32);

            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitNewObject(inst: Inst) {
        let loc = inst.getLocationData();
        let obj = loc.getOutput().getRegister();
        let class_info = inst.getClassInfo();
        let size = getClassSize(class_info.class_id, class_info.type_params);

        let tmp = loc.getTemp(0).getRegister();
        self.emitObjectAllocate(obj, size, REG_TEMP, tmp, loc.getRegisterSnapshot());

        let classptr = getClassPointer(class_info.class_id, class_info.type_params);
        self.emitObjectInitialization(obj, classptr, REG_TEMP);
    }

    fn finalize(): CodeDescriptor {
        self.emitDeferredCode();
        self.asm.resolveJumps();
        self.asm.brk(0i32);

        if self.asm.size() % CODE_SIZE_ALIGNMENT != 0 {
            self.emitComment("align code");
            self.asm.alignCodeSize(CODE_SIZE_ALIGNMENT);
        }

        let code = self.asm.finalize();

        CodeDescriptor(
            self.constPool,
            code,
            self.lazyCompilation,
            self.gcPoints,
            self.locations,
            self.comments,
        )
    }
}
