use package::assembler::x64::{AssemblerX64, Address, Condition, Immediate, ScaleFactor, registerName};
use package::assembler::x64::{RAX, RDI, RDX, RCX, RSI, RBP, RSP, RBX};
use package::assembler::x64::{R8, R9, R10, R11, R12, R13, R14, R15};
use package::assembler::{Label, Register, RegSet};
use package::bytecode::data::Location;
use package::codegen::{CODE_SIZE_ALIGNMENT, CodeGen, CodeDescriptor, CommentTable, LocationTable};
use package::interface::{Architecture, CompilationInfo, config, TRAP_DIV0, TRAP_OVERFLOW};
use package::graph::{Inst, Op, LocationData, Type};

pub class CodeGenX64 {
    info: CompilationInfo,
    asm: AssemblerX64,
    locations: LocationTable,
    comments: CommentTable,
    deferred: Vec[(): ()],
}

impl CodeGenX64 {
    pub static fn new(info: CompilationInfo): CodeGenX64 {
        CodeGenX64(
            info,
            AssemblerX64::new(),
            LocationTable::new(),
            CommentTable::new(),
            Vec[(): ()]::new(),
        )
    }

    fn epilog() {
        self.emitComment("epilog");
        self.asm.movq_rr(RSP, RBP);
        self.asm.popq_r(RBP);
        self.asm.retq();
    }

    fn trap(tmp: Register, trap: Int32, loc: Location) {
        self.asm.movl_ri(CCALL_REG_PARAMS(0), Immediate(trap.toInt64()));
        self.asm.movq_ri(tmp, Immediate(config.trap_trampoline.toInt64()));
        self.asm.call_r(tmp);
        self.locations.insert(self.asm.position(), loc);
    }

    fn emitDeferredCode() {
        for code in self.deferred {
            code();
        }
    }

    fn emitCheckedDivModCommon(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getRegister();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let is_div = inst.op() == Op::CheckedDiv;

        assert(dest == if is_div { RAX } else { RDX });
        assert(loc.getTemp(0).getRegister() == if is_div { RDX } else { RAX });
        assert(lhs != RAX && rhs != RAX);
        assert(lhs != RDX && rhs != RDX);

        assert(inst.op() == Op::CheckedDiv || inst.op() == Op::CheckedMod);

        let lbl_overflow = self.asm.createLabel();
        let lbl_div = self.asm.createLabel();

        self.asm.movq_ri(REG_TMP1, Immediate(Int64::minValue()));
        self.asm.cmpq_rr(REG_TMP1, lhs);
        self.asm.jcc_near(Condition::NotEqual, lbl_div);
        self.asm.cmpq_ri(rhs, Immediate(-1));
        self.asm.jcc(Condition::Equal, lbl_overflow);
        self.asm.bindLabel(lbl_div);

        self.asm.movq_rr(RAX, lhs);
        self.asm.cqo();
        self.asm.idivq_r(rhs);

        self.deferred.push(|| {
            let op = if is_div { "CheckedDiv" } else { "CheckedMod" };
            self.emitComment("slow path for ${op} overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TMP1, TRAP_OVERFLOW, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }
}

pub let REG_PARAMS: Array[Register] = Array[Register]::new(RDI, RSI, RDX, RCX, R8, R9);
pub let CCALL_REG_PARAMS: Array[Register] = REG_PARAMS;

// Temporary registers that can be used within an instruction.
pub let REG_TMP1: Register = R10;
pub let REG_TMP2: Register = R11;

impl CodeGen for CodeGenX64 {
    fn allocatableRegisters(): RegSet {
        RegSet::new(RAX, RDI, RSI, RDX, RCX, R8, R9, RBX, R12, R13, R14)
    }

    fn argumentRegister(idx: Int64): Register {
        REG_PARAMS(idx)
    }

    fn getScratchRegister(): Register {
        REG_TMP1
    }

    fn prolog() {
        self.asm.pushq_r(RBP);
        self.asm.movq_rr(RBP, RSP);
    }

    fn emitComment(comment: String) {
        self.comments.insert(self.asm.position(), comment);
    }

    fn registerName(register: Register): String {
        registerName(register)
    }

    fn createLabel(): Label {
        self.asm.createLabel()
    }

    fn bindLabel(label: Label) {
        self.asm.bindLabel(label);
    }

    fn spill(inst: Inst) {
        let loc = inst.getLocationData();
        let reg = loc.getOutput().getRegister();
        let slot = loc.getSpillSlot();
        self.asm.movq_ar(Address::offset(RBP, slot), reg);
    }

    fn emitInt64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movq_ri(register, Immediate(inst.auxAsInt64()));
    }

    fn emitInt32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(inst.auxAsInt32().toInt64()));
    }

    fn emitTrueConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(1));
    }

    fn emitFalseConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(0));
    }

    fn emitCheckedAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        self.asm.movq_rr(output, lhs);
        self.asm.addq_rr(output, rhs);

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedAdd overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TMP1, TRAP_OVERFLOW, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        self.asm.movq_rr(output, lhs);
        self.asm.subq_rr(output, rhs);

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedSub overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TMP1, TRAP_OVERFLOW, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let output = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        self.asm.movq_rr(output, lhs);
        self.asm.imulq_rr(output, rhs);

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedMul overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TMP1, TRAP_OVERFLOW, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn setLocationConstraintsCheckedDiv(inst: Inst, loc: LocationData) {
        loc.requireInputRegister(0);
        loc.requireInputRegister(1);
        loc.requireOutputFixedRegister(RAX);
        loc.requireTempFixedRegister(RDX);
    }

    fn setLocationConstraintsCheckedMod(inst: Inst, loc: LocationData) {
        loc.requireInputRegister(0);
        loc.requireInputRegister(1);
        loc.requireOutputFixedRegister(RDX);
        loc.requireTempFixedRegister(RAX);
    }

    fn setLocationConstraintsReturn(inst: Inst, loc: LocationData) {
        if inst.hasInput() {
            loc.requireInputFixedRegister(0, RAX);
        }
    }

    fn emitCheckedDiv(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitCheckedMod(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitDivZeroCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let op = loc.getInput(0).getRegister();

        let lbl_failure = self.asm.createLabel();
        self.asm.testq_rr(op, op);
        self.asm.jcc(Condition::Zero, lbl_failure);

        self.deferred.push(|| {
            self.emitComment("slow path for div-by-0 check");
            self.asm.bindLabel(lbl_failure);
            self.trap(REG_TMP1, TRAP_DIV0, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();
        let dest = loc.getOutput().getRegister();

        let lbl_overflow = self.asm.createLabel();
        self.asm.movq_rr(dest, src);
        self.asm.negq_r(dest);
        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedNeg overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TMP1, TRAP_OVERFLOW, self.info.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitIf(inst: Inst) {
        let loc = inst.getLocationData();
        let opnd = loc.getInput(0).getRegister();

        let currentBlock = inst.getBlock();
        let trueBlock = inst.getTrueBlock();
        let falseBlock = inst.getFalseBlock();

        if currentBlock.postOrderIdx == trueBlock.postOrderIdx + 1i32 {
            self.asm.testl_rr(opnd, opnd);
            self.asm.jcc(Condition::Zero, falseBlock.getLabel());
        } else {
            assert(currentBlock.postOrderIdx == falseBlock.postOrderIdx + 1i32);
            self.asm.testl_rr(opnd, opnd);
            self.asm.jcc(Condition::NotZero, trueBlock.getLabel());
        }
    }

    fn emitGoto(inst: Inst) {
        let currentBlock = inst.getBlock();
        let targetBlock = inst.getTargetBlock();

        if currentBlock.postOrderIdx != targetBlock.postOrderIdx + 1i32 {
            self.asm.jmp(targetBlock.getLabel());
        }
    }

    fn emitReturn(inst: Inst) {
        if inst.hasInput() {
            let loc = inst.getLocationData();
            let register = loc.getInput(0).getRegister();
            let ty = inst.getType();

            if RAX != register {
                if ty == Type::Int64 {
                    self.asm.movq_rr(RAX, register);
                } else if ty == Type::Int32 {
                    self.asm.movl_rr(RAX, register);
                } else if ty == Type::Bool {
                    self.asm.movl_rr(RAX, register);
                } else {
                    unreachable[()]();
                }
            }
        }

        self.epilog();
    }

    fn emitMove(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getOperand();
        let src = loc.getInput(0).getOperand();

        if dest.isRegister() {
            if src.isRegister() {
                self.asm.movq_rr(dest.getRegister(), src.getRegister());
            } else {
                assert(src.isStack());
                self.asm.movq_ra(dest.getRegister(), Address::offset(RBP, src.getStack()));
            }
        } else {
            assert(dest.isStack());
            assert(src.isRegister());
            self.asm.movq_ar(Address::offset(RBP, dest.getStack()), src.getRegister());
        }
    }

    fn emitCompare(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();
        let dest = loc.getOutput().getRegister();

        let cond = match inst.op() {
            Op::Greater => Condition::Greater,
            Op::GreaterOrEqual => Condition::GreaterOrEqual,
            Op::Less => Condition::Less,
            Op::LessOrEqual => Condition::LessOrEqual,
            Op::Equal => Condition::Equal,
            Op::NotEqual => Condition::NotEqual,
            _ => unreachable[Condition](),
        };

        self.asm.cmpq_rr(lhs, rhs);
        self.asm.setcc_r(cond, dest);
        self.asm.movzxb_rr(dest, dest);
    }

    fn finalize(): CodeDescriptor {
        self.emitDeferredCode();
        self.asm.resolveJumps();
        self.asm.nop();

        if self.asm.size() % CODE_SIZE_ALIGNMENT != 0 {
            self.emitComment("align code");
            self.asm.alignCodeSize(CODE_SIZE_ALIGNMENT);
        }

        let code = self.asm.finalize();

        CodeDescriptor(
            code,
            self.comments,
            self.locations,
        )
    }
}