use package::assembler::x64::{AssemblerX64, Address as AsmAddress, Condition, Immediate, ScaleFactor, registerName};
use package::assembler::x64::{RAX, RDI, RDX, RCX, RSI, RBP, RSP, RBX};
use package::assembler::x64::{R8, R9, R10, R11, R12, R13, R14, R15};
use package::assembler::x64::{XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, XMM15};
use package::assembler::{FloatRegister, Label, Register, RegSet};
use package::bytecode::data::{ConstPoolId, Location};
use package::codegen::{CODE_SIZE_ALIGNMENT, CodeGen};
use package::interface::{Address, Architecture, CompilationInfo, ConstPool, ConstPoolEntry, ConstPoolValue, config, getFunctionAddress, LazyCompilationSite, LazyCompilationSiteDirect, getFieldOffset};
use package::interface::{TRAP_DIV0, TRAP_OVERFLOW, TRAP_INDEX_OUT_OF_BOUNDS};
use package::interface::{THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET, THREAD_LOCAL_DATA_STATE_OFFSET, THREAD_LOCAL_DATA_MARKING_OFFSET, OBJECT_HEADER_LENGTH, OBJECT_METADATA_OFFSET, METADATA_REMEMBERED_BIT, ARRAY_HEADER_LENGTH};
use package::location::{useInputFloatRegisterFixed, useInputRegister, useInputRegisterFixed, useOutputRegisterFixed, useOutputSameAsFirstInput, useTempRegisterFixed};
use package::graph::{Inst, Op, LocationData, RegisterSnapshot, Type};
use package::{CodeDescriptor, CommentTable, GcPointTable, LazyCompilationData, LocationTable};

let REG_PARAMS: Array[Register] = Array[Register]::new(RDI, RSI, RDX, RCX, R8, R9);
let FLOAT_REG_PARAMS: Array[FloatRegister] = Array[FloatRegister]::new(XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7);

let CCALL_REG_PARAMS: Array[Register] = REG_PARAMS;

// Temporary registers that can be used within an instruction.
let REG_TEMP: Register = R10;
let FREG_TEMP: FloatRegister = XMM15;
let REG_THREAD: Register = R15;

let ALLOCATABLE_REGS: RegSet[Register] = RegSet[Register]::new(
    RAX, RCX, RDX, RBX,
              RSI, RDI,
    // RSP is stack pointer
    // RBP is frame pointer
    R8 , R9 ,      R11,
    // R10 is REG_TEMP
    R12, R13, R14,
    // R15 is REG_THREAD
);

// The last register XMM15 is used as FREG_TEMP.
let ALLOCATABLE_FREGS: RegSet[FloatRegister] = RegSet[FloatRegister]::firstN(15i32);

fn msb(reg: FloatRegister): Bool {
    ((reg.value.toInt64() >> 3i32) & 1) != 0
}

pub class CodeGenX64 {
    ci: CompilationInfo,
    asm: AssemblerX64,
    constPool: ConstPool,
    locations: LocationTable,
    lazyCompilation: LazyCompilationData,
    gcPoints: GcPointTable,
    comments: CommentTable,
    deferred: Vec[(): ()],
}

impl CodeGenX64 {
    pub static fn new(ci: CompilationInfo): CodeGenX64 {
        CodeGenX64(
            ci,
            AssemblerX64::new(),
            ConstPool::new(),
            LocationTable::new(),
            LazyCompilationData::new(),
            GcPointTable::new(),
            CommentTable::new(),
            Vec[(): ()]::new(),
        )
    }

    fn epilog() {
        self.emitComment("epilog");
        self.asm.movq_rr(RSP, RBP);
        self.asm.popq_r(RBP);
        self.asm.retq();
    }

    fn trap(tmp: Register, trap: Int32, loc: Location) {
        self.asm.movl_ri(CCALL_REG_PARAMS(0), Immediate(trap.toInt64()));
        self.asm.movq_ri(tmp, Immediate(config.trap_trampoline.toInt64()));
        self.asm.call_r(tmp);
        self.locations.insert(self.asm.position(), loc);
    }

    fn loadConstPool(dest: Register, entry: ConstPoolEntry) {
        let offset = -(self.asm.position() + 7i32 + entry.disp);
        self.asm.movq_ra(dest, AsmAddress::rip(offset));
    }

    fn emitDeferredCode() {
        for code in self.deferred {
            code();
        }
    }

    fn mov_imm_f32(dest: FloatRegister, value: Float32) {
        let entry = self.constPool.push(ConstPoolValue::Float32(value));
        let inst_size = 8i32 + if msb(dest) { 1i32 } else { 0i32 };
        let disp = self.asm.position() + entry.disp + inst_size;
        self.asm.movss_ra(dest, AsmAddress::rip(-disp));
    }

    fn mov_imm_f64(dest: FloatRegister, value: Float64) {
        let entry = self.constPool.push(ConstPoolValue::Float64(value));
        let inst_size = 8i32 + if msb(dest) { 1i32 } else { 0i32 };
        let disp = self.asm.position() + entry.disp + inst_size;
        self.asm.movsd_ra(dest, AsmAddress::rip(-disp));
    }

    fn emitCheckedDivModCommon(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getRegister();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let is_div = inst.op() == Op::CheckedDiv;

        assert(dest == if is_div { RAX } else { RDX });
        assert(loc.getTemp(0).getRegister() == if is_div { RDX } else { RAX });
        assert(lhs != RAX && rhs != RAX);
        assert(lhs != RDX && rhs != RDX);

        assert(inst.op() == Op::CheckedDiv || inst.op() == Op::CheckedMod);

        let lbl_overflow = self.asm.createLabel();
        let lbl_div = self.asm.createLabel();

        self.asm.movq_ri(REG_TEMP, Immediate(Int64::minValue()));
        self.asm.cmpq_rr(REG_TEMP, lhs);
        self.asm.jcc_near(Condition::NotEqual, lbl_div);
        self.asm.cmpq_ri(rhs, Immediate(-1));
        self.asm.jcc(Condition::Equal, lbl_overflow);
        self.asm.bindLabel(lbl_div);

        self.asm.movq_rr(RAX, lhs);
        self.asm.cqo();
        self.asm.idivq_r(rhs);

        self.deferred.push(|| {
            let op = if is_div { "CheckedDiv" } else { "CheckedMod" };
            self.emitComment("slow path for ${op} overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitWriteBarrier(host: Register, value: Register, snapshot: RegisterSnapshot) {
        let lbl_object_slow_path = self.asm.createLabel();
        let lbl_marking_slow_path = self.asm.createLabel();

        self.asm.cmpb_ai(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_MARKING_OFFSET), Immediate(0));
        self.asm.jcc(Condition::NotZero, lbl_marking_slow_path);

        self.asm.testb_ai(AsmAddress::offset(host, OBJECT_METADATA_OFFSET), Immediate(1 << METADATA_REMEMBERED_BIT));
        self.asm.jcc(Condition::Zero, lbl_object_slow_path);
        let lbl_return = self.asm.createAndBindLabel();

        self.deferred.push(|| {
            self.emitComment("marking barrier slow path");
            self.asm.bindLabel(lbl_marking_slow_path);
            self.asm.int3();
            self.asm.jmp(lbl_return);
        });

        self.deferred.push(|| {
            self.emitComment("object barrier slow path");
            self.asm.bindLabel(lbl_object_slow_path);
            self.asm.testq_rr(value, value);
            self.asm.jcc(Condition::Zero, lbl_return);
            self.saveRegistersForCall(snapshot);
            self.asm.movq_rr(CCALL_REG_PARAMS(0), host);
            self.asm.movq_rr(CCALL_REG_PARAMS(1), value);
            self.asm.movq_ri(REG_TEMP, Immediate(config.object_write_barrier_slow_path.toInt64()));
            self.asm.call_r(REG_TEMP);
            self.restoreRegistersForCall(snapshot);
            self.asm.jmp(lbl_return);
        });
    }

    fn saveRegistersForCall(snapshot: RegisterSnapshot) {
        let regs = snapshot.gp.clone();

        while !regs.isEmpty() {
            let reg = regs.popLowestIndex().getOrPanic();
            self.asm.pushq_r(reg);
        }

        let regs = snapshot.fp.clone();

        if !regs.isEmpty() {
            let size = regs.size() * 8;
            self.asm.subq_ri(RSP, Immediate(size));
            let mut offset = 0i32;

            while !regs.isEmpty() {
                let reg = regs.popLowestIndex().getOrPanic();
                self.asm.movsd_ar(AsmAddress::offset(RSP, offset), reg);
                offset = offset + 8i32;
            }
        }
    }

    fn restoreRegistersForCall(snapshot: RegisterSnapshot) {
        let regs = snapshot.gp.clone();

        while !regs.isEmpty() {
            let reg = regs.popHighestIndex().getOrPanic();
            self.asm.popq_r(reg);
        }

        let regs = snapshot.fp.clone();

        if !regs.isEmpty() {
            let mut offset = 0i32;

            while !regs.isEmpty() {
                let reg = regs.popLowestIndex().getOrPanic();
                self.asm.movsd_ra(reg, AsmAddress::offset(RSP, offset));
                offset = offset + 8i32;
            }

            let size = regs.size() * 8;
            self.asm.addq_ri(RSP, Immediate(size));
        }
    }
}

impl CodeGen for CodeGenX64 {
    fn allocatableRegisters(): RegSet[Register] {
        ALLOCATABLE_REGS
    }

    fn allocatableFloatRegisters(): RegSet[FloatRegister] {
        ALLOCATABLE_FREGS
    }

    fn argumentRegister(idx: Int64): Register {
        REG_PARAMS(idx)
    }

    fn argumentRegisters(): Array[Register] {
        REG_PARAMS
    }

    fn argumentFloatRegisters(): Array[FloatRegister] {
        FLOAT_REG_PARAMS
    }

    fn getScratchRegister(): Register {
        REG_TEMP
    }

    fn getFloatScratchRegister(): FloatRegister {
        FREG_TEMP
    }

    fn getReturnRegister(): Register {
        RAX
    }

    fn getFloatReturnRegister(): FloatRegister {
        XMM0
    }

    fn emitDebug() {
        self.asm.int3();
    }

    fn emitProlog(stackSize: Int32) {
        self.asm.pushq_r(RBP);
        self.asm.movq_rr(RBP, RSP);

        if stackSize > 0i32 {
            self.asm.subq_ri(RSP, Immediate(stackSize.toInt64()));
        }
    }

    fn emitStackLimitCheck() {
        let lbl_stack_overflow = self.asm.createLabel();
        self.asm.cmpq_ar(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET), RSP);
        self.asm.jcc(Condition::Above, lbl_stack_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for stack limit check");
            self.asm.bindLabel(lbl_stack_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.loc);
        });
    }

    fn emitSafepointCheck() {
        let lbl_safepoint = self.asm.createLabel();
        self.asm.cmpb_ai(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_STATE_OFFSET), Immediate(0));
        self.asm.jcc(Condition::NotEqual, lbl_safepoint);

        self.deferred.push(|| {
            self.emitComment("slow path safepoint");
            self.asm.bindLabel(lbl_safepoint);

            self.asm.movq_ri(REG_TEMP, Immediate(config.safepoint_trampoline.toInt64()));
            self.asm.call_r(REG_TEMP);
            self.locations.insert(self.asm.position(), self.ci.loc);
        });
    }

    fn emitComment(comment: String) {
        self.comments.insert(self.asm.position(), comment);
    }

    fn registerName(register: Register): String {
        registerName(register)
    }

    fn createLabel(): Label {
        self.asm.createLabel()
    }

    fn bindLabel(label: Label) {
        self.asm.bindLabel(label);
    }

    fn spill(inst: Inst) {
        let loc = inst.getLocationData();
        let slot = loc.getSpillSlot();
        let ty = inst.getValueType();

        if ty.isAnyFloat() {
            let reg = loc.getOutput().getFloatRegister();

            if ty == Type::Float32 {
                self.asm.movss_ar(AsmAddress::offset(RBP, slot), reg);
            } else {
                assert(ty == Type::Float64);
                self.asm.movsd_ar(AsmAddress::offset(RBP, slot), reg);
            }
        } else {
            let reg = loc.getOutput().getRegister();

            if ty == Type::Int32 {
                self.asm.movl_ar(AsmAddress::offset(RBP, slot), reg);
            } else {
                assert(ty == Type::Int64);
                self.asm.movq_ar(AsmAddress::offset(RBP, slot), reg);
            }
        }
    }

    fn emitInt32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(inst.getValueAsInt32().toInt64()));
    }

    fn emitInt64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movq_ri(register, Immediate(inst.getValueAsInt64()));
    }

    fn emitFloat32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getFloatRegister();
        self.mov_imm_f32(register, inst.getValueAsFloat32());
    }

    fn emitFloat64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getFloatRegister();
        self.mov_imm_f64(register, inst.getValueAsFloat64());
    }

    fn emitTrueConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(1));
    }

    fn emitFalseConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(0));
    }

    fn emitAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.addss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.addsd_rr(output, rhs);
        }
    }

    fn emitSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.subss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.subsd_rr(output, rhs);
        }
    }

    fn emitMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.mulss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.mulsd_rr(output, rhs);
        }
    }

    fn emitDiv(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.divss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.divsd_rr(output, rhs);
        }
    }

    fn emitNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getFloatRegister();
        let dest = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        let value = if ty == Type::Float32 {
            1 << 31i32
        } else {
            assert(ty == Type::Float64);
            1 << 63i32
        };

        if ty == Type::Float32 {
            self.asm.movss_rr(dest, src);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(dest, src);
        }

        let disp = self.constPool.push(ConstPoolValue::Int128(value, 0)).disp;
        let pos = self.asm.position();

        let inst_size = 7i32
            + if ty == Type::Float64 { 1i32 } else { 0i32 }
            + if dest.needsRexBit() { 1i32 } else { 0i32 };

        let address = AsmAddress::rip(-(disp + pos + inst_size));

        if ty == Type::Float32 {
            self.asm.xorps_ra(dest, address)
        } else {
            assert(ty == Type::Float64);
            self.asm.xorpd_ra(dest, address)
        }
    }

    fn emitCheckedAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        assert(dest == lhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.addl_rr(dest, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.addq_rr(dest, rhs);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedAdd overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        assert(dest == lhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.subl_rr(dest, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.subq_rr(dest, rhs);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedSub overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        assert(dest == lhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.imull_rr(dest, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.imulq_rr(dest, rhs);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedMul overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn setLocationConstraintsCheckedAdd(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputSameAsFirstInput(inst);
    }

    fn setLocationConstraintsCheckedSub(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputSameAsFirstInput(inst);
    }

    fn setLocationConstraintsCheckedMul(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputSameAsFirstInput(inst);
    }

    fn setLocationConstraintsCheckedDiv(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegisterFixed(inst, RAX);
        useTempRegisterFixed(inst, RDX);
    }

    fn setLocationConstraintsCheckedMod(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegisterFixed(inst, RDX);
        useTempRegisterFixed(inst, RAX);
    }

    fn setLocationConstraintsReturn(inst: Inst, loc: LocationData) {
        if inst.hasInput() {
            if inst.getOperationType().isAnyFloat() {
                useInputFloatRegisterFixed(inst, 0, XMM0);
            } else {
                useInputRegisterFixed(inst, 0, RAX);
            }
        }
    }

    fn emitCheckedDiv(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitCheckedMod(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitDivZeroCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let op = loc.getInput(0).getRegister();

        let lbl_failure = self.asm.createLabel();
        self.asm.testq_rr(op, op);
        self.asm.jcc(Condition::Zero, lbl_failure);

        self.deferred.push(|| {
            self.emitComment("slow path for div-by-0 check");
            self.asm.bindLabel(lbl_failure);
            self.trap(REG_TEMP, TRAP_DIV0, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();
        let dest = loc.getOutput().getRegister();

        let lbl_overflow = self.asm.createLabel();

        if inst.getValueType() == Type::Int32 {
            self.asm.movl_rr(dest, src);
            self.asm.negl_r(dest);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.movq_rr(dest, src);
            self.asm.negq_r(dest);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedNeg overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitIf(inst: Inst) {
        let loc = inst.getLocationData();
        let opnd = loc.getInput(0).getRegister();

        let currentBlock = inst.getBlock();
        let trueBlock = inst.getTrueBlock();
        let falseBlock = inst.getFalseBlock();

        if currentBlock.postOrderIdx == trueBlock.postOrderIdx + 1i32 {
            self.asm.testl_rr(opnd, opnd);
            self.asm.jcc(Condition::Zero, falseBlock.getLabel());
        } else {
            assert(currentBlock.postOrderIdx == falseBlock.postOrderIdx + 1i32);
            self.asm.testl_rr(opnd, opnd);
            self.asm.jcc(Condition::NotZero, trueBlock.getLabel());
        }
    }

    fn emitGoto(inst: Inst) {
        let currentBlock = inst.getBlock();
        let targetBlock = inst.getTargetBlock();

        if currentBlock.successors(0).isBackward() {
            self.emitSafepointCheck();
        }

        if currentBlock.postOrderIdx != targetBlock.postOrderIdx + 1i32 {
            self.asm.jmp(targetBlock.getLabel());
        }
    }

    fn emitReturn(inst: Inst) {
        if inst.hasInput() {
            let loc = inst.getLocationData();

            if inst.getOperationType().isAnyFloat() {
                let register = loc.getInput(0).getFloatRegister();
                assert(register == XMM0);
            } else {
                let register = loc.getInput(0).getRegister();
                assert(register == RAX);
            }
        }

        self.epilog();
    }

    fn emitMove(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getLocation();
        let src = loc.getInput(0).getLocation();
        let ty = inst.getValueType();

        if dest.isRegister() {
            if src.isRegister() {
                // Register-to-Register
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.movq_rr(dest.getRegister(), src.getRegister());
                } else {
                    assert(ty == Type::Int32 || ty == Type::Bool);
                    self.asm.movl_rr(dest.getRegister(), src.getRegister());
                }
            } else {
                // Reload
                assert(src.isStack());
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.movq_ra(dest.getRegister(), AsmAddress::offset(RBP, src.getStack()));
                } else if ty == Type::Int32 {
                    self.asm.movl_ra(dest.getRegister(), AsmAddress::offset(RBP, src.getStack()));
                } else {
                    assert(ty == Type::Bool);
                    self.asm.movb_ra(dest.getRegister(), AsmAddress::offset(RBP, src.getStack()));
                }
            }
        } else if dest.isFloatRegister() {
            if src.isFloatRegister() {
                // Register-to-Register
                if ty == Type::Float32 {
                    self.asm.movss_rr(dest.getFloatRegister(), src.getFloatRegister());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.movsd_rr(dest.getFloatRegister(), src.getFloatRegister());
                }
            } else {
                // Reload
                assert(src.isStack());
                if ty == Type::Float32 {
                    self.asm.movss_ra(dest.getFloatRegister(), AsmAddress::offset(RBP, src.getStack()));
                } else {
                    assert(ty == Type::Float64);
                    self.asm.movss_ra(dest.getFloatRegister(), AsmAddress::offset(RBP, src.getStack()));
                }
            }
        } else {
            // Spill
            assert(dest.isStack());

            if src.isFloatRegister() {
                if ty == Type::Float32 {
                    self.asm.movss_ar(AsmAddress::offset(RBP, src.getStack()), src.getFloatRegister());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.movsd_ar(AsmAddress::offset(RBP, src.getStack()), src.getFloatRegister());
                }
            } else {
                assert(src.isRegister());
                self.asm.movq_ar(AsmAddress::offset(RBP, dest.getStack()), src.getRegister());

                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.movq_ar(AsmAddress::offset(RBP, dest.getStack()), src.getRegister());
                } else if ty == Type::Int32 {
                    self.asm.movl_ar(AsmAddress::offset(RBP, dest.getStack()), src.getRegister());
                } else {
                    assert(ty == Type::Bool);
                    self.asm.movb_ar(AsmAddress::offset(RBP, dest.getStack()), src.getRegister());
                }
            }
        }
    }

    fn emitCompare(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();
        let dest = loc.getOutput().getRegister();

        let cond = match inst.op() {
            Op::Greater => Condition::Greater,
            Op::GreaterOrEqual => Condition::GreaterOrEqual,
            Op::Less => Condition::Less,
            Op::LessOrEqual => Condition::LessOrEqual,
            Op::Equal => Condition::Equal,
            Op::NotEqual => Condition::NotEqual,
            _ => unreachable[Condition](),
        };

        self.asm.cmpq_rr(lhs, rhs);
        self.asm.setcc_r(cond, dest);
        self.asm.movzxb_rr(dest, dest);
    }

    fn emitInvokeStatic(inst: Inst) {
        let fct_info = inst.getFunctionInfo();
        let address = getFunctionAddress(fct_info.fct_id, fct_info.type_params);
        let cp_entry = self.constPool.push(ConstPoolValue::Address(address));
        self.loadConstPool(REG_TEMP, cp_entry);
        self.asm.call_r(REG_TEMP);

        let pos = self.asm.position();
        let site = LazyCompilationSiteDirect(
            fct_info.fct_id,
            fct_info.type_params,
            pos + cp_entry.disp,
        );
        let location = self.ci.bc.getLocationAt(inst.bytecode_position());

        self.lazyCompilation.insert(pos, LazyCompilationSite::Direct(site));
        self.locations.insert(pos, location);
    }

    fn emitLoadField(inst: Inst) {
        let field_info = inst.getFieldInfo();
        let offset = getFieldOffset(field_info.cls_id, field_info.type_params, field_info.field_id);

        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();

        let ty = inst.getValueType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movb_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movl_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Ptr | Type::Int64 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movss_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movsd_ra(dest, AsmAddress::offset(src, offset));
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitStoreField(inst: Inst) {
        let field_info = inst.getFieldInfo();
        let offset = getFieldOffset(field_info.cls_id, field_info.type_params, field_info.field_id);

        let loc = inst.getLocationData();
        let obj = loc.getInput(0).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let src = loc.getInput(1).getRegister();
                self.asm.movb_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Int32 => {
                let src = loc.getInput(1).getRegister();
                self.asm.movl_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Int64 => {
                let src = loc.getInput(1).getRegister();
                self.asm.movq_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Ptr => {
                let src = loc.getInput(1).getRegister();
                self.asm.movq_ar(AsmAddress::offset(obj, offset), src);
                self.emitWriteBarrier(obj, src, loc.getRegisterSnapshot());
            },

            Type::Float32 => {
                let src = loc.getInput(1).getFloatRegister();
                self.asm.movss_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Float64 => {
                let src = loc.getInput(1).getFloatRegister();
                self.asm.movsd_ar(AsmAddress::offset(obj, offset), src);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitArrayLength(inst: Inst) {
        let loc = inst.getLocationData();
        let arr = loc.getInput(0).getRegister();

        let dest = loc.getOutput().getRegister();
        self.asm.movq_ra(dest, AsmAddress::offset(arr, OBJECT_HEADER_LENGTH));
    }

    fn emitBoundsCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let idx = loc.getInput(0).getRegister();
        let length = loc.getInput(1).getRegister();

        let label_oob = self.asm.createLabel();

        self.asm.cmpq_rr(idx, length);
        self.asm.jcc(Condition::AboveOrEqual, label_oob);

        self.deferred.push(|| {
            self.emitComment("slow path for BoundsCheck");
            self.asm.bindLabel(label_oob);
            self.trap(REG_TEMP, TRAP_INDEX_OUT_OF_BOUNDS, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitLoadArray(inst: Inst) {
        let loc = inst.getLocationData();
        let array = loc.getInput(0).getRegister();
        let idx = loc.getInput(1).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::array(array, idx, ScaleFactor::One, ARRAY_HEADER_LENGTH));
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Four, ARRAY_HEADER_LENGTH));
            },

            Type::Int64 | Type::Ptr => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH));
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movss_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Four, ARRAY_HEADER_LENGTH));
            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movsd_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH));
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitStoreArray(inst: Inst) {
        unimplemented();
    }

    fn finalize(): CodeDescriptor {
        self.emitDeferredCode();
        self.asm.resolveJumps();
        self.asm.nop();

        if self.asm.size() % CODE_SIZE_ALIGNMENT != 0 {
            self.emitComment("align code");
            self.asm.alignCodeSize(CODE_SIZE_ALIGNMENT);
        }

        let code = self.asm.finalize();

        CodeDescriptor(
            self.constPool,
            code,
            self.lazyCompilation,
            self.gcPoints,
            self.locations,
            self.comments,
        )
    }
}