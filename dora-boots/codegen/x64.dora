use package::bytecode::{BytecodeType, FctId};
use package::assembler::x64::{AssemblerX64, Address as AsmAddress, Condition, Immediate, ScaleFactor, registerName};
use package::assembler::x64::{RAX, RDI, RDX, RCX, RSI, RBP, RSP, RBX};
use package::assembler::x64::{R8, R9, R10, R11, R12, R13, R14, R15};
use package::assembler::x64::{XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, XMM8, XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15};
use package::assembler::{FloatRegister, Label, Register, RegSet};
use package::bytecode::data::{ConstPoolId, Location};
use package::codegen::{CODE_SIZE_ALIGNMENT, CodeGen};
use package::interface::{Address, Architecture, CompilationInfo, ConstPool, ConstPoolEntry, ConstPoolValue, config, getFunctionAddress, LazyCompilationSite, LazyCompilationSiteDirect, getFieldOffset, getClassSize, getClassPointer, getClassPointerForLambda, getFunctionVtableIndex, getGlobalValueAddress, getGlobalStateAddress, getGlobalInitializerFunctionId};
use package::interface::{TRAP_DIV0, TRAP_OVERFLOW, TRAP_INDEX_OUT_OF_BOUNDS, LAMBDA_SIZE, PTR_SIZE, GLOBAL_STATE_INITIALIZED};
use package::interface::{THREAD_LOCAL_DATA_TLAB_TOP_OFFSET, THREAD_LOCAL_DATA_TLAB_END_OFFSET, THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET, THREAD_LOCAL_DATA_STATE_OFFSET, THREAD_LOCAL_DATA_MARKING_OFFSET, OBJECT_HEADER_LENGTH, OBJECT_METADATA_OFFSET, METADATA_REMEMBERED_BIT, ARRAY_HEADER_LENGTH};
use package::location::{useInputFloatRegisterFixed, useInputRegister, useInputRegisterFixed, useOutputRegisterFixed, useOutputSameAsFirstInput, addTempRegisterFixed};
use package::graph::{Inst, Op, LocationData, RegisterSnapshot, Type};
use package::{CodeDescriptor, CommentTable, GcPoint, GcPointTable, LazyCompilationData, LazyCompilationSiteVirtual, LazyCompilationSiteLambda, LocationTable};

let REG_PARAMS: Array[Register] = Array[Register]::new(RDI, RSI, RDX, RCX, R8, R9);
let FLOAT_REG_PARAMS: Array[FloatRegister] = Array[FloatRegister]::new(XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7);

let CCALL_REG_PARAMS: Array[Register] = REG_PARAMS;

// Temporary registers that can be used within an instruction.
let REG_TEMP: Register = R10;
let FREG_TEMP: FloatRegister = XMM15;
let REG_THREAD: Register = R15;

let ALLOCATABLE_REGS: RegSet[Register] = RegSet[Register]::new(
    RAX, RCX, RDX, RBX,
              RSI, RDI,
    // RSP is stack pointer
    // RBP is frame pointer
    R8 , R9 ,      R11,
    // R10 is REG_TEMP
    R12, R13, R14,
    // R15 is REG_THREAD
);

// The last register XMM15 is used as FREG_TEMP.
// Only use 10 registers for now for testing (otherwise 15).
let ALLOCATABLE_FREGS: RegSet[FloatRegister] = RegSet[FloatRegister]::firstN(10i32);

let CALLEE_SAVED_REGS: RegSet[Register] = if config.isWindows {
    RegSet[Register]::new(RBX, RDI, RSI, R12, R13, R14, R15)
} else {
    assert(config.isUnix);
    RegSet[Register]::new(RBX, R12, R13, R14, R15)
};

let CALLEE_SAVED_FREGS: RegSet[FloatRegister] = if config.isWindows {
    RegSet[FloatRegister]::new(
        XMM6, XMM7, XMM8, XMM9,
        XMM10, XMM11, XMM12, XMM13,
        XMM14, XMM15
    )
} else {
    assert(config.isUnix);
    RegSet[FloatRegister]::new()
};

fn msb(reg: FloatRegister): Bool {
    ((reg.value.toInt64() >> 3i32) & 1) != 0
}

pub class CodeGenX64 {
    ci: CompilationInfo,
    asm: AssemblerX64,
    constPool: ConstPool,
    locations: LocationTable,
    lazyCompilation: LazyCompilationData,
    gcPoints: GcPointTable,
    comments: CommentTable,
    deferred: Vec[(): ()],
}

impl CodeGenX64 {
    pub static fn new(ci: CompilationInfo): CodeGenX64 {
        CodeGenX64(
            ci,
            AssemblerX64::new(),
            ConstPool::new(),
            LocationTable::new(),
            LazyCompilationData::new(),
            GcPointTable::new(),
            CommentTable::new(),
            Vec[(): ()]::new(),
        )
    }

    fn epilog() {
        self.emitComment("epilog");
        self.asm.movq_rr(RSP, RBP);
        self.asm.popq_r(RBP);
        self.asm.retq();
    }

    fn trap(tmp: Register, trap: Int32, loc: Location) {
        self.asm.movl_ri(CCALL_REG_PARAMS(0), Immediate(trap.toInt64()));
        self.asm.movq_ri(tmp, Immediate(config.trap_trampoline.toInt64()));
        self.asm.call_r(tmp);
        self.locations.insert(self.asm.position(), loc);
    }

    fn loadConstPool(dest: Register, entry: ConstPoolEntry) {
        let offset = -(self.asm.position() + 7i32 + entry.disp);
        self.asm.movq_ra(dest, AsmAddress::rip(offset));
    }

    fn emitDeferredCode() {
        for code in self.deferred {
            code();
        }
    }

    fn mov_imm_f32(dest: FloatRegister, value: Float32) {
        let entry = self.constPool.push(ConstPoolValue::Float32(value));
        let inst_size = 8i32 + if msb(dest) { 1i32 } else { 0i32 };
        let disp = self.asm.position() + entry.disp + inst_size;
        self.asm.movss_ra(dest, AsmAddress::rip(-disp));
    }

    fn mov_imm_f64(dest: FloatRegister, value: Float64) {
        let entry = self.constPool.push(ConstPoolValue::Float64(value));
        let inst_size = 8i32 + if msb(dest) { 1i32 } else { 0i32 };
        let disp = self.asm.position() + entry.disp + inst_size;
        self.asm.movsd_ra(dest, AsmAddress::rip(-disp));
    }

    fn emitCheckedDivModCommon(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getRegister();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let is_div = inst.op() == Op::CheckedDiv;

        assert(dest == if is_div { RAX } else { RDX });
        assert(loc.getTemp(0).getRegister() == if is_div { RDX } else { RAX });
        assert(lhs != RAX && rhs != RAX);
        assert(lhs != RDX && rhs != RDX);

        assert(inst.op() == Op::CheckedDiv || inst.op() == Op::CheckedMod);

        let lbl_overflow = self.asm.createLabel();
        let lbl_div = self.asm.createLabel();

        self.asm.movq_ri(REG_TEMP, Immediate(Int64::minValue()));
        self.asm.cmpq_rr(REG_TEMP, lhs);
        self.asm.jcc_near(Condition::NotEqual, lbl_div);
        self.asm.cmpq_ri(rhs, Immediate(-1));
        self.asm.jcc(Condition::Equal, lbl_overflow);
        self.asm.bindLabel(lbl_div);

        self.asm.movq_rr(RAX, lhs);
        self.asm.cqo();
        self.asm.idivq_r(rhs);

        self.deferred.push(|| {
            let op = if is_div { "CheckedDiv" } else { "CheckedMod" };
            self.emitComment("slow path for ${op} overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitWriteBarrier(host: Register, value: Register, snapshot: RegisterSnapshot) {
        let lbl_object_slow_path = self.asm.createLabel();
        let lbl_marking_slow_path = self.asm.createLabel();

        self.asm.cmpb_ai(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_MARKING_OFFSET), Immediate(0));
        self.asm.jcc(Condition::NotZero, lbl_marking_slow_path);

        self.asm.testb_ai(AsmAddress::offset(host, OBJECT_METADATA_OFFSET), Immediate(1 << METADATA_REMEMBERED_BIT));
        self.asm.jcc(Condition::Zero, lbl_object_slow_path);
        let lbl_return = self.asm.createAndBindLabel();

        self.deferred.push(|| {
            self.emitComment("marking barrier slow path");
            self.asm.bindLabel(lbl_marking_slow_path);
            self.asm.int3();
            self.asm.jmp(lbl_return);
        });

        self.deferred.push(|| {
            self.emitComment("object barrier slow path");
            self.asm.bindLabel(lbl_object_slow_path);
            self.asm.testq_rr(value, value);
            self.asm.jcc(Condition::Zero, lbl_return);
            self.saveRegistersForCall(snapshot);
            self.asm.movq_rr(CCALL_REG_PARAMS(0), host);
            self.asm.movq_rr(CCALL_REG_PARAMS(1), value);
            self.asm.movq_ri(REG_TEMP, Immediate(config.object_write_barrier_slow_path.toInt64()));
            self.asm.call_r(REG_TEMP);
            self.restoreRegistersForCall(snapshot);
            self.asm.jmp(lbl_return);
        });
    }

    fn emitObjectAllocate(obj: Register, size: Int32, tmp1: Register, tmp2: Register, snapshot: RegisterSnapshot) {
        let lbl_alloc_slow_path = self.asm.createLabel();

        self.asm.movq_ra(obj, AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_TLAB_TOP_OFFSET));
        self.asm.movq_ra(tmp1, AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_TLAB_END_OFFSET));

        self.asm.lea(tmp2, AsmAddress::offset(obj, size));
        self.asm.cmpq_rr(tmp2, tmp1);
        self.asm.jcc(Condition::Greater, lbl_alloc_slow_path);
        self.asm.movq_ar(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_TLAB_TOP_OFFSET), tmp2);
        let lbl_return = self.asm.createAndBindLabel();

        assert(snapshot.gp.remove(obj));

        self.deferred.push(|| {
            self.emitComment("allocation slow path");
            self.asm.bindLabel(lbl_alloc_slow_path);
            self.saveRegistersForCall(snapshot);
            self.asm.movq_ri(CCALL_REG_PARAMS(0), Immediate(size.toInt64()));
            self.asm.movq_ri(REG_TEMP, Immediate(config.allocation_slow_path.toInt64()));
            self.asm.call_r(REG_TEMP);
            self.asm.movq_rr(obj, RAX);
            self.restoreRegistersForCall(snapshot);
            self.asm.jmp(lbl_return);
        });
    }

    fn emitObjectInitialization(obj: Register, size: Int32, classptr: Address, tmp1: Register, tmp2: FloatRegister) {
        let metadata_part = 0xFF_FF_FF_FCi32 | 1i32 << METADATA_REMEMBERED_BIT;
        let classptr_part = classptr.value - config.meta_space_start.value;

        let header_word = metadata_part.toInt64() << 32i32 | classptr_part;
        self.asm.movq_ri(tmp1, Immediate(header_word));
        self.asm.movq_ar(AsmAddress::offset(obj, 0i32), tmp1);

        if size > OBJECT_HEADER_LENGTH {
            let size = size.toInt64();
            assert(size % PTR_SIZE.toInt64() == 0);
            self.asm.lea(tmp1, AsmAddress::offset(obj, OBJECT_HEADER_LENGTH));
            self.zeroMemory(tmp1, (size - OBJECT_HEADER_LENGTH.toInt64()) / PTR_SIZE.toInt64(), tmp2);
        }
    }

    fn zeroMemory(ptr: Register, words: Int64, tmp: FloatRegister) {
        self.emitComment("zero memory of fixed length");
        self.asm.xorps_rr(tmp, tmp);

        let mut idx = 0;

        while idx + 1 < words {
            self.asm.movups_ar(AsmAddress::offset(ptr, idx.toInt32() * PTR_SIZE), tmp);
            idx = idx + 2;
        }

        if idx < words {
            self.asm.movsd_ar(AsmAddress::offset(ptr, idx.toInt32() * PTR_SIZE), tmp);
            idx = idx + 1;
        }

        assert(idx == words);
    }

    fn zeroMemoryDynamic(ptr: Register, words: Register, tmp: FloatRegister) {
        self.emitComment("zero memory with dynamic length");
        let done = self.asm.createLabel();

        self.asm.testq_rr(words, words);
        self.asm.jcc(Condition::Zero, done);

        self.asm.xorps_rr(tmp, tmp);

        let loop = self.asm.createAndBindLabel();
        self.asm.movsd_ar(AsmAddress::array(ptr, words, ScaleFactor::Eight, -PTR_SIZE), tmp);
        self.asm.subq_ri(words, Immediate(1));
        self.asm.jcc(Condition::NotZero, loop);

        self.asm.bindLabel(done);
    }

    fn saveRegistersForCall(snapshot: RegisterSnapshot) {
        let regs = snapshot.gp.clone().difference(CALLEE_SAVED_REGS);

        while !regs.isEmpty() {
            let reg = regs.popLowestIndex().getOrPanic();
            self.asm.pushq_r(reg);
        }

        let regs = snapshot.fp.clone();

        if !regs.isEmpty() {
            let size = regs.size() * PTR_SIZE.toInt64();
            self.asm.subq_ri(RSP, Immediate(size));
            let mut offset = 0i32;

            while !regs.isEmpty() {
                let reg = regs.popLowestIndex().getOrPanic();
                self.asm.movsd_ar(AsmAddress::offset(RSP, offset), reg);
                offset = offset + PTR_SIZE;
            }
        }
    }

    fn restoreRegistersForCall(snapshot: RegisterSnapshot) {
        let regs = snapshot.gp.clone().difference(CALLEE_SAVED_REGS);

        while !regs.isEmpty() {
            let reg = regs.popHighestIndex().getOrPanic();
            self.asm.popq_r(reg);
        }

        let regs = snapshot.fp.clone();

        if !regs.isEmpty() {
            let mut offset = 0i32;

            while !regs.isEmpty() {
                let reg = regs.popLowestIndex().getOrPanic();
                self.asm.movsd_ra(reg, AsmAddress::offset(RSP, offset));
                offset = offset + PTR_SIZE;
            }

            let size = regs.size() * PTR_SIZE.toInt64();
            self.asm.addq_ri(RSP, Immediate(size));
        }
    }

    fn emitInvokeCommon(inst: Inst) {
        let fct_info = inst.getFunctionInfo();
        self.emitCall(fct_info.fct_id, fct_info.type_params, inst.bytecode_position(), inst.getLocationData().getGcPoint());
    }

    fn emitCall(fct_id: FctId, type_params: Array[BytecodeType], bytecode_position: Int32, gc_point: GcPoint) {
        let address = getFunctionAddress(fct_id, type_params);
        let cp_entry = self.constPool.push(ConstPoolValue::Address(address));
        self.loadConstPool(REG_TEMP, cp_entry);
        self.asm.call_r(REG_TEMP);

        let pos = self.asm.position();
        let site = LazyCompilationSiteDirect(
            fct_id,
            type_params,
            pos + cp_entry.disp,
        );
        let location = self.ci.bc.getLocationAt(bytecode_position);

        self.lazyCompilation.insert(pos, LazyCompilationSite::Direct(site));
        self.locations.insert(pos, location);
        self.gcPoints.insert(pos, gc_point);
    }

    fn emitVirtualCall(obj: Register, tmp1: Register, tmp2: Register, inst: Inst, vtable_index: Int32, site: LazyCompilationSite) {
        self.asm.movl_ra(tmp1, AsmAddress::offset(obj, 0i32));

        self.asm.movq_ri(tmp2, Immediate(config.meta_space_start.value));
        self.asm.addq_rr(tmp1, tmp2);

        let vtable_entry_offset = 32i32 + vtable_index * PTR_SIZE;
        self.asm.movq_ra(tmp1, AsmAddress::offset(tmp1, vtable_entry_offset));
        self.asm.call_r(tmp1);

        let pos = self.asm.position();
        let location = self.ci.bc.getLocationAt(inst.bytecode_position());

        self.lazyCompilation.insert(pos, site);
        self.locations.insert(pos, location);
        self.gcPoints.insert(pos, inst.getLocationData().getGcPoint());
    }
}

impl CodeGen for CodeGenX64 {
    fn allocatableRegisters(): RegSet[Register] {
        ALLOCATABLE_REGS
    }

    fn allocatableFloatRegisters(): RegSet[FloatRegister] {
        ALLOCATABLE_FREGS
    }

    fn argumentRegister(idx: Int64): Register {
        REG_PARAMS(idx)
    }

    fn argumentRegisters(): Array[Register] {
        REG_PARAMS
    }

    fn argumentFloatRegisters(): Array[FloatRegister] {
        FLOAT_REG_PARAMS
    }

    fn getScratchRegister(): Register {
        REG_TEMP
    }

    fn getFloatScratchRegister(): FloatRegister {
        FREG_TEMP
    }

    fn getReturnRegister(): Register {
        RAX
    }

    fn getFloatReturnRegister(): FloatRegister {
        XMM0
    }

    fn emitDebug() {
        self.asm.int3();
    }

    fn emitProlog(stackSize: Int32) {
        self.asm.pushq_r(RBP);
        self.asm.movq_rr(RBP, RSP);

        if stackSize > 0i32 {
            self.asm.subq_ri(RSP, Immediate(stackSize.toInt64()));
        }
    }

    fn emitStackLimitCheck() {
        let lbl_stack_overflow = self.asm.createLabel();
        self.asm.cmpq_ar(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET), RSP);
        self.asm.jcc(Condition::Above, lbl_stack_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for stack limit check");
            self.asm.bindLabel(lbl_stack_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.loc);
        });
    }

    fn emitSafepointCheck() {
        let lbl_safepoint = self.asm.createLabel();
        self.asm.cmpb_ai(AsmAddress::offset(REG_THREAD, THREAD_LOCAL_DATA_STATE_OFFSET), Immediate(0));
        self.asm.jcc(Condition::NotEqual, lbl_safepoint);

        self.deferred.push(|| {
            self.emitComment("slow path safepoint");
            self.asm.bindLabel(lbl_safepoint);

            self.asm.movq_ri(REG_TEMP, Immediate(config.safepoint_trampoline.toInt64()));
            self.asm.call_r(REG_TEMP);
            self.locations.insert(self.asm.position(), self.ci.loc);
        });
    }

    fn emitComment(comment: String) {
        self.comments.insert(self.asm.position(), comment);
    }

    fn registerName(register: Register): String {
        registerName(register)
    }

    fn createLabel(): Label {
        self.asm.createLabel()
    }

    fn bindLabel(label: Label) {
        self.asm.bindLabel(label);
    }

    fn spill(inst: Inst) {
        let loc = inst.getLocationData();
        let slot = loc.getSpillSlot();
        let ty = inst.getValueType();

        if ty.isAnyFloat() {
            let reg = loc.getOutput().getFloatRegister();

            if ty == Type::Float32 {
                self.asm.movss_ar(AsmAddress::offset(RBP, slot), reg);
            } else {
                assert(ty == Type::Float64);
                self.asm.movsd_ar(AsmAddress::offset(RBP, slot), reg);
            }
        } else {
            let reg = loc.getOutput().getRegister();

            if ty == Type::UInt8 || ty == Type::Bool {
                self.asm.movb_ar(AsmAddress::offset(RBP, slot), reg);
            } else if ty == Type::Int32 || ty == Type::Char {
                self.asm.movl_ar(AsmAddress::offset(RBP, slot), reg);
            } else if ty == Type::Int64 {
                self.asm.movq_ar(AsmAddress::offset(RBP, slot), reg);
            } else if ty == Type::Ptr {
                self.asm.movq_ar(AsmAddress::offset(RBP, slot), reg);
            } else {
                unimplemented();
            }
        }
    }

    fn emitInt32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(inst.getValueAsInt32().toInt64()));
    }

    fn emitInt64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movq_ri(register, Immediate(inst.getValueAsInt64()));
    }

    fn emitFloat32Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getFloatRegister();
        self.mov_imm_f32(register, inst.getValueAsFloat32());
    }

    fn emitFloat64Const(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getFloatRegister();
        self.mov_imm_f64(register, inst.getValueAsFloat64());
    }

    fn emitTrueConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(1));
    }

    fn emitFalseConst(inst: Inst) {
        let loc = inst.getLocationData();
        let register = loc.getOutput().getRegister();
        self.asm.movl_ri(register, Immediate(0));
    }

    fn emitAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.addss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.addsd_rr(output, rhs);
        }
    }

    fn emitSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.subss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.subsd_rr(output, rhs);
        }
    }

    fn emitMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.mulss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.mulsd_rr(output, rhs);
        }
    }

    fn emitDiv(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getFloatRegister();
        let rhs = loc.getInput(1).getFloatRegister();
        let output = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        if ty == Type::Float32 {
            self.asm.movss_rr(output, lhs);
            self.asm.divss_rr(output, rhs);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(output, lhs);
            self.asm.divsd_rr(output, rhs);
        }
    }

    fn emitNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getFloatRegister();
        let dest = loc.getOutput().getFloatRegister();

        let ty = inst.getValueType();

        let value = if ty == Type::Float32 {
            1 << 31i32
        } else {
            assert(ty == Type::Float64);
            1 << 63i32
        };

        if ty == Type::Float32 {
            self.asm.movss_rr(dest, src);
        } else {
            assert(ty == Type::Float64);
            self.asm.movsd_rr(dest, src);
        }

        let disp = self.constPool.push(ConstPoolValue::Int128(value, 0)).disp;
        let pos = self.asm.position();

        let inst_size = 7i32
            + if ty == Type::Float64 { 1i32 } else { 0i32 }
            + if dest.needsRexBit() { 1i32 } else { 0i32 };

        let address = AsmAddress::rip(-(disp + pos + inst_size));

        if ty == Type::Float32 {
            self.asm.xorps_ra(dest, address)
        } else {
            assert(ty == Type::Float64);
            self.asm.xorpd_ra(dest, address)
        }
    }

    fn emitCheckedAdd(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        assert(dest == lhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.addl_rr(dest, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.addq_rr(dest, rhs);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedAdd overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedSub(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        assert(dest == lhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.subl_rr(dest, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.subq_rr(dest, rhs);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedSub overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedMul(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();

        let dest = loc.getOutput().getRegister();
        let lbl_overflow = self.asm.createLabel();

        assert(dest == lhs);

        if inst.getValueType() == Type::Int32 {
            self.asm.imull_rr(dest, rhs);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.imulq_rr(dest, rhs);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedMul overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn setLocationConstraintsCheckedAdd(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputSameAsFirstInput(inst);
    }

    fn setLocationConstraintsCheckedSub(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputSameAsFirstInput(inst);
    }

    fn setLocationConstraintsCheckedMul(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputSameAsFirstInput(inst);
    }

    fn setLocationConstraintsCheckedDiv(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegisterFixed(inst, RAX, true);
        addTempRegisterFixed(inst, RDX);
    }

    fn setLocationConstraintsCheckedMod(inst: Inst, loc: LocationData) {
        useInputRegister(inst, 0);
        useInputRegister(inst, 1);
        useOutputRegisterFixed(inst, RDX, true);
        addTempRegisterFixed(inst, RAX);
    }

    fn setLocationConstraintsReturn(inst: Inst, loc: LocationData) {
        if inst.hasInput() {
            if inst.getOperationType().isAnyFloat() {
                useInputFloatRegisterFixed(inst, 0, XMM0);
            } else {
                useInputRegisterFixed(inst, 0, RAX);
            }
        }
    }

    fn emitCheckedDiv(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitCheckedMod(inst: Inst) {
        self.emitCheckedDivModCommon(inst);
    }

    fn emitDivZeroCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let op = loc.getInput(0).getRegister();

        let lbl_failure = self.asm.createLabel();
        self.asm.testq_rr(op, op);
        self.asm.jcc(Condition::Zero, lbl_failure);

        self.deferred.push(|| {
            self.emitComment("slow path for div-by-0 check");
            self.asm.bindLabel(lbl_failure);
            self.trap(REG_TEMP, TRAP_DIV0, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitCheckedNeg(inst: Inst) {
        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();
        let dest = loc.getOutput().getRegister();

        let lbl_overflow = self.asm.createLabel();

        if inst.getValueType() == Type::Int32 {
            self.asm.movl_rr(dest, src);
            self.asm.negl_r(dest);
        } else {
            assert(inst.getValueType() == Type::Int64);
            self.asm.movq_rr(dest, src);
            self.asm.negq_r(dest);
        }

        self.asm.jcc(Condition::Overflow, lbl_overflow);

        self.deferred.push(|| {
            self.emitComment("slow path for CheckedNeg overflow");
            self.asm.bindLabel(lbl_overflow);
            self.trap(REG_TEMP, TRAP_OVERFLOW, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitIf(inst: Inst) {
        let loc = inst.getLocationData();
        let opnd = loc.getInput(0).getRegister();

        let currentBlock = inst.getBlock();
        let trueBlock = inst.getTrueBlock();
        let falseBlock = inst.getFalseBlock();

        if currentBlock.postOrderIdx == trueBlock.postOrderIdx + 1i32 {
            self.asm.testl_rr(opnd, opnd);
            self.asm.jcc(Condition::Zero, falseBlock.getLabel());
        } else {
            assert(currentBlock.postOrderIdx == falseBlock.postOrderIdx + 1i32);
            self.asm.testl_rr(opnd, opnd);
            self.asm.jcc(Condition::NotZero, trueBlock.getLabel());
        }
    }

    fn emitGoto(inst: Inst) {
        let currentBlock = inst.getBlock();
        let targetBlock = inst.getTargetBlock();

        if currentBlock.successors(0).isBackward() {
            self.emitSafepointCheck();
        }

        if currentBlock.postOrderIdx != targetBlock.postOrderIdx + 1i32 {
            self.asm.jmp(targetBlock.getLabel());
        }
    }

    fn emitReturn(inst: Inst) {
        if inst.hasInput() {
            let loc = inst.getLocationData();

            if inst.getOperationType().isAnyFloat() {
                let register = loc.getInput(0).getFloatRegister();
                assert(register == XMM0);
            } else {
                let register = loc.getInput(0).getRegister();
                assert(register == RAX);
            }
        }

        self.epilog();
    }

    fn emitMove(inst: Inst) {
        let loc = inst.getLocationData();
        let dest = loc.getOutput().getLocation();
        let src = loc.getInput(0).getLocation();
        let ty = inst.getValueType();

        if dest.isRegister() {
            if src.isRegister() {
                // Register-to-Register
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.movq_rr(dest.getRegister(), src.getRegister());
                } else {
                    assert(ty == Type::Int32 || ty == Type::Bool);
                    self.asm.movl_rr(dest.getRegister(), src.getRegister());
                }
            } else {
                // Reload
                assert(src.isStack());
                let slot = src.getStack();
                assert(slot.isFp());
                let offset = slot.getOffset();

                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.movq_ra(dest.getRegister(), AsmAddress::offset(RBP, offset));
                } else if ty == Type::Int32 {
                    self.asm.movl_ra(dest.getRegister(), AsmAddress::offset(RBP, offset));
                } else {
                    assert(ty == Type::Bool || ty == Type::UInt8);
                    self.asm.movb_ra(dest.getRegister(), AsmAddress::offset(RBP, offset));
                }
            }
        } else if dest.isFloatRegister() {
            if src.isFloatRegister() {
                // Register-to-Register
                if ty == Type::Float32 {
                    self.asm.movss_rr(dest.getFloatRegister(), src.getFloatRegister());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.movsd_rr(dest.getFloatRegister(), src.getFloatRegister());
                }
            } else {
                // Reload
                assert(src.isStack());
                let slot = src.getStack();
                assert(slot.isFp());
                let offset = slot.getOffset();

                if ty == Type::Float32 {
                    self.asm.movss_ra(dest.getFloatRegister(), AsmAddress::offset(RBP, offset));
                } else {
                    assert(ty == Type::Float64);
                    self.asm.movsd_ra(dest.getFloatRegister(), AsmAddress::offset(RBP, offset));
                }
            }
        } else {
            // Spill
            assert(dest.isStack());
            let slot = dest.getStack();
            let stack_reg = if slot.isFp() { RBP } else { RSP };
            let offset = slot.getOffset();

            if src.isFloatRegister() {
                if ty == Type::Float32 {
                    self.asm.movss_ar(AsmAddress::offset(stack_reg, offset), src.getFloatRegister());
                } else {
                    assert(ty == Type::Float64);
                    self.asm.movsd_ar(AsmAddress::offset(stack_reg, offset), src.getFloatRegister());
                }
            } else if src.isRegister() {
                if ty == Type::Int64 || ty == Type::Ptr {
                    self.asm.movq_ar(AsmAddress::offset(stack_reg, offset), src.getRegister());
                } else if ty == Type::Int32 {
                    self.asm.movl_ar(AsmAddress::offset(stack_reg, offset), src.getRegister());
                } else {
                    assert(ty == Type::Bool);
                    self.asm.movb_ar(AsmAddress::offset(stack_reg, offset), src.getRegister());
                }
            } else {
                let src_slot = src.getStack();
                assert(src_slot.isFp());
                let src_offset = src_slot.getOffset();

                if ty == Type::UInt8 || ty == Type::Bool {
                    self.asm.movb_ra(REG_TEMP, AsmAddress::offset(RBP, src_offset));
                    self.asm.movb_ar(AsmAddress::offset(stack_reg, offset), REG_TEMP);
                } else if ty == Type::Int32 || ty == Type::Char || ty == Type::Float32 {
                    self.asm.movl_ra(REG_TEMP, AsmAddress::offset(RBP, src_offset));
                    self.asm.movl_ar(AsmAddress::offset(stack_reg, offset), REG_TEMP);
                } else if ty == Type::Int64 || ty == Type::Ptr || ty == Type::Float64 {
                    self.asm.movq_ra(REG_TEMP, AsmAddress::offset(RBP, src_offset));
                    self.asm.movq_ar(AsmAddress::offset(stack_reg, offset), REG_TEMP);
                } else {
                    unimplemented();
                }
            }
        }
    }

    fn emitCompare(inst: Inst) {
        let loc = inst.getLocationData();
        let lhs = loc.getInput(0).getRegister();
        let rhs = loc.getInput(1).getRegister();
        let dest = loc.getOutput().getRegister();

        let cond = match inst.op() {
            Op::Greater => Condition::Greater,
            Op::GreaterOrEqual => Condition::GreaterOrEqual,
            Op::Less => Condition::Less,
            Op::LessOrEqual => Condition::LessOrEqual,
            Op::Equal => Condition::Equal,
            Op::NotEqual => Condition::NotEqual,
            _ => unreachable[Condition](),
        };

        self.asm.cmpq_rr(lhs, rhs);
        self.asm.setcc_r(cond, dest);
        self.asm.movzxb_rr(dest, dest);
    }

    fn emitInvokeStatic(inst: Inst) {
        self.emitInvokeCommon(inst);
    }

    fn emitInvokeDirect(inst: Inst) {
        self.emitInvokeCommon(inst);
    }

    fn emitInvokeVirtual(inst: Inst) {
        let fct_info = inst.getVirtualFunctionInfo();
        let loc = inst.getLocationData();
        let obj = loc.getInput(0).getRegister();
        let tmp = loc.getTemp(0).getRegister();

        let site = LazyCompilationSiteVirtual(
            true,
            fct_info.fct_id,
            fct_info.type_params,
            fct_info.trait_object_ty,
        );
        let site = LazyCompilationSite::Virtual(site);

        let vtable_index = getFunctionVtableIndex(fct_info.fct_id);

        self.emitVirtualCall(obj, REG_TEMP, tmp, inst, vtable_index, site);
    }

    fn emitInvokeLambda(inst: Inst) {
        let fct_info = inst.getLambdaFunctionInfo();
        let loc = inst.getLocationData();
        let obj = loc.getInput(0).getRegister();
        let tmp = loc.getTemp(0).getRegister();

        let site = LazyCompilationSiteLambda(
            true,
            fct_info.params,
            fct_info.return_type,
        );
        let site = LazyCompilationSite::Lambda(site);

        self.emitVirtualCall(obj, REG_TEMP, tmp, inst, 0i32, site);
    }

    fn emitLoadField(inst: Inst) {
        let field_info = inst.getFieldInfo();
        let offset = getFieldOffset(field_info.cls_id, field_info.type_params, field_info.field_id);

        let loc = inst.getLocationData();
        let src = loc.getInput(0).getRegister();

        let ty = inst.getValueType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movb_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movl_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Ptr | Type::Int64 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movss_ra(dest, AsmAddress::offset(src, offset));
            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movsd_ra(dest, AsmAddress::offset(src, offset));
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitStoreField(inst: Inst) {
        let field_info = inst.getFieldInfo();
        let offset = field_info.offset.unwrapOrElse(||: Int32 {
            getFieldOffset(field_info.cls_id, field_info.type_params, field_info.field_id)
        });

        let loc = inst.getLocationData();
        let obj = loc.getInput(0).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let src = loc.getInput(1).getRegister();
                self.asm.movb_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Int32 => {
                let src = loc.getInput(1).getRegister();
                self.asm.movl_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Int64 => {
                let src = loc.getInput(1).getRegister();
                self.asm.movq_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Ptr => {
                let src = loc.getInput(1).getRegister();
                self.asm.movq_ar(AsmAddress::offset(obj, offset), src);
                self.emitWriteBarrier(obj, src, loc.getRegisterSnapshot());
            },

            Type::Float32 => {
                let src = loc.getInput(1).getFloatRegister();
                self.asm.movss_ar(AsmAddress::offset(obj, offset), src);
            },

            Type::Float64 => {
                let src = loc.getInput(1).getFloatRegister();
                self.asm.movsd_ar(AsmAddress::offset(obj, offset), src);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitArrayLength(inst: Inst) {
        let loc = inst.getLocationData();
        let arr = loc.getInput(0).getRegister();

        let dest = loc.getOutput().getRegister();
        self.asm.movq_ra(dest, AsmAddress::offset(arr, OBJECT_HEADER_LENGTH));
    }

    fn emitBoundsCheck(inst: Inst) {
        let loc = inst.getLocationData();
        let idx = loc.getInput(0).getRegister();
        let length = loc.getInput(1).getRegister();

        let label_oob = self.asm.createLabel();

        self.asm.cmpq_rr(idx, length);
        self.asm.jcc(Condition::AboveOrEqual, label_oob);

        self.deferred.push(|| {
            self.emitComment("slow path for BoundsCheck");
            self.asm.bindLabel(label_oob);
            self.trap(REG_TEMP, TRAP_INDEX_OUT_OF_BOUNDS, self.ci.bc.getLocationAt(inst.bytecode_position()));
        });
    }

    fn emitLoadArray(inst: Inst) {
        let loc = inst.getLocationData();
        let array = loc.getInput(0).getRegister();
        let idx = loc.getInput(1).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::array(array, idx, ScaleFactor::One, ARRAY_HEADER_LENGTH));
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Four, ARRAY_HEADER_LENGTH));
            },

            Type::Int64 | Type::Ptr => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH));
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movss_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Four, ARRAY_HEADER_LENGTH));
            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movsd_ra(dest, AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH));
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitStoreArray(inst: Inst) {
        let loc = inst.getLocationData();
        let array = loc.getInput(0).getRegister();
        let idx = loc.getInput(1).getRegister();

        let ty = inst.getOperationType();

        match ty {
            Type::Bool | Type::UInt8 => {
                let value = loc.getInput(2).getRegister();
                self.asm.movq_ar(AsmAddress::array(array, idx, ScaleFactor::One, ARRAY_HEADER_LENGTH), value);
            },

            Type::Int32 => {
                let value = loc.getInput(2).getRegister();
                self.asm.movq_ar(AsmAddress::array(array, idx, ScaleFactor::Four, ARRAY_HEADER_LENGTH), value);
            },

            Type::Int64 => {
                let value = loc.getInput(2).getRegister();
                self.asm.movq_ar(AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH), value);
            },

            Type::Ptr => {
                let value = loc.getInput(2).getRegister();
                self.asm.movq_ar(AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH), value);
                self.emitWriteBarrier(array, value, loc.getRegisterSnapshot());
            },

            Type::Float32 => {
                let value = loc.getInput(2).getFloatRegister();
                self.asm.movss_ar(AsmAddress::array(array, idx, ScaleFactor::Four, ARRAY_HEADER_LENGTH), value);
            },

            Type::Float64 => {
                let value = loc.getInput(2).getFloatRegister();
                self.asm.movsd_ar(AsmAddress::array(array, idx, ScaleFactor::Eight, ARRAY_HEADER_LENGTH), value);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitNewObject(inst: Inst) {
        let loc = inst.getLocationData();
        let obj = loc.getOutput().getRegister();
        let class_info = inst.getClassInfo();
        let size = getClassSize(class_info.class_id, class_info.type_params);

        let tmp = loc.getTemp(0).getRegister();
        self.emitObjectAllocate(obj, size, REG_TEMP, tmp, loc.getRegisterSnapshot());

        let classptr = getClassPointer(class_info.class_id, class_info.type_params);
        self.emitObjectInitialization(obj, size, classptr, REG_TEMP, FREG_TEMP);
    }

    fn emitNewLambda(inst: Inst) {
        let loc = inst.getLocationData();
        let obj = loc.getOutput().getRegister();
        let class_info = inst.getFunctionInfo();
        let size = LAMBDA_SIZE;

        let tmp = loc.getTemp(0).getRegister();
        self.emitObjectAllocate(obj, size, REG_TEMP, tmp, loc.getRegisterSnapshot());

        let classptr = getClassPointerForLambda(class_info.fct_id, class_info.type_params);
        self.emitObjectInitialization(obj, size, classptr, REG_TEMP, FREG_TEMP);
    }

    fn emitLoadGlobal(inst: Inst) {
        let loc = inst.getLocationData();

        let global_id = inst.getGlobalId();
        let value_address = getGlobalValueAddress(global_id);
        self.asm.movq_ri(REG_TEMP, Immediate(value_address.value));

        let ty = inst.getValueType();

        match ty {
            Type::UInt8 | Type::Bool => {
                let dest = loc.getOutput().getRegister();
                self.asm.movb_ra(dest, AsmAddress::offset(REG_TEMP, 0i32));
            },

            Type::Int32 => {
                let dest = loc.getOutput().getRegister();
                self.asm.movl_ra(dest, AsmAddress::offset(REG_TEMP, 0i32));
            },

            Type::Int64 | Type::Ptr => {
                let dest = loc.getOutput().getRegister();
                self.asm.movq_ra(dest, AsmAddress::offset(REG_TEMP, 0i32));
            },

            Type::Float32 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movss_ra(dest, AsmAddress::offset(REG_TEMP, 0i32));

            },

            Type::Float64 => {
                let dest = loc.getOutput().getFloatRegister();
                self.asm.movsd_ra(dest, AsmAddress::offset(REG_TEMP, 0i32));
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitEnsureGlobalInitialized(inst: Inst) {
        let loc = inst.getLocationData();
        let tmp = loc.getTemp(0).getRegister();

        let lbl_global_slow_path = self.asm.createLabel();

        let global_id = inst.getGlobalId();
        let state_address = getGlobalStateAddress(global_id);
        self.asm.movq_ri(REG_TEMP, Immediate(state_address.value));
        self.asm.cmpb_ai(AsmAddress::offset(REG_TEMP, 0i32), Immediate(GLOBAL_STATE_INITIALIZED.toInt64()));
        self.asm.jcc(Condition::NotEqual, lbl_global_slow_path);
        let lbl_return = self.asm.createAndBindLabel();

        self.deferred.push(|| {
            self.emitComment("slow path for global initializer");
            self.asm.bindLabel(lbl_global_slow_path);

            // Compute initial value.
            let fct_id = getGlobalInitializerFunctionId(global_id);
            let type_params = Array[BytecodeType]::new();
            self.emitCall(fct_id, type_params, inst.bytecode_position(), GcPoint::new());

            // Store initial value in global variable.
            let value_address = getGlobalValueAddress(global_id);
            self.asm.movq_ri(REG_TEMP, Immediate(value_address.value));

            match inst.getOperationType() {
                Type::UInt8 | Type::Bool => {
                    self.asm.movb_ar(AsmAddress::offset(REG_TEMP, 0i32), RAX);
                },

                Type::Int32 | Type::Char => {
                    self.asm.movl_ar(AsmAddress::offset(REG_TEMP, 0i32), RAX);
                },

                Type::Int64 | Type::Ptr => {
                    self.asm.movq_ar(AsmAddress::offset(REG_TEMP, 0i32), RAX);
                },

                Type::Float32 => {
                    self.asm.movss_ar(AsmAddress::offset(REG_TEMP, 0i32), XMM0);
                },

                Type::Float64 => {
                    self.asm.movsd_ar(AsmAddress::offset(REG_TEMP, 0i32), XMM0);
                },

                _ => {
                    unimplemented();
                }
            }

            // Set global variable state to INITIALIZED.
            self.asm.movq_ri(REG_TEMP, Immediate(state_address.value));
            self.asm.movb_ai(AsmAddress::offset(REG_TEMP, 0i32), Immediate(GLOBAL_STATE_INITIALIZED.toInt64()));

            self.asm.jmp(lbl_return);
        });
    }

    fn emitStoreGlobal(inst: Inst) {
        let loc = inst.getLocationData();

        let global_id = inst.getGlobalId();

        let value_address = getGlobalValueAddress(global_id);
        self.asm.movq_ri(REG_TEMP, Immediate(value_address.value));

        match inst.getOperationType() {
            Type::UInt8 | Type::Bool => {
                let src = loc.getInput(0).getRegister();
                self.asm.movb_ar(AsmAddress::offset(REG_TEMP, 0i32), src);
            },

            Type::Int32 | Type::Char => {
                let src = loc.getInput(0).getRegister();
                self.asm.movl_ar(AsmAddress::offset(REG_TEMP, 0i32), src);
            },

            Type::Int64 | Type::Ptr => {
                let src = loc.getInput(0).getRegister();
                self.asm.movq_ar(AsmAddress::offset(REG_TEMP, 0i32), src);
            },

            Type::Float32 => {
                let src = loc.getInput(0).getFloatRegister();
                self.asm.movss_ar(AsmAddress::offset(REG_TEMP, 0i32), src);
            },

            Type::Float64 => {
                let src = loc.getInput(0).getFloatRegister();
                self.asm.movsd_ar(AsmAddress::offset(REG_TEMP, 0i32), src);
            },

            _ => {
                unimplemented();
            }
        }
    }

    fn emitMarkGlobalInitialized(inst: Inst) {
        let global_id = inst.getGlobalId();

        let state_address = getGlobalStateAddress(global_id);
        self.asm.movq_ri(REG_TEMP, Immediate(state_address.value));
        self.asm.movb_ai(AsmAddress::offset(REG_TEMP, 0i32), Immediate(GLOBAL_STATE_INITIALIZED.toInt64()));
    }

    fn finalize(): CodeDescriptor {
        self.emitDeferredCode();
        self.asm.resolveJumps();
        self.asm.nop();

        if self.asm.size() % CODE_SIZE_ALIGNMENT != 0 {
            self.emitComment("align code");
            self.asm.alignCodeSize(CODE_SIZE_ALIGNMENT);
        }

        let code = self.asm.finalize();

        CodeDescriptor(
            self.constPool,
            code,
            self.lazyCompilation,
            self.gcPoints,
            self.locations,
            self.comments,
        )
    }
}
