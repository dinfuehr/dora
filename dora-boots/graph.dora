class Graph {
    var entryBlock: Block;
    var exitBlock: Block;

    var blocks: Vec[Block] = Vec[Block]();
    var reversePostOrder: Vec[Block] = Vec[Block]();

    var nextBlockIdValue: Int = 0;
    var nextInstIdValue: Int = 0;

    fun addBlock(block: Block) {
        assert(block.graph.isNone() && block.id == -1);

        block.graph = some[Graph](self);
        block.id = self.nextBlockId();
        self.blocks.push(block);
    }

    fun setEntryBlock(block: Block) {
        self.entryBlock = block;
    }

    fun getEntryBlock() -> Block {
        self.entryBlock
    }

    fun setExitBlock(block: Block) {
        self.exitBlock = block;
    }

    fun nextInstId() -> Int {
        let id = self.nextInstIdValue;
        self.nextInstIdValue = id + 1;

        id
    }

    fun nextBlockId() -> Int {
        let id = self.nextBlockIdValue;
        self.nextBlockIdValue = id + 1;

        id
    }

    fun numberBlocks() -> Int {
        self.nextBlockIdValue
    }
}

class Block() {
    var id: Int = -1;

    var phis: Vec[Inst] = Vec[Inst]();
    var instructions: InstLinkedList = InstLinkedList();

    var graph: Option[Graph] = none[Graph]();

    var dominator: Option[Block] = none[Block]();
    var dominatedBlocks: Vec[Block] = Vec[Block]();

    var predecessors: Vec[Block] = Vec[Block]();
    var successors: Vec[Block] = Vec[Block]();

    var loopHeader: Option[LoopHeader] = none[LoopHeader]();

    fun getDominator() -> Option[Block] {
        self.dominator
    }

    fun setDominator(block: Block) {
        self.dominator = some[Block](block);
    }

    fun dominates(other: Block) -> Bool {
        var current = other.getDominator();

        while current.isSome() {
            if self === current.unwrap() { return true; }
            current = current.unwrap().getDominator();
        }

        false
    }

    fun getDominatedBlocks() -> Vec[Block] {
        self.dominatedBlocks
    }

    fun addDominatedBlock(block: Block) {
        self.dominatedBlocks.push(block);
    }

    fun addPredecessor(block: Block) {
        self.predecessors.push(block);
        block.successors.push(block);
    }

    fun addSuccessor(block: Block) {
        self.successors.push(block);
        block.predecessors.push(block);
    }

    fun appendPhi(phi: PhiInst) -> PhiInst {
        assert(phi.block.isNone() && phi.id == -1);

        phi.block = some[Block](self);
        phi.id = self.graph.unwrap().nextInstId();

        self.phis.push(phi);
        phi.registerUses();

        phi
    }

    fun appendInst(inst: Inst) -> Inst {
        assert(inst.block.isNone() && inst.id == -1);

        inst.block = some[Block](self);
        inst.id = self.graph.unwrap().nextInstId();

        self.instructions.appendInst(inst);

        inst.registerUses();
        return inst;
    }

    fun addBackEdge(block: Block) {
        if self.loopHeader.isNone() {
            self.loopHeader = some[LoopHeader](LoopHeader(self));
        }
        self.loopHeader.unwrap().addBackEdge(block);
    }
}

impl Hash for Block {
  fun hash() -> Int = self.id.hash();
}

impl Equals for Block {
  fun equals(other: Block) -> Bool = self === other;
}

class LoopHeader(let header: Block) {
    var backEdges: Vec[Block] = Vec[Block]();

    fun getHeader() -> Block {
        self.header
    }

    fun addBackEdge(block: Block) {
        self.backEdges.push(block);
    }

    fun numberBackEdges() -> Int {
        self.backEdges.length()
    }
}

class Input(var idx: Int, var value: Inst, var usedBy: Inst) {
    var previousUse: Option[Input] = none[Input]();
    var nextUse: Option[Input] = none[Input]();
}

@abstract @open class Inst {
    var id: Int = -1;
    var block: Option[Block] = none[Block]();

    var previous: Option[Inst] = none[Inst]();
    var next: Option[Inst] = none[Inst]();

    var ty: Type = nil;

    var useListHead: Option[Input] = none[Input]();
    var useListTail: Option[Input] = none[Input]();

    var inputs: Vec[Input] = Vec[Input]();

    fun getType() -> Type {
        return self.ty;
    }

    fun addInput(inst: Inst) {
        let input = Input(self.inputs.length(), inst, self);
        self.inputs.push(input);
    }

    fun addUse(input: Input) {
        assert(input.value === self);

        if self.useListHead.isNone() {
            input.previousUse = none[Input]();
            input.nextUse = none[Input]();

            self.useListHead = some[Input](input);
            self.useListTail = some[Input](input);
        } else {
            input.previousUse = self.useListTail;
            input.nextUse = none[Input]();

            self.useListTail = some[Input](input);
        }
    }

    fun removeUse(input: Input) {
        assert(input.value === self);

        if input.previousUse.isNone() && input.nextUse.isNone() {
            self.useListHead = none[Input]();
            self.useListTail = none[Input]();
        } else if input.previousUse.isNone() {
            self.useListHead = input.nextUse;
            input.nextUse.unwrap().previousUse = none[Input]();
        } else if input.nextUse.isNone() {
            self.useListTail = input.previousUse;
            input.previousUse.unwrap().previousUse = none[Input]();
        } else {
            input.previousUse.unwrap().nextUse = input.nextUse;
            input.nextUse.unwrap().previousUse = input.previousUse;
        }

        input.previousUse = none[Input]();
        input.nextUse = none[Input]();
    }

    fun registerUses() {
        let inputs = self.inputs.length();
        var idx = 0;

        while idx < inputs {
            let input = self.inputs.get(idx);
            input.value.addUse(input);
            idx = idx + 1;
        }
    }

    fun hasUses() -> Bool {
        let result = self.useListHead.isSome();
        assert(result == self.useListTail.isSome());
        result
    }

    fun replaceWith(replacement: Inst) {
        while self.useListHead.isSome() {
            let input = self.useListHead.unwrap();
            input.usedBy.replaceInput(replacement, input.idx);
        }
    }

    fun replaceInput(replacement: Inst, idx: Int) {
        let input = self.inputs.get(idx);

        if input.value === replacement {
            return;
        }

        input.value.removeUse(input);
        input.value = replacement;
        replacement.addUse(input);
    }

    fun users() -> Array[Inst] {
        let data = Vec[Inst]();
        var current = self.useListHead;

        while current.isSome() {
            let cur = current.unwrap();
            data.push(cur.usedBy);
            current = cur.nextUse;
        }

        data.toArray()
    }
}

@abstract @open class Const: Inst
class IntConst(let value: Int): Const
class LongConst(let value: Long): Const
class FloatConst(let value: Float): Const
class DoubleConst(let value: Double): Const

class UnaryInst(let op: UnOp, let opnd: Inst): Inst {
    self.addInput(opnd);
}

class BinaryInst(let op: BinOp, let lhs: Inst, let rhs: Inst): Inst {
    self.addInput(lhs);
    self.addInput(rhs);
}

class Undef: Inst

class PhiInst: Inst

class ArrayGet(let array: Inst, let index: Inst): Inst {
    self.addInput(array);
    self.addInput(index);
}

class ArraySet(let array: Inst, let index: Inst, let value: Inst): Inst {
    self.addInput(array);
    self.addInput(index);
    self.addInput(value);
}

class ArrayLength(let array: Inst): Inst {
    self.addInput(array);
}

class ParamInst(let index: Int, ty: Type): Inst {
    self.ty = ty;
}

class ReturnInst(let value: Inst): Inst {
    self.addInput(value);
}

class ReturnVoidInst: Inst

class CondInst(let cond: Inst, let true_block: Block, let false_block: Block): Inst {
    self.addInput(cond);
}

class GotoInst(let block: Block): Inst

enum BinOp {
    Add, Sub, Mul, Div, Mod,
    FAdd, FSub, FMul, FDiv,
}

enum UnOp {
    Neg, FNeg, Not,
}

class InstLinkedList {
    var first: Option[Inst] = none[Inst]();
    var last: Option[Inst] = none[Inst]();

    fun isEmpty() -> Bool {
        self.first.isNone()
    }

    fun firstInst() -> Option[Inst] {
        self.first
    }

    fun lastInst() -> Option[Inst] {
        self.last
    }

    fun appendInst(inst: Inst) {
        if self.first.isNone() {
            inst.previous = none[Inst]();
            inst.next = none[Inst]();

            self.first = some[Inst](inst);
            self.last = some[Inst](inst);
        } else {
            self.last.unwrap().next = some[Inst](inst);

            inst.previous = self.last;
            inst.next = none[Inst]();

            self.last = some[Inst](inst);
        }
    }
}

class InstIterator(block: Block) {
    var current: Option[Inst] = block.instructions.first;

    fun hasNext() -> Bool {
        self.current.isSome()
    }

    fun next() -> Inst {
        let inst = self.current.unwrap();
        self.current = inst.next;
        inst
    }
}

class BackwardInstIterator(block: Block) {
    var current: Option[Inst] = block.instructions.last;

    fun hasNext() -> Bool {
        self.current.isSome()
    }

    fun next() -> Inst {
        let inst = self.current.unwrap();
        self.current = inst.previous;
        inst
    }
}
