use package::bytecode::data::{BytecodeType, FctId, Location};
use package::codegen::x64::CodeGenX64;
use package::codegen::arm64::CodeGenArm64;
use package::assembler::{FloatRegister, Label, Register, RegSet};
use package::interface::{Address, Architecture, CompilationInfo, config};
use package::graph::{Graph, Inst, LocationData, Op, Operand, Type};
use package::CodeDescriptor;

pub mod arm64;
pub mod x64;

const CODE_SIZE_ALIGNMENT: Int64 = 16;
pub const STACK_FRAME_ALIGNMENT: Int64 = 16;

pub fn createCodeGen(ci: CompilationInfo): CodeGen {
    match config.architecture {
        Architecture::X64 => CodeGenX64::new(ci) as CodeGen,
        Architecture::Arm64 => CodeGenArm64::new(ci) as CodeGen,
    }
}

pub fn generateCode(graph: Graph, codegen: CodeGen, ci: CompilationInfo): CodeDescriptor {
    let stackSize = graph.getStackSize();
    assert(stackSize >= 0i32);
    assert(stackSize % STACK_FRAME_ALIGNMENT.toInt32() == 0i32);

    if ci.emitDebug {
        codegen.emitDebug();
    }

    codegen.emitProlog(stackSize);

    codegen.emitComment("stack limit check");
    codegen.emitStackLimitCheck();

    codegen.emitComment("safepoint check");
    codegen.emitSafepointCheck();

    for block in graph.insertionOrderIterator() {
        block.setLabel(codegen.createLabel());
    }

    for block in graph.reversePostOrderIterator() {
        codegen.emitComment("Block ${block.id()}");
        codegen.bindLabel(block.getLabel());

        for inst in block.instructionsIterator() {
            emitInst(codegen, inst);

            let loc = inst.getLocationData();

            if loc.hasOutput() && loc.hasSpillSlot() {
                codegen.spill(inst);
            }
        }
    }

    codegen.finalize()
}

fn emitInst(codegen: CodeGen, inst: Inst) {
    match inst.op() {
        Op::Arg => {},

        Op::TrueConst => {
            codegen.emitComment("TrueConst");
            codegen.emitTrueConst(inst);
        },

        Op::FalseConst => {
            codegen.emitComment("FalseConst");
            codegen.emitFalseConst(inst);
        },

        Op::Int32Const => {
            codegen.emitComment("Int32Const");
            codegen.emitInt32Const(inst);
        },

        Op::Int64Const => {
            codegen.emitComment("Int64Const");
            codegen.emitInt64Const(inst);
        },

        Op::Float32Const => {
            codegen.emitComment("Float32Const");
            codegen.emitFloat32Const(inst);
        },

        Op::Float64Const => {
            codegen.emitComment("Float64Const");
            codegen.emitFloat64Const(inst);
        },

        Op::Add => {
            codegen.emitComment("Add");
            codegen.emitAdd(inst);
        },

        Op::Sub => {
            codegen.emitComment("Sub");
            codegen.emitSub(inst);
        },

        Op::Mul => {
            codegen.emitComment("Mul");
            codegen.emitMul(inst);
        },

        Op::Div => {
            codegen.emitComment("Div");
            codegen.emitDiv(inst);
        },

        Op::Neg => {
            codegen.emitComment("Neg");
            codegen.emitNeg(inst);
        },

        Op::CheckedAdd => {
            codegen.emitComment("CheckedAdd");
            codegen.emitCheckedAdd(inst);
        },

        Op::CheckedSub => {
            codegen.emitComment("CheckedSub");
            codegen.emitCheckedSub(inst);
        },

        Op::CheckedMul => {
            codegen.emitComment("CheckedMul");
            codegen.emitCheckedMul(inst);
        },

        Op::CheckedDiv => {
            codegen.emitComment("CheckedDiv");
            codegen.emitCheckedDiv(inst);
        },

        Op::CheckedMod => {
            codegen.emitComment("CheckedMod");
            codegen.emitCheckedMod(inst);
        },

        Op::CheckedNeg => {
            codegen.emitComment("CheckedNeg");
            codegen.emitCheckedNeg(inst);
        },

        Op::DivZeroCheck => {
            codegen.emitComment("DivZeroCheck");
            codegen.emitDivZeroCheck(inst);
        },

        Op::If => {
            codegen.emitComment("If");
            codegen.emitIf(inst);
        },

        Op::Goto => {
            codegen.emitComment("Goto");
            codegen.emitGoto(inst);
        },

        Op::Return => {
            codegen.emitComment("Return");
            codegen.emitReturn(inst);
        },

        Op::Move => {
            codegen.emitComment("Move");
            codegen.emitMove(inst);
        },

        Op::Greater
        | Op::GreaterOrEqual
        | Op::Less
        | Op::LessOrEqual
        | Op::Equal
        | Op::NotEqual => {
            codegen.emitComment("${inst.op().name()}");
            codegen.emitCompare(inst);
        },

        Op::InvokeStatic => {
            codegen.emitComment("InvokeStatic");
            codegen.emitInvokeStatic(inst);
        },

        _ => {
            println("unsupported op ${inst.op().name()}");
            unreachable[()]();
        }
    }
}

pub fn ensureLocationData(graph: Graph, codegen: CodeGen, ci: CompilationInfo) {
    let argumentLocations = computeArgumentLocations(codegen, ci);

    for block in graph.insertionOrderIterator() {
        for inst in block.phisIterator() {
            let loc_data = LocationData::new(inst);
            inst.setLocationData(loc_data);
        }

        for inst in block.instructionsIterator() {
            setLocationConstraints(inst, codegen, ci, argumentLocations);
        }
    }
}

fn setLocationConstraints(inst: Inst, codegen: CodeGen, ci: CompilationInfo, argumentLocations: Array[Operand]) {
    let loc = LocationData::new(inst);

    match inst.op() {
        Op::Arg => {
            let location = argumentLocations(inst.getIndex().toInt64());

            if location.isFloatRegister() {
                loc.requireOutputFixedFloatRegister(location.getFloatRegister());
            } else {
                assert(location.isRegister());
                loc.requireOutputFixedRegister(location.getRegister());
            }
        },

        Op::TrueConst |
        Op::FalseConst => {
            loc.requireOutputRegister();
        },

        Op::Int32Const
        | Op::Int64Const => {
            loc.requireOutputRegister();
        },

        Op::Float32Const
        | Op::Float64Const => {
            loc.requireOutputFloatRegister();
        },

        Op::DivZeroCheck => {
            loc.requireInputRegister(0);
        },

        Op::Greater
        | Op::GreaterOrEqual
        | Op::Less
        | Op::LessOrEqual
        | Op::Equal
        | Op::NotEqual => {
            if inst.getOperationType().isAnyFloat() {
                loc.requireInputFloatRegister(0);
                loc.requireInputFloatRegister(1);
            } else {
                loc.requireInputRegister(0);
                loc.requireInputRegister(1);
            }

            loc.requireOutputRegister();
        },

        Op::CheckedAdd => {
            codegen.setLocationConstraintsCheckedAdd(inst, loc);
        },

        Op::CheckedSub => {
            codegen.setLocationConstraintsCheckedSub(inst, loc);
        },

        Op::CheckedMul => {
            codegen.setLocationConstraintsCheckedMul(inst, loc);
        },

        Op::Add
        | Op::Sub
        | Op::Mul
        | Op::Div => {
            if inst.getValueType().isAnyFloat() {
                loc.requireInputFloatRegister(0);
                loc.requireInputFloatRegister(1);
                loc.requireOutputFloatRegister();
            } else {
                loc.requireInputRegister(0);
                loc.requireInputRegister(1);
                loc.requireOutputRegister();
            }
        },

        Op::CheckedDiv => {
            codegen.setLocationConstraintsCheckedDiv(inst, loc);
        },

        Op::CheckedMod => {
            codegen.setLocationConstraintsCheckedMod(inst, loc);
        },

        Op::Neg | Op::CheckedNeg => {
            if inst.getValueType().isAnyFloat() {
                loc.requireInputFloatRegister(0);
                loc.requireOutputFloatRegister();
            } else {
                loc.requireInputRegister(0);
                loc.requireOutputRegister();
            }
        },

        Op::If => {
            loc.requireInputRegister(0);
        },

        Op::Goto => {},

        Op::Return => {
            codegen.setLocationConstraintsReturn(inst, loc);
        },

        Op::InvokeStatic => {
            setLocationConstraintsInvokeStatic(inst, loc, codegen, ci);
        },

        _ => {
            println("unsupported op ${inst.op().name()}");
            unreachable[()]();
        }
    }

    inst.setLocationData(loc);
}

fn computeArgumentLocations(codegen: CodeGen, ci: CompilationInfo): Array[Operand] {
    let arguments = ci.bc.arguments.toInt64();
    let locations = Array[Operand]::fill(arguments, Operand::None);
    let mut gp_idx = 0;
    let mut fp_idx = 0;

    let gp_argument_registers = codegen.argumentRegisters();
    let fp_argument_registers = codegen.argumentFloatRegisters();

    for idx in std::range(0, arguments) {
        let ty = ci.bc.registers(idx);
        let ty = Type::fromBytecodeType(ty);

        if ty.isAnyFloat() {
            assert(fp_idx < fp_argument_registers.size());
            locations(idx) = fp_argument_registers(fp_idx).toOperand();
            fp_idx = fp_idx + 1;
        } else {
            assert(gp_idx < gp_argument_registers.size());
            locations(idx) = gp_argument_registers(gp_idx).toOperand();
            gp_idx = gp_idx + 1;
        }
    }


    locations
}

fn setLocationConstraintsInvokeStatic(inst: Inst, loc: LocationData, codegen: CodeGen, ci: CompilationInfo) {
    let mut idx = 0;
    let mut gp_idx = 0;
    let mut fp_idx = 0;

    let gp_regs = codegen.argumentRegisters();
    let fp_regs = codegen.argumentFloatRegisters();

    for input in inst.getInputs() {
        if input.getValue().getValueType().isAnyFloat() {
            loc.requireInputFixedFloatRegister(idx, fp_regs(fp_idx));
            fp_idx = fp_idx + 1;
        } else {
            loc.requireInputFixedRegister(idx, gp_regs(gp_idx));
            gp_idx = gp_idx + 1;
        }
        idx = idx + 1;
    }

    let ty = inst.getValueType();

    if !ty.isUnit() {
        if ty.isAnyFloat() {
            let reg = codegen.getFloatReturnRegister();
            loc.requireOutputFixedFloatRegister(reg);
        } else {
            let reg = codegen.getReturnRegister();
            loc.requireOutputFixedRegister(reg);
        }
    }
}

pub trait CodeGen {
    fn allocatableRegisters(): RegSet[Register];
    fn allocatableFloatRegisters(): RegSet[FloatRegister];

    fn argumentRegister(idx: Int64): Register;
    fn argumentRegisters(): Array[Register];
    fn argumentFloatRegisters(): Array[FloatRegister];

    fn getScratchRegister(): Register;
    fn getFloatScratchRegister(): FloatRegister;

    fn getReturnRegister(): Register;
    fn getFloatReturnRegister(): FloatRegister;

    fn emitDebug();
    fn emitProlog(stackSize: Int32);
    fn emitStackLimitCheck();
    fn emitSafepointCheck();

    fn finalize(): CodeDescriptor;

    fn registerName(register: Register): String;

    fn createLabel(): Label;
    fn bindLabel(label: Label);

    fn spill(inst: Inst);

    fn setLocationConstraintsCheckedAdd(inst: Inst, loc: LocationData);
    fn setLocationConstraintsCheckedSub(inst: Inst, loc: LocationData);
    fn setLocationConstraintsCheckedMul(inst: Inst, loc: LocationData);
    fn setLocationConstraintsCheckedDiv(inst: Inst, loc: LocationData);
    fn setLocationConstraintsCheckedMod(inst: Inst, loc: LocationData);
    fn setLocationConstraintsReturn(inst: Inst, loc: LocationData);

    fn emitTrueConst(inst: Inst);
    fn emitFalseConst(inst: Inst);
    fn emitInt32Const(inst: Inst);
    fn emitInt64Const(inst: Inst);
    fn emitFloat32Const(inst: Inst);
    fn emitFloat64Const(inst: Inst);
    fn emitAdd(inst: Inst);
    fn emitSub(inst: Inst);
    fn emitMul(inst: Inst);
    fn emitDiv(inst: Inst);
    fn emitNeg(inst: Inst);
    fn emitCheckedAdd(inst: Inst);
    fn emitCheckedSub(inst: Inst);
    fn emitCheckedMul(inst: Inst);
    fn emitCheckedDiv(inst: Inst);
    fn emitCheckedMod(inst: Inst);
    fn emitDivZeroCheck(inst: Inst);
    fn emitCheckedNeg(inst: Inst);
    fn emitIf(inst: Inst);
    fn emitGoto(inst: Inst);
    fn emitReturn(inst: Inst);
    fn emitMove(inst: Inst);
    fn emitCompare(inst: Inst);
    fn emitInvokeStatic(inst: Inst);

    fn emitComment(comment: String);
}
