use std::collections::VecIter;

use package::assembler::{Register, RegSet};
use package::graph::{Inst, LocationData, Op};

pub mod arm64;
pub mod x64;

pub trait CodeGen {
    fn allocatableRegisters(): RegSet;
    fn argumentRegister(idx: Int64): Register;
    fn prolog();
    fn finalize(): CodeDescriptor;

    fn setSubLocationData(inst: Inst, loc: LocationData);

    fn emitInt64Const(inst: Inst);
    fn emitAdd(inst: Inst);
    fn emitSub(inst: Inst);
    fn emitMul(inst: Inst);
    fn emitDiv(inst: Inst);
    fn emitMod(inst: Inst);
    fn emitReturn(inst: Inst);

}

pub fn setLocationConstraints(codegen: CodeGen, inst: Inst) {
    let loc = LocationData::new(inst);

    match inst.op() {
        Op::Arg => {
            let idx = inst.auxAsInt32().toInt64();
            let reg = codegen.argumentRegister(idx);
            loc.requireOutputFixedRegister(reg);
        },

        Op::Int64Const => {
            loc.requireOutputRegister();
        },

        Op::Add => {
            loc.requireInputRegister(0);
            loc.requireInputRegister(1);
            loc.requireOutputRegister();
        },

        Op::Sub => {
            codegen.setSubLocationData(inst, loc);
        },

        Op::Mul => {
            unreachable[()]();
        },

        Op::Div => {
            unreachable[()]();

        },

        Op::Mod => {
            unreachable[()]();
        },

        Op::Return => {
            if inst.hasInput() {
                loc.requireInputRegister(0);
            }
        },

        _ => {
            unreachable[()]();
        }
    }

    inst.setLocationData(loc);
}

pub fn emitInst(codegen: CodeGen, inst: Inst) {
    match inst.op() {
        Op::Arg => {},

        Op::Int64Const => {
            codegen.emitInt64Const(inst);
        },

        Op::Add => {
            codegen.emitAdd(inst);
        },

        Op::Sub => {
            codegen.emitSub(inst);
        },

        Op::Mul => {
            codegen.emitMul(inst);
        },

        Op::Div => {
            codegen.emitDiv(inst);
        },

        Op::Mod => {
            codegen.emitMod(inst);
        },

        Op::Return => {
            codegen.emitReturn(inst);
        },

        _ => {
            unreachable[()]();
        }
    }
}

pub class CodeDescriptor {
    pub code: Array[UInt8],
    pub comments: CommentTable,
}

pub class CommentTable {
    entries: Vec[(Int32, String)],
}

impl CommentTable {
    pub static fn new(): CommentTable {
        CommentTable(
            Vec[(Int32, String)]::new(),
        )
    }

    pub fn insert(offset: Int32, comment: String) {
        self.entries.push((offset, comment));
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, String)] {
        self.entries.makeIterator()
    }
}