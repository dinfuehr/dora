use std::collections::VecIter;

use package::bytecode::data::Location;
use package::assembler::{Label, Register, RegSet};
use package::interface::CompilationInfo;
use package::graph::{Inst, LocationData, Op};

pub mod arm64;
pub mod x64;

const CODE_SIZE_ALIGNMENT: Int64 = 16;

pub trait CodeGen {
    fn allocatableRegisters(): RegSet;
    fn argumentRegister(idx: Int64): Register;
    fn getScratchRegister(): Register;

    fn prolog();
    fn finalize(): CodeDescriptor;

    fn registerName(register: Register): String;

    fn createLabel(): Label;
    fn bindLabel(label: Label);

    fn emitTrueConst(inst: Inst);
    fn emitFalseConst(inst: Inst);
    fn emitInt64Const(inst: Inst);
    fn emitInt32Const(inst: Inst);
    fn emitCheckedAdd(inst: Inst);
    fn emitCheckedSub(inst: Inst);
    fn emitCheckedMul(inst: Inst);
    fn emitCheckedDiv(inst: Inst);
    fn emitCheckedMod(inst: Inst);
    fn emitDivZeroCheck(inst: Inst);
    fn emitCheckedNeg(inst: Inst);
    fn emitIf(inst: Inst);
    fn emitGoto(inst: Inst);
    fn emitReturn(inst: Inst);
    fn emitMove(inst: Inst);
    fn emitCompare(inst: Inst);

    fn emitComment(comment: String);

}

pub fn setLocationConstraints(codegen: CodeGen, inst: Inst) {
    let loc = LocationData::new(inst);

    match inst.op() {
        Op::Arg => {
            let idx = inst.auxAsInt32().toInt64();
            let reg = codegen.argumentRegister(idx);
            loc.requireOutputFixedRegister(reg);
        },

        Op::TrueConst |
        Op::FalseConst => {
            loc.requireOutputRegister();
        },

        Op::Phi => {
            loc.requireOutputRegister();
            let mut idx = 0;

            for input in inst.getInputs() {
                loc.requireInputRegister(idx);
                idx = idx + 1;
            }
        },

        Op::Int32Const
        | Op::Int64Const => {
            loc.requireOutputRegister();
        },

        Op::DivZeroCheck => {
            loc.requireInputRegister(0);
        },

        Op::Greater
        | Op::GreaterOrEqual
        | Op::Less
        | Op::LessOrEqual
        | Op::Equal
        | Op::NotEqual => {
            loc.requireInputRegister(0);
            loc.requireInputRegister(1);
            loc.requireOutputRegister();
        },

        Op::CheckedAdd
        | Op::CheckedSub
        | Op::CheckedMul
        | Op::CheckedDiv
        | Op::CheckedMod => {
            loc.requireInputRegister(0);
            loc.requireInputRegister(1);
            loc.requireOutputRegister();
        },

        Op::CheckedNeg => {
            loc.requireInputRegister(0);
            loc.requireOutputRegister();
        },

        Op::If => {
            loc.requireInputRegister(0);
        },

        Op::Goto => {},

        Op::Return => {
            if inst.hasInput() {
                loc.requireInputRegister(0);
            }
        },

        _ => {
            println("unsupported op ${inst.op().name()}");
            unreachable[()]();
        }
    }

    inst.setLocationData(loc);
}

pub fn emitInst(codegen: CodeGen, inst: Inst) {
    match inst.op() {
        Op::Arg => {},

        Op::TrueConst => {
            codegen.emitComment("TrueConst");
            codegen.emitTrueConst(inst);
        },

        Op::FalseConst => {
            codegen.emitComment("FalseConst");
            codegen.emitFalseConst(inst);
        },

        Op::Int32Const => {
            codegen.emitComment("Int32Const");
            codegen.emitInt32Const(inst);
        },

        Op::Int64Const => {
            codegen.emitComment("Int64Const");
            codegen.emitInt64Const(inst);
        },

        Op::CheckedAdd => {
            codegen.emitComment("CheckedAdd");
            codegen.emitCheckedAdd(inst);
        },

        Op::CheckedSub => {
            codegen.emitComment("CheckedSub");
            codegen.emitCheckedSub(inst);
        },

        Op::CheckedMul => {
            codegen.emitComment("CheckedMul");
            codegen.emitCheckedMul(inst);
        },

        Op::CheckedDiv => {
            codegen.emitComment("CheckedDiv");
            codegen.emitCheckedDiv(inst);
        },

        Op::CheckedMod => {
            codegen.emitComment("CheckedMod");
            codegen.emitCheckedMod(inst);
        },

        Op::CheckedNeg => {
            codegen.emitComment("CheckedNeg");
            codegen.emitCheckedNeg(inst);
        },

        Op::DivZeroCheck => {
            codegen.emitComment("DivZeroCheck");
            codegen.emitDivZeroCheck(inst);
        },

        Op::If => {
            codegen.emitComment("If");
            codegen.emitIf(inst);
        },

        Op::Goto => {
            codegen.emitComment("Goto");
            codegen.emitGoto(inst);
        },

        Op::Return => {
            codegen.emitComment("Return");
            codegen.emitReturn(inst);
        },

        Op::Move => {
            codegen.emitComment("Move");
            codegen.emitMove(inst);
        },

        Op::Greater
        | Op::GreaterOrEqual
        | Op::Less
        | Op::LessOrEqual
        | Op::Equal
        | Op::NotEqual => {
            codegen.emitComment("${inst.op().name()}");
            codegen.emitCompare(inst);
        },

        _ => {
            println("unsupported op ${inst.op().name()}");
            unreachable[()]();
        }
    }
}

pub class CodeDescriptor {
    pub code: Array[UInt8],
    pub comments: CommentTable,
    pub locations: LocationTable,
}

pub class CommentTable {
    entries: Vec[(Int32, String)],
}

impl CommentTable {
    pub static fn new(): CommentTable {
        CommentTable(
            Vec[(Int32, String)]::new(),
        )
    }

    pub fn insert(offset: Int32, comment: String) {
        if self.entries.last().isSome() {
            let last = self.entries.last().getOrPanic();
            assert(last.0 <= offset);
        }

        self.entries.push((offset, comment));
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, String)] {
        self.entries.makeIterator()
    }
}

pub class LocationTable {
    entries: Vec[(Int32, Location)],
}

impl LocationTable {
    pub static fn new(): LocationTable {
        LocationTable(
            Vec[(Int32, Location)]::new(),
        )
    }

    pub fn insert(offset: Int32, location: Location) {
        if self.entries.last().isSome() {
            let last = self.entries.last().getOrPanic();
            assert(last.0 <= offset);
        }

        self.entries.push((offset, location));
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, Location)] {
        self.entries.makeIterator()
    }
}
