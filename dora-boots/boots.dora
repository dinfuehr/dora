use package::assembler::RegSet;
use package::codegen::CodeGen;
use package::codegen::x64::CodeGenX64;
use package::codegen::arm64::CodeGenArm64;
use package::codegen::{emitInst, CodeDescriptor, setLocationConstraints};
use package::dominator::buildDominatorTree;
use package::graph::{createMove, Graph, Location, LocationData, Op, opName};
use package::graph::dump::dumpGraph;
use package::graph_builder::createGraph;
use package::interface::{Architecture, CompilationInfo};
use package::interface::{compile, config, getSystemConfig};
use package::liveness::computeLiveness;

mod assembler;
mod bytecode;
mod codegen;
mod dce;
mod deserializer;
mod dominator_test;
mod dominator;
mod graph;
mod graph_builder_tests;
mod graph_builder;
mod interface;
mod liveness;
mod serializer;

pub fn compileFunction(ci: CompilationInfo): CodeDescriptor {
    let graph = createGraph(ci.bc);
    let codegen = createCodeGen(ci);

    buildDominatorTree(graph);
    computeLiveness(graph);

    if (ci.emitGraph) {
        println("after graph building:");
        println(dumpGraph(graph, config.architecture));
    }

    ensureLocationData(graph, codegen);
    allocateRegisters(graph, codegen);
    removePhis(graph);

    if (ci.emitGraph) {
        println("after register allocation:");
        println(dumpGraph(graph, config.architecture));
    }

    generate(graph, codegen)
}

fn ensureLocationData(graph: Graph, codegen: CodeGen) {
    for block in graph.insertionOrderIterator() {
        for inst in block.instructionsIterator() {
            setLocationConstraints(codegen, inst);
        }
    }
}

fn allocateRegisters(graph: Graph, codegen: CodeGen) {
    let available_registers = codegen.allocatableRegisters();

    for block in graph.reversePostOrderIterator() {
        for inst in block.phisIterator() {
            let loc = inst.getLocationData();

            // pick a register
            let register = available_registers.acquire().getOrPanic();
            loc.getOutput().setRegister(register);
        }

        for inst in block.instructionsIterator() {
            let loc = inst.getLocationData();
            let mut idx = 0;

            for input in inst.getInputs() {
                let value = input.getValue();
                let output = value.getLocationData().getOutput();
                loc.getInput(idx).setRegister(output.getRegister());
                idx = idx + 1;
            }

            if loc.hasOutput() {
                let output = loc.getOutput();

                if output.hasRegister() {
                    // fixed register was already assigned
                    assert(available_registers.contains(output.getRegister()));
                    available_registers.remove(output.getRegister());
                } else {
                    // pick a register
                    let register = available_registers.acquire().getOrPanic();
                    output.setRegister(register);
                }
            }
        }
    }
}

fn removePhis(graph: Graph) {
    for block in graph.insertionOrderIterator() {
        for phi in block.phisIterator() {
            let phiDestRegister = phi.getLocationData().getOutput().getRegister();

            for predecessorEdge in block.predecessors {
                let predecessor = predecessorEdge.source;
                let value = phi.getInput(predecessorEdge.targetIdx).getValue();

                // Critical edges are not supported yet.
                assert(predecessor.successors.size() == 1);

                let valueRegister = value.getLocationData().getOutput().getRegister();

                // Insert move into predecessor
                // TODO: should be parallel move
                let inst = createMove(phiDestRegister, valueRegister);
                let terminator = predecessor.lastInst();
                assert(terminator.isTerminator());
                predecessor.insertBefore(inst, terminator);
            }
        }
    }
}

fn generate(graph: Graph, codegen: CodeGen): CodeDescriptor {
    codegen.prolog();

    for block in graph.insertionOrderIterator() {
        codegen.emitComment("Block ${block.id()}");

        for inst in block.instructionsIterator() {
            emitInst(codegen, inst);
        }
    }

    codegen.finalize()
}

fn createCodeGen(ci: CompilationInfo): CodeGen {
    match config.architecture {
        Architecture::X64 => CodeGenX64::new(ci) as CodeGen,
        Architecture::Arm64 => CodeGenArm64::new(ci) as CodeGen,
    }
}