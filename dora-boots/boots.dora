use std::collections::HashMap;

use package::assembler::{RegMap, RegSet, Register};
use package::codegen::CodeGen;
use package::codegen::{createCodeGen, emitInst, CodeDescriptor, generateCode, setLocationConstraints};
use package::dominator::buildDominatorTree;
use package::graph::{createGotoInst, createMove, Block, Edge, Graph, Inst, Location, LocationData, Op, opName};
use package::graph::dump::dumpGraph;
use package::graph_builder::createGraph;
use package::interface::{Architecture, CompilationInfo};
use package::interface::{compile, config, getSystemConfig};
use package::regalloc::performRegisterAllocation;
use package::liveness::computeLiveness;

mod assembler;
mod bytecode;
mod codegen;
mod dce;
mod deserializer;
mod dominator_test;
mod dominator;
mod graph;
mod graph_builder_tests;
mod graph_builder;
mod interface;
mod liveness;
mod regalloc;
mod serializer;

pub class CompilationData {
    ci: CompilationInfo,
    graph: Graph,
    codegen: CodeGen,
    stackSize: Option[Int32],
}

pub fn compileFunction(ci: CompilationInfo): CodeDescriptor {
    let graph = createGraph(ci.bc);
    let codegen = createCodeGen(ci);

    let cd = CompilationData(
        ci,
        graph,
        codegen,
        None[Int32],
    );

    if (ci.emitGraph) {
        println("after graph building:");
        println(dumpGraph(graph, config.architecture));
    }

    splitCriticalEdges(graph);

    if (ci.emitGraph) {
        println("after critical edge splitting:");
        println(dumpGraph(graph, config.architecture));
    }

    buildDominatorTree(graph);
    computeLiveness(graph);

    if (ci.emitGraph) {
        println("before register allocation:");
        println(dumpGraph(graph, config.architecture));
    }

    performRegisterAllocation(cd);

    if (ci.emitGraph) {
        println("after register allocation:");
        println(dumpGraph(graph, config.architecture));
    }

    generateCode(cd)
}

fn splitCriticalEdges(graph: Graph) {
    for block in graph.insertionOrderIterator() {
        if block.predecessors.size() <= 1 {
            continue;
        }

        for predecessorEdge in block.predecessors {
            let predecessor = predecessorEdge.source;

            if predecessor.successors.size() == 1 {
                continue;
            }

            // Found a critical edge.
            splitCriticalEdge(graph, predecessorEdge);
        }
    }
}

fn splitCriticalEdge(graph: Graph, edge: Edge) {
    let predecessor = edge.source;
    let successor = edge.target;

    let intermediate = Block::new();
    graph.addBlock(intermediate);

    let inst = createGotoInst(successor);
    intermediate.appendInst(inst);

    let terminator = predecessor.lastInst();
    assert(terminator.op() == Op::If);
    if terminator.getTrueBlock() === successor {
        terminator.setTrueBlock(intermediate);
    } else {
        assert(terminator.getFalseBlock() === successor);
        terminator.setFalseBlock(intermediate);
    }

    let predecessorToIntermediateEdge = Edge::new(edge.source, edge.sourceIdx, intermediate, 0);
    assert(intermediate.predecessors.isEmpty());
    intermediate.predecessors.push(predecessorToIntermediateEdge);

    predecessor.successors(edge.sourceIdx) = predecessorToIntermediateEdge;

    let intermediateToSuccessorEdge = edge;
    intermediateToSuccessorEdge.source = intermediate;
    intermediateToSuccessorEdge.sourceIdx = 0;
    assert(intermediate.successors.isEmpty());
    intermediate.successors.push(intermediateToSuccessorEdge);
}
