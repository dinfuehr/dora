use package::assembler::AssemblerBuffer;
use package::assembler::Label;
use package::assembler::MachineCode;
use package::assembler::Register;
use package::assembler::assertAsm32;

let R0: Register = Register(0i32);
let R1: Register = Register(1i32);
let R2: Register = Register(2i32);
let R3: Register = Register(3i32);
let R4: Register = Register(4i32);
let R5: Register = Register(5i32);
let R6: Register = Register(6i32);
let R7: Register = Register(7i32);
let R8: Register = Register(8i32);
let R9: Register = Register(9i32);
let R10: Register = Register(10i32);
let R11: Register = Register(11i32);
let R12: Register = Register(12i32);
let R13: Register = Register(13i32);
let R14: Register = Register(14i32);
let R15: Register = Register(15i32);

let R16: Register = Register(16i32);
let R17: Register = Register(17i32);
let R18: Register = Register(18i32);
let R19: Register = Register(19i32);
let R20: Register = Register(20i32);
let R21: Register = Register(21i32);
let R22: Register = Register(22i32);
let R23: Register = Register(23i32);
let R24: Register = Register(24i32);
let R25: Register = Register(25i32);
let R26: Register = Register(26i32);
let R27: Register = Register(27i32);
let R28: Register = Register(28i32);
let R29: Register = Register(29i32);
let R30: Register = Register(30i32);

let REG_ZERO: Register = Register(32i32);
let REG_SP: Register = Register(33i32);

let REG_FP: Register = R29;
let REG_LR: Register = R30;

struct NeonRegister(value: Int32)

impl NeonRegister {
    fn encoding(): Int32 {
        self.value
    }
}

let F0: NeonRegister = NeonRegister(0i32);
let F1: NeonRegister = NeonRegister(1i32);
let F2: NeonRegister = NeonRegister(2i32);
let F3: NeonRegister = NeonRegister(3i32);
let F4: NeonRegister = NeonRegister(4i32);
let F5: NeonRegister = NeonRegister(5i32);
let F6: NeonRegister = NeonRegister(6i32);
let F7: NeonRegister = NeonRegister(7i32);
let F8: NeonRegister = NeonRegister(8i32);
let F9: NeonRegister = NeonRegister(9i32);
let F10: NeonRegister = NeonRegister(10i32);
let F11: NeonRegister = NeonRegister(11i32);
let F12: NeonRegister = NeonRegister(12i32);
let F13: NeonRegister = NeonRegister(13i32);
let F14: NeonRegister = NeonRegister(14i32);
let F15: NeonRegister = NeonRegister(15i32);

let F16: NeonRegister = NeonRegister(16i32);
let F17: NeonRegister = NeonRegister(17i32);
let F18: NeonRegister = NeonRegister(18i32);
let F19: NeonRegister = NeonRegister(19i32);
let F20: NeonRegister = NeonRegister(20i32);
let F21: NeonRegister = NeonRegister(21i32);
let F22: NeonRegister = NeonRegister(22i32);
let F23: NeonRegister = NeonRegister(23i32);
let F24: NeonRegister = NeonRegister(24i32);
let F25: NeonRegister = NeonRegister(25i32);
let F26: NeonRegister = NeonRegister(26i32);
let F27: NeonRegister = NeonRegister(27i32);
let F28: NeonRegister = NeonRegister(28i32);
let F29: NeonRegister = NeonRegister(29i32);
let F30: NeonRegister = NeonRegister(30i32);
let F31: NeonRegister = NeonRegister(31i32);

class ForwardJump {
    offset: Int64,
    label: Label,
    kind: JumpKind
}

enum JumpKind {
    Unconditional(Bool),
    Conditional(Cond),
    Zero(Bool, Bool, Register),
}

enum Cond {
    EQ, // equal
    NE, // not equal
    CS,
    HS, // carry set, unsigned higher or same
    CC,
    LO, // carry clear, unsigned lower
    MI, // negative
    PL, // positive or zero
    VS, // overflow
    VC, // no overflow
    HI, // unsigned higher
    LS, // unsigned lower or same
    GE, // signed greater than or equal
    LT, // signed less than
    GT, // signed greater than
    LE, // signed less than or equal
}

impl Cond {
    pub fn invert(): Cond {
        match self {
            Cond::EQ => Cond::NE,
            Cond::NE => Cond::EQ,
            Cond::CS => Cond::CC,
            Cond::HS => Cond::CC,
            Cond::CC => Cond::CS,
            Cond::LO => Cond::CS,
            Cond::MI => Cond::PL,
            Cond::PL => Cond::MI,
            Cond::VS => Cond::VC,
            Cond::VC => Cond::VS,
            Cond::HI => Cond::LS,
            Cond::LS => Cond::HI,
            Cond::GE => Cond::LT,
            Cond::LT => Cond::GE,
            Cond::GT => Cond::LE,
            Cond::LE => Cond::GT,
        }
    }

    pub fn encoding(): Int32 {
        match self {
            Cond::EQ => 0b0000i32,
            Cond::NE => 0b0001i32,
            Cond::CS => 0b0010i32,
            Cond::HS => 0b0010i32,
            Cond::CC => 0b0011i32,
            Cond::LO => 0b0011i32,
            Cond::MI => 0b0100i32,
            Cond::PL => 0b0101i32,
            Cond::VS => 0b0110i32,
            Cond::VC => 0b0111i32,
            Cond::HI => 0b1000i32,
            Cond::LS => 0b1001i32,
            Cond::GE => 0b1010i32,
            Cond::LT => 0b1011i32,
            Cond::GT => 0b1100i32,
            Cond::LE => 0b1101i32,
        }
    }
}

pub class AssemblerArm64 {
    buffer: AssemblerBuffer,
    jumps: Vec[ForwardJump],
}

impl AssemblerArm64 {
    pub static fn new(): AssemblerArm64 {
        AssemblerArm64(
            AssemblerBuffer::new(),
            Vec[ForwardJump]::new()
        )
    }

    pub fn add_ext(
        rd: Register,
        rn: Register,
        rm: Register,
        extend: Extend,
        amount: Int32,
    ) {
        self.buffer.emitInt32(encoding::addsub_extreg(1i32, 0i32, false, 0i32, rm, extend, amount, rn, rd));
    }

    pub fn add_ext_w(
        rd: Register,
        rn: Register,
        rm: Register,
        extend: Extend,
        amount: Int32,
    ) {
        self.buffer.emitInt32(encoding::addsub_extreg(0i32, 0i32, false, 0i32, rm, extend, amount, rn, rd));
    }

    pub fn add_sh(rd: Register, rn: Register, rm: Register, shift: Shift, amount: Int32) {
        self.buffer.emitInt32(encoding::addsub_shreg(1i32, 0i32, 0i32, shift, rm, amount, rn, rd));
    }

    pub fn add_sh_w(
        rd: Register,
        rn: Register,
        rm: Register,
        shift: Shift,
        amount: Int32,
    ) {
        self.buffer.emitInt32(encoding::addsub_shreg(0i32, 0i32, 0i32, shift, rm, amount, rn, rd));
    }

    pub fn add_imm(rd: Register, rn: Register, imm: Int32) {
        let (shift, imm12) = imm_encoding::imm12(imm);
        self.buffer.emitInt32(encoding::addsub_imm(1i32, 0i32, false, shift, imm12, rn, rd));
    }

    pub fn add_imm_w(rd: Register, rn: Register, imm: Int32) {
        let (shift, imm12) = imm_encoding::imm12(imm);
        self.buffer.emitInt32(encoding::addsub_imm(0i32, 0i32, false, shift, imm12, rn, rd));
    }

    pub fn adds_imm(rd: Register, rn: Register, imm: Int32) {
        let (shift, imm12) = imm_encoding::imm12(imm);
        self.buffer.emitInt32(encoding::addsub_imm(1i32, 0i32, true, shift, imm12, rn, rd));
    }

    pub fn adds_imm_w(rd: Register, rn: Register, imm: Int32) {
        let (shift, imm12) = imm_encoding::imm12(imm);
        self.buffer.emitInt32(encoding::addsub_imm(0i32, 0i32, true, shift, imm12, rn, rd));
    }

    pub fn adds_sh(rd: Register, rn: Register, rm: Register, shift: Shift, amount: Int32) {
        self.buffer.emitInt32(encoding::addsub_shreg(1i32, 0i32, 1i32, shift, rm, amount, rn, rd));
    }

    pub fn adds_sh_w(
        rd: Register,
        rn: Register,
        rm: Register,
        shift: Shift,
        amount: Int32,
    ) {
        self.buffer.emitInt32(encoding::addsub_shreg(0i32, 0i32, 1i32, shift, rm, amount, rn, rd));
    }

    pub fn adds(rd: Register, rn: Register, rm: Register) {
        self.buffer.emitInt32(encoding::addsub_shreg(1i32, 0i32, 1i32, Shift::LSL, rm, 0i32, rn, rd));
    }

    pub fn adds_w(rd: Register, rn: Register, rm: Register) {
        self.buffer.emitInt32(encoding::addsub_shreg(0i32, 0i32, 1i32, Shift::LSL, rm, 0i32, rn, rd));
    }

    pub fn adr_imm(rd: Register, imm: Int32) {
        self.buffer.emitInt32(encoding::pcrel(0i32, imm, rd));
    }

    pub fn asrv(rd: Register, rn: Register, rm: Register) {
        self.buffer.emitInt32(encoding::dataproc2(1i32, 0i32, rm, 0b1010i32, rn, rd));
    }

    pub fn asrv_w(rd: Register, rn: Register, rm: Register) {
        self.buffer.emitInt32(encoding::dataproc2(0i32, 0i32, rm, 0b1010i32, rn, rd));
    }

    pub fn and_imm(rd: Register, rn: Register, imm: Int64) {
        let n_immr_imms = imm_encoding::logical_imm(imm, 64).getOrPanic();
        self.buffer.emitInt32(encoding::logical_imm(1i32, 0b00i32, n_immr_imms, rn, rd));
    }

    pub fn and_imm_w(rd: Register, rn: Register, imm: Int64) {
        let n_immr_imms = imm_encoding::logical_imm(imm, 32).getOrPanic();
        self.buffer.emitInt32(encoding::logical_imm(0i32, 0b00i32, n_immr_imms, rn, rd));
    }

    pub fn b(target: Label) {
        if target.isBound() {
            let diff = target.offset - self.buffer.position();
            assert(diff % 4 == 0);
            let inst = encoding::uncond_branch_imm(0i32, (diff / 4).toInt32());
            self.buffer.emitInt32(inst);
        } else {
            let pos = self.buffer.position();
            self.buffer.emitInt32(0i32);
            self.jumps.push(ForwardJump(
                pos,
                target,
                JumpKind::Unconditional(false),
            ));
        }
    }

    pub fn bc(cond: Cond, target: Label) {
        if target.isBound() {
            let diff = target.offset - self.buffer.position();
            assert(diff % 4 == 0);
            self.bc_imm(cond, (diff / 4).toInt32());
        } else {
            let pos = self.buffer.position();
            self.buffer.emitInt32(0i32);
            self.buffer.emitInt32(0i32);
            self.jumps.push(ForwardJump(
                pos,
                target,
                JumpKind::Conditional(cond),
            ));
        }
    }

    fn bc_imm(cond: Cond, diff: Int32) {
        let inst = encoding::cond_branch_imm(cond, diff);
        self.buffer.emitInt32(inst);
    }

    pub fn bfm(rd: Register, rn: Register, immr: Int32, imms: Int32) {
        self.buffer.emitInt32(encoding::bitfield(1i32, 0b01i32, 1i32, immr, imms, rn, rd));
    }

    pub fn bfm_w(rd: Register, rn: Register, immr: Int32, imms: Int32) {
        self.buffer.emitInt32(encoding::bitfield(0i32, 0b01i32, 0i32, immr, imms, rn, rd));
    }

    pub fn bic_sh(rd: Register, rn: Register, rm: Register, shift: Shift, imm6: Int32) {
        self.buffer.emitInt32(encoding::logical_shreg(1i32, 0b00i32, shift, 1i32, rm, imm6, rn, rd));
    }

    pub fn bic_sh_w(rd: Register, rn: Register, rm: Register, shift: Shift, imm6: Int32) {
        self.buffer.emitInt32(encoding::logical_shreg(0i32, 0b00i32, shift, 1i32, rm, imm6, rn, rd));
    }

    pub fn bics_sh(rd: Register, rn: Register, rm: Register, shift: Shift, imm6: Int32) {
        self.buffer.emitInt32(encoding::logical_shreg(1i32, 0b11i32, shift, 1i32, rm, imm6, rn, rd));
    }

    pub fn bics_sh_w(rd: Register, rn: Register, rm: Register, shift: Shift, imm6: Int32) {
        self.buffer.emitInt32(encoding::logical_shreg(0i32, 0b11i32, shift, 1i32, rm, imm6, rn, rd));
    }

    pub fn bl(target: Label) {
        if target.isBound() {
            let diff = target.offset - self.buffer.position();
            assert(diff % 4 == 0);
            let inst = encoding::uncond_branch_imm(1i32, (diff / 4).toInt32());
            self.buffer.emitInt32(inst);
        } else {
            let pos = self.buffer.position();
            self.buffer.emitInt32(0i32);
            self.jumps.push(ForwardJump(
                pos,
                target,
                JumpKind::Unconditional(true),
            ));
        }
    }

    pub fn blr(rn: Register) {
        let inst = encoding::uncond_branch_reg(0b0001i32, 0b11111i32, 0i32, rn, 0i32);
        self.buffer.emitInt32(inst);
    }

    pub fn br(rn: Register) {
        let inst = encoding::uncond_branch_reg(0b0000i32, 0b11111i32, 0i32, rn, 0i32);
        self.buffer.emitInt32(inst);
    }

    pub fn brk(imm16: Int32) {
        self.buffer.emitInt32(encoding::exception(0b001i32, imm16, 0i32, 0i32));
    }

   pub fn cas(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b11i32, 1i32, 0i32, 1i32, cmp, 0i32, REG_ZERO, addr, new,
        ))
    }

    pub fn cas_w(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b10i32, 1i32, 0i32, 1i32, cmp, 0i32, REG_ZERO, addr, new,
        ))
    }

    pub fn casa(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b11i32, 1i32, 1i32, 1i32, cmp, 0i32, REG_ZERO, addr, new,
        ))
    }

    pub fn casa_w(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b10i32, 1i32, 1i32, 1i32, cmp, 0i32, REG_ZERO, addr, new,
        ))
    }

    pub fn casal(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b11i32, 1i32, 1i32, 1i32, cmp, 1i32, REG_ZERO, addr, new,
        ))
    }

    pub fn casal_w(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b10i32, 1i32, 1i32, 1i32, cmp, 1i32, REG_ZERO, addr, new,
        ))
    }

    pub fn casl(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b11i32, 1i32, 0i32, 1i32, cmp, 1i32, REG_ZERO, addr, new,
        ))
    }

    pub fn casl_w(cmp: Register, new: Register, addr: Register) {
        self.buffer.emitInt32(encoding::ldst_exclusive(
            0b10i32, 1i32, 0i32, 1i32, cmp, 1i32, REG_ZERO, addr, new,
        ))
    }

    pub fn cbnz(reg: Register, target: Label) {
        self.common_cbz_cbnz(true, true, reg, target);
    }

    pub fn cbnz_w(reg: Register, target: Label) {
        self.common_cbz_cbnz(false, true, reg, target);
    }

    pub fn cbz(reg: Register, target: Label) {
        self.common_cbz_cbnz(true, false, reg, target);
    }

    pub fn cbz_w(reg: Register, target: Label) {
        self.common_cbz_cbnz(false, false, reg, target);
    }

    fn common_cbz_cbnz(sf: Bool, value: Bool, reg: Register, target: Label) {
        if target.isBound() {
            let diff = target.offset - self.buffer.position();
            assert(diff % 4 == 0);

            let inst =
                encoding::cmp_branch_imm(
                    sf.toInt32(),
                    value.toInt32(),
                    reg,
                    (diff / 4).toInt32(),
                );
            self.buffer.emitInt32(inst);
        } else {
            let pos = self.buffer.position();
            self.buffer.emitInt32(0i32);
            self.buffer.emitInt32(0i32);

            self.jumps.push(ForwardJump(
                pos,
                target,
                JumpKind::Zero(sf, value, reg),
            ));
        }
    }

    pub fn nop() {
        self.buffer.emitInt32(encoding::system(0i32));
    }


    pub fn ret() {
        let inst = encoding::uncond_branch_reg(0b0010i32, 0b11111i32, 0i32, REG_LR, 0i32);
        self.buffer.emitInt32(inst);
    }

    pub fn ret_r(rn: Register) {
        let inst = encoding::uncond_branch_reg(0b0010i32, 0b11111i32, 0i32, rn, 0i32);
        self.buffer.emitInt32(inst);
    }

    pub fn subs(rd: Register, rn: Register, rm: Register) {
        self.buffer.emitInt32(encoding::addsub_shreg(1i32, 1i32, 1i32, Shift::LSL, rm, 0i32, rn, rd));
    }

    pub fn subs_w(rd: Register, rn: Register, rm: Register) {
        self.buffer.emitInt32(encoding::addsub_shreg(0i32, 1i32, 1i32, Shift::LSL, rm, 0i32, rn, rd));
    }

    pub fn subs_sh(rd: Register, rn: Register, rm: Register, shift: Shift, amount: Int32) {
        self.buffer.emitInt32(encoding::addsub_shreg(1i32, 1i32, 1i32, shift, rm, amount, rn, rd));
    }

    pub fn subs_sh_w(
        rd: Register,
        rn: Register,
        rm: Register,
        shift: Shift,
        amount: Int32,
    ) {
        self.buffer.emitInt32(encoding::addsub_shreg(0i32, 1i32, 1i32, shift, rm, amount, rn, rd));
    }

    pub fn finalize(): Array[UInt8] {
        self.resolveJumps();
        while self.buffer.size() % 16 != 0 {
            self.ret();
        }
        self.buffer.toArray()
    }

    fn finalizeTesting(): MachineCode {
        self.resolveJumps();
        MachineCode::new(self.buffer.toArray())
    }

    fn resolveJumps() {
        let old_position = self.buffer.position();

        for jmp in self.jumps {
            assert(jmp.label.isBound());

            let distance = jmp.label.offset - jmp.offset;
            assert(distance % 4 == 0);
            let distance = (distance / 4).toInt32();

            self.buffer.setPosition(jmp.offset);

            match jmp.kind {
                JumpKind::Conditional(cond) => {
                    self.bc_imm(cond, distance);
                    self.nop();
                },

                JumpKind::Unconditional(with_link) => {
                    let inst = encoding::uncond_branch_imm(with_link.toInt32(), distance);
                    self.buffer.emitInt32(inst);
                },

                JumpKind::Zero(sf, value, rt) => {
                    let inst = encoding::cmp_branch_imm(sf.toInt32(), value.toInt32(), rt, distance);
                    self.buffer.emitInt32(inst);
                    self.nop();
                }
            }
        }

        self.jumps.clear();
        self.buffer.setPosition(old_position);
    }
}

impl Register {
    fn isGpr(): Bool {
        self.value <= 30i32
    }

    fn isGprOrZero(): Bool {
        self.isGpr() || self == REG_ZERO
    }

    fn isGprOrSp(): Bool {
        self.isGpr() || self == REG_SP
    }

    fn encoding(): Int32 {
        assert(self.isGpr());
        self.value
    }

    fn encodingZero(): Int32 {
        assert(self.isGprOrZero());

        if self.isGpr() {
            self.value
        } else {
            31i32
        }
    }

    fn encodingSp(): Int32 {
        assert(self.isGprOrSp());

        if self.isGpr() {
            self.value
        } else {
            31i32
        }
    }
}

pub enum Extend {
    UXTB,
    UXTH,
    LSL,
    UXTW,
    UXTX,
    SXTB,
    SXTH,
    SXTW,
    SXTX,
}

impl Extend {
    fn encoding(): Int32 {
        match self {
            Extend::UXTB => 0b000,
            Extend::UXTH => 0b001,
            Extend::LSL => 0b010,
            Extend::UXTW => 0b010,
            Extend::UXTX => 0b011,
            Extend::SXTB => 0b100,
            Extend::SXTH => 0b101,
            Extend::SXTW => 0b110,
            Extend::SXTX => 0b111,
        }
    }

    fn ldst_encoding(): Int32 {
        match self {
            Extend::UXTW => 0b010,
            Extend::LSL => 0b011,
            Extend::SXTW => 0b110,
            Extend::SXTX => 0b111,
            _ => unreachable[Int32](),
        }
    }
}

pub enum Shift {
    LSL,
    LSR,
    ASR,
    ROR,
}

impl Shift {
    fn isRor(): Bool {
        match self {
            Shift::ROR => true,
            _ => false,
        }
    }

    fn encoding(): Int32 {
        match self {
            Shift::LSL => 0i32,
            Shift::LSR => 1i32,
            Shift::ASR => 2i32,
            Shift::ROR => 3i32,
        }
    }
}

mod imm_encoding {
    pub fn logical_imm(mut imm: Int64, reg_size: Int64): Option[Int32] {
        assert(reg_size == 32 || reg_size == 64);

        if imm == 0 || imm == !0 || (reg_size != 64 && (imm >> reg_size.toInt32() != 0 || imm == (!0i32).toInt64())) {
            return None;
        }

        // determine element size, use smallest possible element size
        let mut size: Int64 = reg_size;

        while size > 2 {
            size = size / 2;

            let mask: Int64 = (1 << size.toInt32()) - 1;

            if (imm & mask) != (imm >> size.toInt32()) & mask {
                size = size * 2;
                break;
            }
        }

        // truncate immediate to element size
        let mask = !0 >> (64 - size).toInt32();
        imm = imm & mask;

        let mut rotation: Int64 = 0;
        let mut ones: Int64 = 0;

        if isShiftedMask(imm) {
            let tz = imm.countZeroBitsTrailing().toInt64();

            rotation = (size - tz) & (size - 1);
            ones = (!(imm >> tz.toInt32())).countZeroBitsTrailing().toInt64();

        // not all immediates are shifted masks: e.g. 1001
        } else {
            // extend imm again to 64 bits: e.g. 1..1|1001
            imm = imm | !mask;

            // the negation of the immediate now needs to be
            // a shifted mask
            if !isShiftedMask(!imm) {
                return None;
            }

            let lo = (!imm).countZeroBitsLeading().toInt64();
            let to = (!imm).countZeroBitsTrailing().toInt64();

            rotation = lo - (64 - size);
            ones = lo + to - (64 - size);
        }

        assert(ones > 0);
        assert(rotation < size);

        let immr = rotation;
        let mut nimms = !(size - 1) << 1i32;
        nimms = nimms | (ones - 1);

        let n = ((nimms >> 6i32) & 1) ^ 1;

        let result = n << 12i32 | immr << 6i32 | nimms & 0x3f;
        Some(result.toInt32())
    }

    fn isShiftedMask(imm: Int64): Bool {
        imm != 0 && isMask((imm - 1) | imm)
    }

    fn isMask(imm: Int64): Bool {
        imm != 0 && imm.wrappingAdd(1) & imm == 0
    }

    pub fn imm12(mut imm: Int32): (Int32, Int32) {
        if imm < (1i32 << 12i32) {
            return (0i32, imm);
        }

        imm = imm >> 12i32;

        if imm < (1i32 << 12i32) {
            (1i32, imm)
        } else {
            std::fatalError("illegal value");
            unreachable[(Int32, Int32)]()
        }

    }
}

mod encoding {
    use package::assembler::Register;
    use super::{Extend, Shift, Cond, NeonRegister};

    pub fn addsub_extreg(
        sf: Int32,
        op: Int32,
        s: Bool,
        opt: Int32,
        rm: Register,
        option: Extend,
        imm3: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(op));
        assert(opt == 0i32);
        assert(rm.isGprOrZero());
        assert(fitsU2(imm3));
        assert(rn.isGprOrSp());

        // Register 31 is xzr when setting flags or xsp when not.
        let rd = if s {
            assert(rd.isGprOrZero());
            rd.encodingZero()
        } else {
            assert(rd.isGprOrSp());
            rd.encodingSp()
        };

        sf << 31i32
            | op << 30i32
            | s.toInt32() << 29i32
            | 0b01011i32 << 24i32
            | opt << 22i32
            | 1i32 << 21i32
            | rm.encodingZero() << 16i32
            | option.encoding() << 13i32
            | imm3 << 10i32
            | rn.encodingSp() << 5i32
            | rd
    }

    pub fn addsub_shreg(
        sf: Int32,
        op: Int32,
        s: Int32,
        shift: Shift,
        rm: Register,
        imm6: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(op));
        assert(fitsBit(s));
        assert(!shift.isRor());
        assert(rm.isGpr());
        assert(fitsU6(imm6));
        assert(rn.isGprOrZero());
        assert(rd.isGprOrZero());

        0b01011i32 << 24i32
            | sf << 31i32
            | op << 30i32
            | s << 29i32
            | shift.encoding() << 22i32
            | rm.encoding() << 16i32
            | imm6 << 10i32
            | rn.encodingZero() << 5i32
            | rd.encodingZero()
    }

    pub fn addsub_imm(
        sf: Int32,
        op: Int32,
        s: Bool,
        shift: Int32,
        imm12: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(op));
        assert(fitsBit(shift));
        assert(fitsU12(imm12));
        assert(rn.isGprOrSp());

        let rd = if s {
            assert(rd.isGprOrZero());
            rd.encodingZero()
        } else {
            assert(rd.isGprOrSp());
            rd.encodingSp()
        };

        0b10001i32 << 24i32
            | sf << 31i32
            | op << 30i32
            | s.toInt32() << 29i32
            | shift << 22i32
            | imm12 << 10i32
            | rn.encodingSp() << 5i32
            | rd
    }

    pub fn atomic_op(
        size: Int32,
        v: Int32,
        a: Int32,
        r: Int32,
        rs: Register,
        o3: Int32,
        opc: Int32,
        rn: Register,
        rt: Register,
    ): Int32 {
        assert(fitsU2(size));
        assert(fitsBit(v));
        assert(fitsBit(a));
        assert(fitsBit(r));
        assert(rs.isGpr());
        assert(fitsBit(o3));
        assert(fitsU2(opc));
        assert(rn.isGpr());
        assert(rt.isGpr());

        size << 30i32
            | 0b111i32 << 27i32
            | v << 26i32
            | a << 23i32
            | r << 22i32
            | 1i32 << 21i32
            | rs.encoding() << 16i32
            | o3 << 15i32
            | opc << 12i32
            | rn.encoding() << 5i32
            | rt.encoding()
    }

    pub fn bitfield(
        sf: Int32,
        opc: Int32,
        n: Int32,
        immr: Int32,
        imms: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsU2(opc));
        assert(fitsBit(n));
        assert(fitsU6(immr));
        assert(fitsU6(imms));
        assert(rn.isGpr());
        assert(rd.isGpr());

        sf << 31i32
            | opc << 29i32
            | 0b100110i32 << 23i32
            | n << 22i32
            | (immr & 0x3Fi32) << 16i32
            | (imms & 0x3Fi32) << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn cmp_branch_imm(sf: Int32, op: Int32, rt: Register, imm19: Int32): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(op));
        assert(fitsI19(imm19));
        assert(rt.isGpr());
        let imm = imm19 & 0x7FFFFi32;

        sf << 31i32 | 0b011010i32 << 25i32 | op << 24i32 | imm << 5i32 | rt.encoding()
    }

    pub fn cond_branch_imm(cond: Cond, imm19: Int32): Int32 {
        assert(fitsI19(imm19));

        let imm = imm19 & 0x7FFFFi32;

        0b01010100i32 << 24i32 | imm << 5i32 | cond.encoding()
    }

    pub fn csel(
        sf: Int32,
        op: Int32,
        s: Int32,
        rm: Register,
        cond: Cond,
        op2: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(op));
        assert(fitsBit(s));
        assert(rm.isGprOrZero());
        assert(fitsBit(op2));
        assert(rn.isGprOrZero());
        assert(rd.isGpr());

        0b11010100i32 << 21i32
            | sf << 31i32
            | op << 30i32
            | s << 29i32
            | rm.encodingZero() << 16i32
            | cond.encoding() << 12i32
            | op2 << 10i32
            | rn.encodingZero() << 5i32
            | rd.encoding()
    }

    pub fn dataproc1(
        sf: Int32,
        s: Int32,
        opcode2: Int32,
        opcode: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(sf));
        assert(fitsU5(opcode2));
        assert(fitsU6(opcode));
        assert(rn.isGpr());
        assert(rd.isGpr());

        sf << 31i32
            | 1i32 << 30i32
            | s << 29i32
            | 0b11010110i32 << 21i32
            | opcode2 << 16i32
            | opcode << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn dataproc2(
        sf: Int32,
        s: Int32,
        rm: Register,
        opcode: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(s));
        assert(rm.isGpr());
        assert(fitsU6(opcode));
        assert(rn.isGpr());
        assert(rd.isGpr());

        sf << 31i32
            | s << 29i32
            | 0b11010110i32 << 21i32
            | rm.encoding() << 16i32
            | opcode << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn dataproc3(
        sf: Int32,
        op54: Int32,
        op31: Int32,
        rm: Register,
        o0: Int32,
        ra: Register,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsU2(op54));
        assert(fitsU3(op31));
        assert(rm.isGpr());
        assert(fitsBit(o0));
        assert(ra.isGprOrZero());
        assert(rn.isGpr());
        assert(rd.isGpr());

        sf << 31i32
            | op54 << 29i32
            | 0b11011i32 << 24i32
            | op31 << 21i32
            | rm.encoding() << 16i32
            | o0 << 15i32
            | ra.encodingZero() << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn exception(opc: Int32, imm16: Int32, op2: Int32, ll: Int32): Int32 {
        assert(fitsU3(opc));
        assert(fitsU16(imm16));
        assert(op2 == 0i32);
        assert(fitsU2(ll));

        0b11010100i32 << 24i32 | opc << 21i32 | imm16 << 5i32 | op2 << 2i32 | ll
    }

    pub fn fp_compare(
        m: Int32,
        s: Int32,
        ty: Int32,
        rm: NeonRegister,
        op: Int32,
        rn: NeonRegister,
        opcode2: Int32,
    ): Int32 {
        assert(m == 0i32);
        assert(s == 0i32);
        assert(fitsBit(ty));
        assert(fitsU2(op));
        assert(fitsU5(opcode2));

        m << 31i32
            | s << 29i32
            | 0b11110i32 << 24i32
            | ty << 22i32
            | 1i32 << 21i32
            | rm.encoding() << 16i32
            | op << 14i32
            | 0b1000i32 << 10i32
            | rn.encoding() << 5i32
            | opcode2
    }

    pub fn fp_dataproc1(
        m: Int32,
        s: Int32,
        ty: Int32,
        opcode: Int32,
        rn: NeonRegister,
        rd: NeonRegister,
    ): Int32 {
        assert(m == 0i32);
        assert(s == 0i32);
        assert(fitsU2(ty));
        assert(fitsU6(opcode));

        m << 31i32
            | s << 29i32
            | 0b11110i32 << 24i32
            | ty << 22i32
            | 1i32 << 21i32
            | opcode << 15i32
            | 0b10000i32 << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn fp_dataproc2(
        m: Int32,
        s: Int32,
        ty: Int32,
        rm: NeonRegister,
        opcode: Int32,
        rn: NeonRegister,
        rd: NeonRegister,
    ): Int32 {
        assert(m == 0i32);
        assert(s == 0i32);
        assert(fitsBit(ty));
        assert(fitsU4(opcode));

        m << 31i32
            | s << 29i32
            | 0b11110i32 << 24i32
            | ty << 22i32
            | 1i32 << 21i32
            | rm.encoding() << 16i32
            | opcode << 12i32
            | 0b10i32 << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn fp_int(
        sf: Int32,
        s: Int32,
        ty: Int32,
        rmode: Int32,
        opcode: Int32,
        rn: Int32,
        rd: Int32,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsBit(s));
        assert(fitsU2(ty));
        assert(fitsU2(rmode));
        assert(fitsU3(opcode));
        assert(fitsU5(rn));
        assert(fitsU5(rd));

        sf << 31i32
            | s << 29i32
            | 0b11110i32 << 24i32
            | ty << 22i32
            | 1i32 << 21i32
            | rmode << 19i32
            | opcode << 16i32
            | rn << 5i32
            | rd
    }

    pub fn ldst_exclusive(
        size: Int32,
        o2: Int32,
        l: Int32,
        o1: Int32,
        rs: Register,
        o0: Int32,
        rt2: Register,
        rn: Register,
        rt: Register,
    ): Int32 {
        assert(fitsU2(size));
        assert(fitsBit(o2));
        assert(fitsBit(l));
        assert(fitsBit(o1));
        assert(fitsBit(o0));
        assert(rs.isGprOrZero());
        assert(rt2.isGprOrZero());
        assert(rn.isGprOrSp());
        assert(rt.isGprOrZero());

        size << 30i32
            | 0b001000i32 << 24i32
            | o2 << 23i32
            | l << 22i32
            | o1 << 21i32
            | rs.encodingZero() << 16i32
            | o0 << 15i32
            | rt2.encodingZero() << 10i32
            | rn.encodingSp() << 5i32
            | rt.encodingZero()
    }

    pub fn ldst_pair(
        opc: Int32,
        v: Int32,
        l: Int32,
        imm7: Int32,
        rt2: Register,
        rn: Register,
        rt: Register,
    ): Int32 {
        assert(fitsU2(opc));
        assert(fitsBit(v));
        assert(fitsBit(l));
        assert(fitsI7(imm7));
        assert(rt2.isGpr());
        assert(rn.isGprOrSp());
        assert(rt.isGpr());

        opc << 30i32
            | 0b101i32 << 27i32
            | 1i32 << 24i32
            | l << 22i32
            | (imm7 & 0x7Fi32) << 15i32
            | rt2.encoding() << 10i32
            | rn.encodingSp() << 5i32
            | rt.encoding()
    }

    pub fn ldst_pair_post(
        opc: Int32,
        v: Int32,
        l: Int32,
        imm7: Int32,
        rt2: Register,
        rn: Register,
        rt: Register,
    ): Int32 {
        assert(fitsU2(opc));
        assert(fitsBit(v));
        assert(fitsBit(l));
        assert(fitsI7(imm7));
        assert(rt2.isGpr());
        assert(rn.isGprOrSp());
        assert(rt.isGpr());

        opc << 30i32
            | 0b101i32 << 27i32
            | v << 26i32
            | 0b001i32 << 23i32
            | l << 22i32
            | (imm7 & 0x7Fi32) << 15i32
            | rt2.encoding() << 10i32
            | rn.encodingSp() << 5i32
            | rt.encoding()
    }

    pub fn ldst_pair_pre(
        opc: Int32,
        v: Int32,
        l: Int32,
        imm7: Int32,
        rt2: Register,
        rn: Register,
        rt: Register,
    ): Int32 {
        assert(fitsU2(opc));
        assert(fitsBit(v));
        assert(fitsBit(l));
        assert(fitsI7(imm7));
        assert(rt2.isGpr());
        assert(rn.isGprOrSp());
        assert(rt.isGpr());

        opc << 30i32
            | 0b101i32 << 27i32
            | v << 26i32
            | 0b011i32 << 23i32
            | l << 22i32
            | (imm7 & 0x7Fi32) << 15i32
            | rt2.encoding() << 10i32
            | rn.encodingSp() << 5i32
            | rt.encoding()
    }

    pub fn logical_imm(
        sf: Int32,
        opc: Int32,
        n_immr_imms: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsU2(opc));
        assert(fitsU13(n_immr_imms));
        assert(rn.isGpr());
        assert(rd.isGpr());

        sf << 31i32
            | opc << 29i32
            | 0b100100i32 << 23i32
            | n_immr_imms << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn logical_shreg(
        sf: Int32,
        opc: Int32,
        shift: Shift,
        n: Int32,
        rm: Register,
        imm6: Int32,
        rn: Register,
        rd: Register,
    ): Int32 {
        assert(fitsBit(sf));
        assert(fitsU2(opc));
        assert(fitsBit(n));
        assert(rm.isGprOrZero());
        assert(fitsU5(imm6));
        assert(rn.isGprOrZero());
        assert(rd.isGpr());

        0b01010i32 << 24i32
            | sf << 31i32
            | opc << 29i32
            | shift.encoding() << 22i32
            | n << 21i32
            | rm.encodingZero() << 16i32
            | imm6 << 10i32
            | rn.encodingZero() << 5i32
            | rd.encoding()
    }

    pub fn move_wide_imm(sf: Int32, opc: Int32, hw: Int32, imm16: Int32, rd: Register): Int32 {
        assert(fitsBit(sf));
        assert(fitsU2(opc));
        assert(fitsU2(hw));
        if sf == 0i32 {
            assert(fitsBit(hw));
        }
        assert(fitsU16(imm16));
        assert(rd.isGpr());

        0b100101i32 << 23i32 | sf << 31i32 | opc << 29i32 | hw << 21i32 | imm16 << 5i32 | rd.encoding()
    }

    pub fn ldst_regimm(
        size: Int32,
        v: Int32,
        opc: Int32,
        imm12: Int32,
        rn: Register,
        rt: Int32,
    ): Int32 {
        assert(fitsU2(size));
        assert(fitsBit(v));
        assert(fitsU2(opc));
        assert(fitsU12(imm12));
        assert(rn.isGprOrSp());
        assert(fitsU5(rt));

        0b111001i32 << 24i32
            | size << 30i32
            | v << 26i32
            | opc << 22i32
            | imm12 << 10i32
            | rn.encodingSp() << 5i32
            | rt
    }

    pub fn ldst_regoffset(
        size: Int32,
        v: Int32,
        opc: Int32,
        rm: Register,
        option: Extend,
        s: Int32,
        rn: Register,
        rt: Int32,
    ): Int32 {
        assert(fitsU2(size));
        assert(fitsBit(v));
        assert(fitsU2(opc));
        assert(rm.isGprOrZero());
        assert(fitsBit(s));
        assert(rn.isGprOrSp());
        assert(fitsU5(rt));

        0b111i32 << 27i32
            | 1i32 << 21i32
            | 0b10i32 << 10i32
            | size << 30i32
            | v << 26i32
            | opc << 22i32
            | rm.encodingZero() << 16i32
            | option.ldst_encoding() << 13i32
            | s << 12i32
            | rn.encodingSp() << 5i32
            | rt
    }

    pub fn ldst_reg_unscaledimm(
        size: Int32,
        v: Int32,
        opc: Int32,
        imm9: Int32,
        rn: Register,
        rt: Int32,
    ): Int32 {
        assert(fitsU2(size));
        assert(fitsBit(v));
        assert(fitsU2(opc));
        assert(fitsI9(imm9));
        assert(rn.isGprOrSp());
        assert(fitsU5(rt));

        let imm = imm9 & 0x1FFi32;

        size << 30i32 | 0b111i32 << 27i32 | v << 26i32 | opc << 22i32 | imm << 12i32 | rn.encodingSp() << 5i32 | rt
    }

    pub fn simd_across_lanes(
        q: Int32,
        u: Int32,
        size: Int32,
        opcode: Int32,
        rn: NeonRegister,
        rd: NeonRegister,
    ): Int32 {
        assert(fitsBit(q));
        assert(fitsBit(u));
        assert(fitsU2(size));
        assert(fitsU5(opcode));

        q << 30i32
            | u << 29i32
            | 0b01110i32 << 24i32
            | size << 22i32
            | 0b11000i32 << 17i32
            | opcode << 12i32
            | 0b10i32 << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn pcrel(op: Int32, imm: Int32, rd: Register): Int32 {
        assert(fitsI21(imm));
        assert(fitsBit(op));
        assert(rd.isGpr());

        let immlo = imm & 3i32;
        let immhi = (imm >> 2i32) & 0x7FFFFi32;

        1i32 << 28i32 | op << 31i32 | immlo << 29i32 | immhi << 5i32 | rd.encoding()
    }

    pub fn simd_2regs_misc(
        q: Int32,
        u: Int32,
        size: Int32,
        opcode: Int32,
        rn: NeonRegister,
        rd: NeonRegister,
    ): Int32 {
        assert(fitsBit(q));
        assert(fitsBit(u));
        assert(fitsU2(size));
        assert(fitsU5(opcode));

        q << 30i32
            | u << 29i32
            | 0b01110i32 << 24i32
            | size << 22i32
            | 0b10000i32 << 17i32
            | opcode << 12i32
            | 0b10i32 << 10i32
            | rn.encoding() << 5i32
            | rd.encoding()
    }

    pub fn system(imm: Int32): Int32 {
        assert(fitsU7(imm));
        0xD503201Fi32 | imm << 5i32
    }

    pub fn uncond_branch_imm(op: Int32, imm26: Int32): Int32 {
        assert(fitsBit(op));
        assert(fitsI26(imm26));

        0b101i32 << 26i32 | op << 31i32 | (imm26 & 0x3FFFFFFi32)
    }

    pub fn uncond_branch_reg(opc: Int32, op2: Int32, op3: Int32, rn: Register, op4: Int32): Int32 {
        assert(fitsU4(opc));
        assert(fitsU5(op2));
        assert(fitsU6(op3));
        assert(fitsU5(op4));

        0b1101011i32 << 25i32 | opc << 21i32 | op2 << 16i32 | op3 << 10i32 | rn.encoding() << 5i32 | op4
    }

    fn fitsBit(value: Int32): Bool {
        value >= 0i32 && value < 2i32
    }

    fn fitsI7(value: Int32): Bool {
        fitsSigned(value, 7i32)
    }

    fn fitsI9(value: Int32): Bool {
        fitsSigned(value, 9i32)
    }

    fn fitsI19(value: Int32): Bool {
        fitsSigned(value, 19i32)
    }

    fn fitsI21(value: Int32): Bool {
        fitsSigned(value, 21i32)
    }

    fn fitsI26(value: Int32): Bool {
        fitsSigned(value, 26i32)
    }

    fn fitsSigned(value: Int32, bits: Int32): Bool {
        assert(bits > 0i32 && bits < 32i32);
        -(1i32 << (bits - 1i32)) <= value && value < (1i32 << (bits - 1i32))
    }

    fn fitsU2(value: Int32): Bool {
        fitsUnsigned(value, 2i32)
    }

    fn fitsU3(value: Int32): Bool {
        fitsUnsigned(value, 3i32)
    }

    fn fitsU4(value: Int32): Bool {
        fitsUnsigned(value, 4i32)
    }

    fn fitsU5(value: Int32): Bool {
        fitsUnsigned(value, 5i32)
    }

    fn fitsU6(value: Int32): Bool {
        fitsUnsigned(value, 6i32)
    }

    fn fitsU7(value: Int32): Bool {
        fitsUnsigned(value, 7i32)
    }

    fn fitsU12(value: Int32): Bool {
        fitsUnsigned(value, 12i32)
    }

    fn fitsU13(value: Int32): Bool {
        fitsUnsigned(value, 13i32)
    }

    fn fitsU16(value: Int32): Bool {
        fitsUnsigned(value, 16i32)
    }

    fn fitsUnsigned(value: Int32, bits: Int32): Bool {
        assert(bits > 0i32 && bits < 32i32);
        value >= 0i32 && value < (1i32 << bits)
    }
}

mod tests {
    use super::{assertAsm32, AssemblerArm64, Cond, Extend, Shift};
    use super::{REG_ZERO, REG_SP};
    use super::{
        R0, R1, R2, R3, R4, R5, R6, R8, R9, R10,
        R17, R27, R28, R29, R30
    };

    @Test
    fn test_asm_ret() {
        let asm = AssemblerArm64::new();
        asm.ret();
        asm.ret_r(R0);
        asm.ret_r(R10);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xd65f03c0i32,
            0xd65f0000i32,
            0xd65f0140i32
        );
    }

    @Test
    fn test_br_blr() {
        let asm = AssemblerArm64::new();
        asm.br(R0);
        asm.br(R30);
        asm.blr(R0);
        asm.blr(R30);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xd61f0000i32,
            0xd61f03c0i32,
            0xd63f0000i32,
            0xd63f03c0i32,
        );
    }

    @Test
    fn test_b_backward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createAndBindLabel();
        asm.nop();
        asm.b(target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xd503201fi32,
            0x17ffffffi32,
        );
    }

    @Test
    fn test_b_forward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createLabel();
        asm.b(target);
        asm.nop();
        asm.buffer.bindLabel(target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0x14000002i32,
            0xd503201fi32,
        );
    }

    @Test
    fn test_bl_backward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createAndBindLabel();
        asm.nop();
        asm.bl(target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xd503201fi32,
            0x97ffffffi32,
        );
    }

    @Test
    fn test_bl_forward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createLabel();
        asm.bl(target);
        asm.nop();
        asm.buffer.bindLabel(target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0x94000002i32,
            0xd503201fi32,
        );
    }

    @Test
    fn test_bc_backward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createAndBindLabel();
        asm.nop();
        asm.bc(Cond::EQ, target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xd503201fi32,
            0x54ffffe0i32,
        );
    }

    @Test
    fn test_bc_forward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createLabel();
        asm.bc(Cond::NE, target);
        asm.nop();
        asm.buffer.bindLabel(target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0x54000061i32,
            0xd503201fi32,
            0xd503201fi32,
        );
    }

    @Test
    fn test_cbz_backward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createAndBindLabel();
        asm.nop();
        asm.cbz(R17, target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xd503201fi32,
            0xb4fffff1i32,
        );
    }

    @Test
    fn test_cbz_forward() {
        let asm = AssemblerArm64::new();
        let target = asm.buffer.createLabel();
        asm.cbz(R17, target);
        asm.nop();
        asm.buffer.bindLabel(target);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            0xb4000071i32,
            0xd503201fi32,
            0xd503201fi32,
        );
    }

    @Test
    fn test_nop() {
        let asm = AssemblerArm64::new();
        asm.nop();
        let buffer = asm.finalizeTesting();

        assertAsm32(buffer, 0xd503201fi32);
    }

    @Test
    fn test_add_extreg() {
        let asm = AssemblerArm64::new();
        asm.add_ext(REG_SP, R1, R2, Extend::UXTX, 1i32);
        asm.add_ext(R1, REG_SP, R2, Extend::UXTX, 2i32);
        asm.add_ext_w(REG_SP, R1, R2, Extend::UXTW, 1i32);
        asm.add_ext_w(R1, REG_SP, R2, Extend::UXTW, 2i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // add sp, x1, x2, uxtx #1
            0x8b22643fi32,
            // add x1, sp, x2, uxtx #2
            0x8b226be1i32,
            // add wsp, w1, w2, uxtw #1
            0x0b22443fi32,
            // add w1, wsp, w2, uxtw #2
            0x0b224be1i32,
        );
    }

    @Test
    fn test_add_imm() {
        let asm = AssemblerArm64::new();
        asm.add_imm(REG_SP, REG_SP, 0i32);
        asm.add_imm(R0, R1, 0i32);
        asm.add_imm(REG_SP, REG_SP, 1i32);
        asm.add_imm(R2, R3, 1i32);
        asm.add_imm(REG_SP, REG_SP, 4096i32);
        asm.add_imm(R0, R1, 4096i32);
        asm.add_imm(REG_SP, REG_SP, 8192i32);
        asm.add_imm(R2, R3, 8192i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // mov sp, sp
            0x910003ffi32,
            // add x0, x1, #0x0
            0x91000020i32,
            // add sp, sp, #0x1
            0x910007ffi32,
            // add x2, x3, #0x1
            0x91000462i32,
            // add sp, sp, #0x1, lsl #12
            0x914007ffi32,
            // add x0, x1, #0x1, lsl #12
            0x91400420i32,
            // add sp, sp, #0x2, lsl #12
            0x91400bffi32,
            // add x2, x3, #0x2, lsl #12
            0x91400862i32,
        );
    }

    @Test
    fn test_adds_imm() {
        let asm = AssemblerArm64::new();
        asm.adds_imm(REG_ZERO, REG_SP, 0i32);
        asm.adds_imm(R0, R1, 0i32);
        asm.adds_imm(REG_ZERO, REG_SP, 1i32);
        asm.adds_imm(R2, R3, 1i32);
        asm.adds_imm(REG_ZERO, REG_SP, 4096i32);
        asm.adds_imm(R0, R1, 4096i32);
        asm.adds_imm(REG_ZERO, REG_SP, 8192i32);
        asm.adds_imm(R2, R3, 8192i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // cmn sp, #0x0
            0xb10003ffi32,
            // adds x0, x1, #0x0
            0xb1000020i32,
            // cmn sp, #0x1
            0xb10007ffi32,
            // adds x2, x3, #0x1
            0xb1000462i32,
            // cmn sp, #0x1, lsl #12
            0xb14007ffi32,
            // adds x0, x1, #0x1, lsl #12
            0xb1400420i32,
            // cmn sp, #0x2, lsl #12
            0xb1400bffi32,
            // adds x2, x3, #0x2, lsl #12
            0xb1400862i32,
        );
    }

    @Test
    fn test_add_imm_w() {
        let asm = AssemblerArm64::new();
        asm.add_imm_w(REG_SP, REG_SP, 0i32);
        asm.add_imm_w(R0, R1, 0i32);
        asm.add_imm_w(REG_SP, REG_SP, 1i32);
        asm.add_imm_w(R2, R3, 1i32);
        asm.add_imm_w(REG_SP, REG_SP, 4096i32);
        asm.add_imm_w(R0, R1, 4096i32);
        asm.add_imm_w(REG_SP, REG_SP, 8192i32);
        asm.add_imm_w(R2, R3, 8192i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // mov wsp, wsp
            0x110003ffi32,
            // add w0, w1, #0x0
            0x11000020i32,
            // add wsp, wsp, #0x1
            0x110007ffi32,
            // add w2, w3, #0x1
            0x11000462i32,
            // add wsp, wsp, #0x1, lsl #12
            0x114007ffi32,
            // add w0, w1, #0x1, lsl #12
            0x11400420i32,
            // add wsp, wsp, #0x2, lsl #12
            0x11400bffi32,
            // add w2, w3, #0x2, lsl #12
            0x11400862i32,
        );
    }

    @Test
    fn test_adds_imm_w() {
        let asm = AssemblerArm64::new();
        asm.adds_imm_w(REG_ZERO, REG_SP, 0i32);
        asm.adds_imm_w(R0, R1, 0i32);
        asm.adds_imm_w(REG_ZERO, REG_SP, 1i32);
        asm.adds_imm_w(R2, R3, 1i32);
        asm.adds_imm_w(REG_ZERO, REG_SP, 4096i32);
        asm.adds_imm_w(R0, R1, 4096i32);
        asm.adds_imm_w(REG_ZERO, REG_SP, 8192i32);
        asm.adds_imm_w(R2, R3, 8192i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // cmn wsp, #0x0
            0x310003ffi32,
            // adds w0, w1, #0x0
            0x31000020i32,
            // cmn wsp, #0x1
            0x310007ffi32,
            // adds w2, w3, #0x1
            0x31000462i32,
            // cmn wsp, #0x1, lsl #12
            0x314007ffi32,
            // adds w0, w1, #0x1, lsl #12
            0x31400420i32,
            // cmn wsp, #0x2, lsl #12
            0x31400bffi32,
            // adds w2, w3, #0x2, lsl #12
            0x31400862i32,
        );
    }

    @Test
    fn test_adds() {
        let asm = AssemblerArm64::new();
        asm.adds(R1, R2, R3);
        asm.adds_w(R4, R5, R6);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // adds x1, x2, x3
            0xab030041i32,
            // adds w4, w5, w6
            0x2b0600a4i32,
        );
    }

    @Test
    fn test_adds_sh() {
        let asm = AssemblerArm64::new();
        asm.adds_sh(R1, R2, R3, Shift::ASR, 2i32);
        asm.adds_sh_w(R4, R5, R6, Shift::ASR, 2i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // adds x1, x2, x3, asr #2
            0xab830841i32,
            // adds w4, w5, w6, asr #2
            0x2b8608a4i32,
        );
    }

    @Test
    fn test_subs() {
        let asm = AssemblerArm64::new();
        asm.subs(R1, R2, R3);
        asm.subs_w(R4, R5, R6);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // subs x1, x2, x3
            0xeb030041i32,
            // subs w4, w5, w6
            0x6b0600a4i32,
        );
    }

    @Test
    fn test_subs_sh() {
        let asm = AssemblerArm64::new();
        asm.subs_sh(R1, R2, R3, Shift::ASR, 2i32);
        asm.subs_sh_w(R4, R5, R6, Shift::ASR, 2i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // subs x1, x2, x3, asr #2
            0xeb830841i32,
            // subs w4, w5, w6, asr #2
            0x6b8608a4i32,
        );
    }

    @Test
    fn test_adr() {
        let asm = AssemblerArm64::new();
        asm.adr_imm(R0, -8i32);
        asm.adr_imm(R30, -4i32);
        asm.adr_imm(R29, 0i32);
        asm.adr_imm(R28, 4i32);
        asm.adr_imm(R27, 8i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // adr x0, -8
            0x10ffffc0i32,
            // adr x30, -4
            0x10fffffei32,
            // adr x29, 0
            0x1000001di32,
            // adr x28, 4
            0x1000003ci32,
            // adr x27, 8
            0x1000005bi32,
        );
    }

    @Test
    fn test_asrv() {
        let asm = AssemblerArm64::new();
        asm.asrv(R0, R1, R2);
        asm.asrv_w(R0, R1, R2);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // asr x0, x1, x2
            0x9ac22820i32,
            // asr w0, w1, w2
            0x1ac22820i32,
        );
    }

    @Test
    fn test_bfm() {
        let asm = AssemblerArm64::new();
        asm.bfm(R0, R1, 1i32, 2i32);
        asm.bfm_w(R2, R3, 3i32, 4i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // bfxil x0, x1, #1, #2
            0xb3410820i32,
            // bfxil w2, w3, #3, #2
            0x33031062i32,
        );
    }

    @Test
    fn test_bic_sh() {
        let asm = AssemblerArm64::new();
        asm.bic_sh(R0, R1, R2, Shift::LSR, 2i32);
        asm.bic_sh_w(R2, R3, R4, Shift::LSL, 2i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // bic x0, x1, x2, lsr #2
            0x8a620820i32,
            // bic w2, w3, w4, lsl #2
            0x0a240862i32,
        );
    }

    @Test
    fn test_bics_sh() {
        let asm = AssemblerArm64::new();
        asm.bics_sh(R0, R1, R2, Shift::LSR, 2i32);
        asm.bics_sh_w(R2, R3, R4, Shift::LSL, 2i32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // bics x0, x1, x2, lsr #2
            0xea620820i32,
            // bics w2, w3, w4, lsl #2
            0x6a240862i32,
        );
    }

    @Test
    fn test_brk() {
        let asm = AssemblerArm64::new();
        asm.brk(0i32);
        asm.brk(0xFFFFi32);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // brk #0
            0xd4200000i32,
            // brk #0xffff
            0xd43fffe0i32,
        );
    }

    @Test
    fn test_cas() {
        let asm = AssemblerArm64::new();
        asm.cas(R0, R1, R2);
        asm.cas_w(R0, R1, R2);
        asm.casa(R0, R1, R2);
        asm.casa_w(R0, R1, R2);
        asm.casl(R0, R1, R2);
        asm.casl_w(R0, R1, R2);
        asm.casal(R0, R1, R2);
        asm.casal_w(R0, R1, R2);
        let buffer = asm.finalizeTesting();

        assertAsm32(
            buffer,
            // cas x0, x1, [x2]
            0xc8a07c41i32,
            // cas w0, w1, [x2]
            0x88a07c41i32,
            // casa x0, x1, [x2]
            0xc8e07c41i32,
            // casa w0, w1, [x2]
            0x88e07c41i32,
            // casl x0, x1, [x2]
            0xc8a0fc41i32,
            // casl w0, w1, [x2]
            0x88a0fc41i32,
            // casal x0, x1, [x2]
            0xc8e0fc41i32,
            // casal w0, w1, [x2]
            0x88e0fc41i32,
        );
    }
}
