use package::assembler::AssemblerBuffer;
use package::assembler::Label;
use package::assembler::MachineCode;
use package::assembler::Register;

pub let RAX: Register = Register(0i32);
pub let RCX: Register = Register(1i32);
pub let RDX: Register = Register(2i32);
pub let RBX: Register = Register(3i32);
pub let RSP: Register = Register(4i32);
pub let RBP: Register = Register(5i32);
pub let RSI: Register = Register(6i32);
pub let RDI: Register = Register(7i32);

pub let R8: Register = Register(8i32);
pub let R9: Register = Register(9i32);
pub let R10: Register = Register(10i32);
pub let R11: Register = Register(11i32);
pub let R12: Register = Register(12i32);
pub let R13: Register = Register(13i32);
pub let R14: Register = Register(14i32);
pub let R15: Register = Register(15i32);

pub let XMM0: XmmRegister = XmmRegister(0i32);
pub let XMM1: XmmRegister = XmmRegister(1i32);
pub let XMM2: XmmRegister = XmmRegister(2i32);
pub let XMM3: XmmRegister = XmmRegister(3i32);
pub let XMM4: XmmRegister = XmmRegister(4i32);
pub let XMM5: XmmRegister = XmmRegister(5i32);
pub let XMM6: XmmRegister = XmmRegister(6i32);
pub let XMM7: XmmRegister = XmmRegister(7i32);

pub let XMM8: XmmRegister = XmmRegister(8i32);
pub let XMM9: XmmRegister = XmmRegister(9i32);
pub let XMM10: XmmRegister = XmmRegister(10i32);
pub let XMM11: XmmRegister = XmmRegister(11i32);
pub let XMM12: XmmRegister = XmmRegister(12i32);
pub let XMM13: XmmRegister = XmmRegister(13i32);
pub let XMM14: XmmRegister = XmmRegister(14i32);
pub let XMM15: XmmRegister = XmmRegister(15i32);

struct XmmRegister(value: Int32)

impl XmmRegister {
    fn lowBits(): Int32 { self.value & 0b111i32 }
    fn needsRexBit(): Bool { self.value > 7i32 }
}

enum JumpDistance {
    Near,
    Far,
}

pub class AssemblerX64 {
    buffer: AssemblerBuffer,
    jumps: Vec[(Int64, Label, JumpDistance)],
}

impl AssemblerX64 {
    static pub fn new(): AssemblerX64 {
        AssemblerX64(
            AssemblerBuffer::new(),
            Vec[(Int64, Label, JumpDistance)]::new()
        )
    }

    fn createLabel(): Label {
        self.buffer.createLabel()
    }

    fn bindLabel(lbl: Label) {
        self.buffer.bindLabel(lbl);
    }

    fn createAndBindLabel(): Label {
        self.buffer.createAndBindLabel()
    }

    fn addl_ri(dest: Register, imm: Immediate) {
        self.emitAlu32Imm(dest, imm, 0b000i32, 0x05u8);
    }

    fn addl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x01u8);
        self.emitModRmReg(src, dest);
    }

    fn addq_ri(reg: Register, imm: Immediate) {
        self.emitAlu64Imm(reg, imm, 0b000i32, 0x05u8);
    }

    fn addq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x01u8);
        self.emitModRmReg(src, dest);
    }

    fn addss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x58u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn addsd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x58u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn andl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x21u8);
        self.emitModRmReg(src, dest);
    }

    fn andps_ra(dest: XmmRegister, src: Address) {
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0fu8);
        self.emitByte(0x54u8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn andq_ri(lhs: Register, imm: Immediate) {
        self.emitAlu64Imm(lhs, imm, 0b100i32, 0x25u8);
    }

    fn andq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x21u8);
        self.emitModRmReg(src, dest);
    }

    fn call_r(src: Register) {
        self.emitRex32RmFieldOptional(src);
        self.emitByte(0xFFu8);
        self.emitModRmOpcode(0b010i32, src);
    }

    fn cdq() {
        self.emitByte(0x99u8);
    }

    fn cmovl(condition: Condition, dest: Register, src: Register) {
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte((0x40i32 + condition.toInt32()).toUInt8());
        self.emitModRmReg(dest, src);
    }

    fn cmovq(condition: Condition, dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte((0x40i32 + condition.toInt32()).toUInt8());
        self.emitModRmReg(dest, src);
    }

    fn cmpb_ai(lhs: Address, rhs: Immediate) {
        assert(rhs.isInt8() || rhs.isUInt8());
        self.emitRex32AddressOptional(lhs);
        self.emitByte(0x80u8);
        self.emitAddress(0b111i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn cmpb_ar(lhs: Address, rhs: Register) {
        self.emitRex32ModRmAddressByteOptional(rhs, lhs);
        self.emitByte(0x38u8);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn cmpl_ai(lhs: Address, imm: Immediate) {
        assert(imm.isInt32() || imm.isUInt32());
        self.emitRex32AddressOptional(lhs);

        if imm.isInt8() {
            self.emitByte(0x83u8);
            self.emitAddress(0b111i32, lhs);
            self.emitByte(imm.toUInt8());
        } else {
            self.emitByte(0x81u8);
            self.emitAddress(0b111i32, lhs);
            self.emitInt32(imm.toInt32());
        }
    }

    fn cmpl_ar(lhs: Address, rhs: Register) {
        self.emitRex32ModRmAddressOptional(rhs, lhs);
        self.emitByte(0x39u8);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn cmpl_ri(lhs: Register, imm: Immediate) {
        self.emitAlu32Imm(lhs, imm, 0b111i32, 0x3Du8);
    }

    fn cmpl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x39u8);
        self.emitModRmReg(src, dest);
    }

    fn cmpq_ai(lhs: Address, imm: Immediate) {
        assert(imm.isInt32());
        self.emitRex64Address(lhs);

        if imm.isInt8() {
            self.emitByte(0x83u8);
            self.emitAddress(0b111i32, lhs);
            self.emitByte(imm.toUInt8());
        } else {
            self.emitByte(0x81u8);
            self.emitAddress(0b111i32, lhs);
            self.emitInt32(imm.toInt32());
        }
    }

    fn cmpq_ar(lhs: Address, rhs: Register) {
        self.emitRex64ModRmAddress(rhs, lhs);
        self.emitByte(0x39u8);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn cmpq_ri(lhs: Register, imm: Immediate) {
        self.emitAlu64Imm(lhs, imm, 0b111i32, 0x3Du8);
    }

    fn cmpq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x39u8);
        self.emitModRmReg(src, dest);
    }

    pub fn cmpxchgl_ar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressOptional(src, dest);
        self.emitByte(0x0fu8);
        self.emitByte(0xb1u8);
        self.emitAddress(src.lowBits(), dest);
    }

    pub fn cmpxchgq_ar(dest: Address, src: Register) {
        self.emitRex64ModRmAddress(src, dest);
        self.emitByte(0x0fu8);
        self.emitByte(0xb1u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn cqo() {
        self.emitRex64();
        self.emitByte(0x99u8);
    }

    fn cvtsd2ss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x5Au8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn cvtsi2sdd_rr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF2u8);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Au8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvtsi2sdq_rr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF2u8);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Au8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvtsi2ssd_rr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Au8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvtsi2ssq_rr(dest: XmmRegister, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Au8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvtss2sd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x5Au8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn cvttsd2sid_rr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Cu8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvttsd2siq_rr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Cu8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvttss2sid_rr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Cu8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn cvttss2siq_rr(dest: Register, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Cu8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn divss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x5Eu8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn divsd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x5Eu8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn idivl_r(src: Register) {
        self.emitRex32RmFieldOptional(src);
        self.emitByte(0xF7u8);
        self.emitModRmOpcode(0b111i32, src);
    }

    fn idivq_r(src: Register) {
        self.emitRex64RmField(src);
        self.emitByte(0xF7u8);
        self.emitModRmOpcode(0b111i32, src);
    }

    fn imull_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xAFu8);
        self.emitModRmReg(dest, src);
    }

    fn imulq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xAFu8);
        self.emitModRmReg(dest, src);
    }

    fn int3() {
        self.emitByte(0xCCu8);
    }

    fn jcc(condition: Condition, dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2i64);
            assert(distance <= -2i64);

            if distance >= -128i64 {
                self.emitByte((0x70i32 + condition.toInt32()).toUInt8());
                self.emitByte(distance.toUInt8());
            } else {
                let distance = dest.offset - (self.size() + 6i64);
                assert(distance.toInt32().toInt64() == distance);
                self.emitByte(0x0Fu8);
                self.emitByte((0x80i32 + condition.toInt32()).toUInt8());
                self.emitInt32(distance.toInt32());
            }
        } else {
            // forward jump - conservatively assume far jump
            self.emitByte(0x0Fu8);
            self.emitByte((0x80i32 + condition.toInt32()).toUInt8());
            self.emitJump(dest, JumpDistance::Far);
            self.emitInt32(0i32);
        }
    }

    fn jcc_near(condition: Condition, dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2i64);
            assert(-128i64 <= distance && distance <= -2i64);
            self.emitByte((0x70i32 + condition.toInt32()).toUInt8());
            self.emitByte(distance.toUInt8());
        } else {
            // forward jump
            self.emitByte((0x70i32 + condition.toInt32()).toUInt8());
            self.emitJump(dest, JumpDistance::Near);
            self.emitByte(0u8);
        }
    }

    fn jmp(dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2i64);
            assert(distance <= -2i64);

            if distance >= -128i64 {
                self.emitByte(0xEBu8);
                self.emitByte(distance.toUInt8());
            } else {
                let distance = dest.offset - (self.size() + 5i64);
                assert(distance.toInt32().toInt64() == distance);
                self.emitByte(0xE9u8);
                self.emitInt32(distance.toInt32());
            }
        } else {
            // forward jump - conservatively assume far jump
            self.emitByte(0xE9u8);
            self.emitJump(dest, JumpDistance::Far);
            self.emitInt32(0i32);
        }
    }

    fn jmp_near(dest: Label) {
        if dest.isBound() {
            // backwards jump
            // rip = end of current instruction = pc + 2
            let distance = dest.offset - (self.size() + 2i64);
            assert(-128i64 <= distance && distance <= -2i64);
            self.emitByte(0xEBu8);
            self.emitByte(distance.toUInt8());
        } else {
            // forward jump
            self.emitByte(0xEBu8);
            self.emitJump(dest, JumpDistance::Near);
            self.emitByte(0u8);
        }
    }

    fn jmp_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xFFu8);
        self.emitModRmOpcode(0b100i32, reg);
    }

    fn lea(dest: Register, src: Address) {
        self.emitRex64ModRmAddress(dest, src);
        self.emitByte(0x8Du8);
        self.emitAddress(dest.lowBits(), src);
    }

    pub fn lock_cmpxchgq_ar(dest: Address, src: Register) {
        self.emitLockPrefix();
        self.cmpxchgq_ar(dest, src);
    }

    pub fn lock_cmpxchgl_ar(dest: Address, src: Register) {
        self.emitLockPrefix();
        self.cmpxchgl_ar(dest, src);
    }

    pub fn lock_xaddq_ar(dest: Address, src: Register) {
        self.emitLockPrefix();
        self.xaddq_ar(dest, src);
    }

    pub fn lock_xaddl_ar(dest: Address, src: Register) {
        self.emitLockPrefix();
        self.xaddl_ar(dest, src);
    }

    fn lzcntl_rr(dest: Register, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBDu8);
        self.emitModRmReg(dest, src);
    }

    fn lzcntq_rr(dest: Register, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBDu8);
        self.emitModRmReg(dest, src);
    }

    fn movb_ai(dest: Address, src: Immediate) {
        assert(src.isInt8() || src.isUInt8());
        self.emitRex32AddressOptional(dest);
        self.emitByte(0xC6u8);
        self.emitAddress(0b000i32, dest);
        self.emitByte(src.toUInt8());
    }

    fn movb_ar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressByteOptional(src, dest);
        self.emitByte(0x88u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movb_ra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressByteOptional(dest, src);
        self.emitByte(0x8au8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movd_rx(dest: Register, src: XmmRegister) {
        self.emitByte(0x66u8);
        self.emitRexOptional(false, src.needsRexBit(), false, dest.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x7Eu8);
        self.emitModRm(0b11i32, src.lowBits(), dest.lowBits());
    }

    fn movd_xr(dest: XmmRegister, src: Register) {
        self.emitByte(0x66u8);
        self.emitRexOptional(false, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x6Eu8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn movl_ai(dest: Address, imm: Immediate) {
        assert(imm.isInt32() || imm.isUInt32());
        self.emitRex32AddressOptional(dest);
        self.emitByte(0xC7u8);
        self.emitAddress(0b000i32, dest);
        self.emitInt32(imm.toInt32());
    }

    fn movl_ar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressOptional(src, dest);
        self.emitByte(0x89u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movl_ra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressOptional(dest, src);
        self.emitByte(0x8Bu8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movl_ri(dest: Register, imm: Immediate) {
        assert(imm.isInt32());
        self.emitRex32RmFieldOptional(dest);
        self.emitByte((0xB8i32 + dest.lowBits()).toUInt8());
        self.emitInt32(imm.toInt32());
    }

    fn movl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x89u8);
        self.emitModRmReg(src, dest);
    }

    fn movq_ai(dest: Address, imm: Immediate) {
        assert(imm.isInt32());
        self.emitRex64Address(dest);
        self.emitByte(0xC7u8);
        self.emitAddress(0b000i32, dest);
        self.emitInt32(imm.toInt32());
    }

    fn movq_ar(dest: Address, src: Register) {
        self.emitRex64ModRmAddress(src, dest);
        self.emitByte(0x89u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movq_ra(dest: Register, src: Address) {
        self.emitRex64ModRmAddress(dest, src);
        self.emitByte(0x8Bu8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movq_ri(dest: Register, imm: Immediate) {
        if imm.isInt32() {
            self.emitRex64RmField(dest);
            self.emitByte(0xC7u8);
            self.emitModRmOpcode(0i32, dest);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitRex64RmField(dest);
            self.emitByte((0xB8i32 + dest.lowBits()).toUInt8());
            self.emitInt64(imm.toInt64());
        }
    }

    pub fn movq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x89u8);
        self.emitModRmReg(src, dest);
    }

    fn movq_rx(dest: Register, src: XmmRegister) {
        self.emitByte(0x66u8);
        self.emitRexOptional(true, src.needsRexBit(), false, dest.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x7Eu8);
        self.emitModRm(0b11i32, src.lowBits(), dest.lowBits());
    }

    fn movq_xr(dest: XmmRegister, src: Register) {
        self.emitByte(0x66u8);
        self.emitRexOptional(true, dest.needsRexBit(), false, src.needsRexBit());
        self.emitByte(0x0Fu8);
        self.emitByte(0x6Eu8);
        self.emitModRm(0b11i32, dest.lowBits(), src.lowBits());
    }

    fn movsd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x10u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn movsd_ra(dest: XmmRegister, src: Address) {
        self.emitByte(0xF2u8);
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x10u8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsd_ar(dest: Address, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseAddressOptional(src, dest);
        self.emitByte(0x0Fu8);
        self.emitByte(0x11u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movss_ar(dest: Address, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseAddressOptional(src, dest);
        self.emitByte(0x0Fu8);
        self.emitByte(0x11u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn movss_ra(dest: XmmRegister, src: Address) {
        self.emitByte(0xF3u8);
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x10u8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x10u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn movsxbl_ra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBEu8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsxbl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmByteOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBEu8);
        self.emitModRmReg(dest, src);
    }

    fn movsxbq_ra(dest: Register, src: Address) {
        self.emitRex64ModRmAddress(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBEu8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movsxbq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBEu8);
        self.emitModRmReg(dest, src);
    }

    fn movsxlq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x63u8);
        self.emitModRmReg(dest, src);
    }

    fn movzxb_ra(dest: Register, src: Address) {
        self.emitRex32ModRmAddressOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xB6u8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn movzxb_rr(dest: Register, src: Register) {
        self.emitRex32ModRmByteOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xB6u8);
        self.emitModRmReg(dest, src);
    }

    fn mulss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x59u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn mulsd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x59u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn negl_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xF7u8);
        self.emitModRmOpcode(0b011i32, reg);
    }

    fn negq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xF7u8);
        self.emitModRmOpcode(0b011i32, reg);
    }

    fn nop() {
        self.emitByte(0x90u8);
    }

    fn notl_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xF7u8);
        self.emitModRmOpcode(0b010i32, reg);
    }

    fn notq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xF7u8);
        self.emitModRmOpcode(0b010i32, reg);
    }

    fn orl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x09u8);
        self.emitModRmReg(src, dest);
    }

    fn orq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x09u8);
        self.emitModRmReg(src, dest);
    }

    pub fn pushq_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte((0x50i32 + reg.lowBits()).toUInt8());
    }

    fn popcntl_rr(dest: Register, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xB8u8);
        self.emitModRmReg(dest, src);
    }

    fn popcntq_rr(dest: Register, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xB8u8);
        self.emitModRmReg(dest, src);
    }

    pub fn popq_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte((0x58i32 + reg.lowBits()).toUInt8());
    }

    fn pxor_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0x66u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xEFu8);
        self.emitModRmSseRegisters(dest, src);
    }

    pub fn retq() {
        self.emitByte(0xC3u8);
    }

    fn roll_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b000i32, reg);
    }

    fn rolq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b000i32, reg);
    }

    pub fn roundss_ri(dest: XmmRegister, src: XmmRegister, mode: UInt8) {
        self.emitByte(0x66u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0fu8);
        self.emitByte(0x3au8);
        self.emitByte(0x0au8);
        self.emitModRmSseRegisters(dest, src);
        self.emitByte(mode);
    }

    pub fn roundsd_ri(dest: XmmRegister, src: XmmRegister, mode: UInt8) {
        self.emitByte(0x66u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0fu8);
        self.emitByte(0x3au8);
        self.emitByte(0x0bu8);
        self.emitModRmSseRegisters(dest, src);
        self.emitByte(mode);
    }

    fn rorl_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b001i32, reg);
    }

    fn rorq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b001i32, reg);
    }

    fn sarl_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b111i32, reg);
    }

    fn sarl_ri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex32RmFieldOptional(lhs);
        self.emitByte(0xC1u8);
        self.emitModRmOpcode(0b111i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn sarq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b111i32, reg);
    }

    fn sarq_ri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex64RmField(lhs);
        self.emitByte(0xC1u8);
        self.emitModRmOpcode(0b111i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn setcc_r(condition: Condition, dest: Register) {
        if dest.needsRexBit() || dest.lowBits() > 3i32 {
            self.emitRex(false, false, false, dest.needsRexBit());
        }

        self.emitByte(0x0Fu8);
        self.emitByte((0x90i32 + condition.toInt32()).toUInt8());
        self.emitModRmOpcode(0i32, dest);
    }

    fn shll_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b100i32, reg);
    }

    fn shll_ri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex32RmFieldOptional(lhs);
        self.emitByte(0xC1u8);
        self.emitModRmOpcode(0b100i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn shlq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b100i32, reg);
    }

    fn shlq_ri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex64RmField(lhs);
        self.emitByte(0xC1u8);
        self.emitModRmOpcode(0b100i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn shrl_r(reg: Register) {
        self.emitRex32RmFieldOptional(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b101i32, reg);
    }

    fn shrl_ri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex32RmFieldOptional(lhs);
        self.emitByte(0xC1u8);
        self.emitModRmOpcode(0b101i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn shrq_r(reg: Register) {
        self.emitRex64RmField(reg);
        self.emitByte(0xD3u8);
        self.emitModRmOpcode(0b101i32, reg);
    }

    fn shrq_ri(lhs: Register, rhs: Immediate) {
        assert(rhs.isInt8());
        self.emitRex64RmField(lhs);
        self.emitByte(0xC1u8);
        self.emitModRmOpcode(0b101i32, lhs);
        self.emitByte(rhs.toUInt8());
    }

    fn sqrtsd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x51u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn sqrtss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x51u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn subl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x29u8);
        self.emitModRmReg(src, dest);
    }

    fn subq_ri(reg: Register, imm: Immediate) {
        self.emitAlu64Imm(reg, imm, 0b101i32, 0x2Du8);
    }

    fn subq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x29u8);
        self.emitModRmReg(src, dest);
    }

    fn subsd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF2u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x5Cu8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn subss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0xF3u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x5Cu8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn testl_ai(lhs: Address, rhs: Immediate) {
        assert(rhs.isInt32());
        self.emitRex32AddressOptional(lhs);
        self.emitByte(0xF7u8);
        self.emitAddress(0b000i32, lhs);
        self.emitInt32(rhs.toInt32());
    }

    fn testl_ar(lhs: Address, rhs: Register) {
        self.emitRex32ModRmAddressOptional(rhs, lhs);
        self.emitByte(0x85u8);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn testl_ri(lhs: Register, imm: Immediate) {
        assert(imm.isInt32());

        if imm.isUInt8() {
            if lhs == RAX {
                self.emitByte(0xA8u8);
            } else if lhs.value < 4i32 {
                self.emitByte(0xF6u8);
                self.emitModRmOpcode(0b000i32, lhs);
            } else {
                self.emitRex(false, false, false, lhs.needsRexBit());
                self.emitByte(0xF6u8);
                self.emitModRmOpcode(0b000i32, lhs);
            }
            self.emitByte(imm.toUInt8());
        } else if lhs == RAX {
            self.emitByte(0xA9u8);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitByte(0xF7u8);
            self.emitModRmOpcode(0b000i32, lhs);
            self.emitInt32(imm.toInt32());
        }
    }

    fn testl_rr(lhs: Register, rhs: Register) {
        self.emitRex32ModRmOptional(rhs, lhs);
        self.emitByte(0x85u8);
        self.emitModRmReg(rhs, lhs);
    }

    fn testq_ai(lhs: Address, rhs: Immediate) {
        assert(rhs.isInt32());
        self.emitRex64Address(lhs);
        self.emitByte(0xF7u8);
        self.emitAddress(0b000i32, lhs);
        self.emitInt32(rhs.toInt32());
    }

    fn testq_ar(lhs: Address, rhs: Register) {
        self.emitRex64ModRmAddress(rhs, lhs);
        self.emitByte(0x85u8);
        self.emitAddress(rhs.lowBits(), lhs);
    }

    fn testq_rr(lhs: Register, rhs: Register) {
        self.emitRex64ModRm(rhs, lhs);
        self.emitByte(0x85u8);
        self.emitModRmReg(rhs, lhs);
    }

    fn tzcntl_rr(dest: Register, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRex32ModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBCu8);
        self.emitModRmReg(dest, src);
    }

    fn tzcntq_rr(dest: Register, src: Register) {
        self.emitByte(0xF3u8);
        self.emitRex64ModRm(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0xBCu8);
        self.emitModRmReg(dest, src);
    }

    fn ucomiss_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Eu8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn ucomisd_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitByte(0x66u8);
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x2Eu8);
        self.emitModRmSseRegisters(dest, src);
    }

    pub fn xaddl_ar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressOptional(src, dest);
        self.emitByte(0x0fu8);
        self.emitByte(0xc1u8);
        self.emitAddress(src.lowBits(), dest);
    }

    pub fn xaddq_ar(dest: Address, src: Register) {
        self.emitRex64ModRmAddress(src, dest);
        self.emitByte(0x0fu8);
        self.emitByte(0xc1u8);
        self.emitAddress(src.lowBits(), dest);
    }

    pub fn xchgb_ar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressByteOptional(src, dest);
        self.emitByte(0x86u8);
        self.emitAddress(src.lowBits(), dest);
    }

    pub fn xchgl_ar(dest: Address, src: Register) {
        self.emitRex32ModRmAddressOptional(src, dest);
        self.emitByte(0x87u8);
        self.emitAddress(src.lowBits(), dest);
    }

    pub fn xchgq_ar(dest: Address, src: Register) {
        self.emitRex64ModRmAddress(src, dest);
        self.emitByte(0x87u8);
        self.emitAddress(src.lowBits(), dest);
    }

    fn xorl_ri(lhs: Register, rhs: Immediate) {
        self.emitAlu32Imm(lhs, rhs, 0b110i32, 0x35u8);
    }

    fn xorl_rr(dest: Register, src: Register) {
        self.emitRex32ModRmOptional(src, dest);
        self.emitByte(0x31u8);
        self.emitModRmReg(src, dest);
    }

    fn xorpd_ra(dest: XmmRegister, src: Address) {
        self.emitByte(0x66u8);
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x57u8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn xorps_ra(dest: XmmRegister, src: Address) {
        self.emitRexSseAddressOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x57u8);
        self.emitAddress(dest.lowBits(), src);
    }

    fn xorps_rr(dest: XmmRegister, src: XmmRegister) {
        self.emitRexSseModRmOptional(dest, src);
        self.emitByte(0x0Fu8);
        self.emitByte(0x57u8);
        self.emitModRmSseRegisters(dest, src);
    }

    fn xorq_rr(dest: Register, src: Register) {
        self.emitRex64ModRm(src, dest);
        self.emitByte(0x31u8);
        self.emitModRmReg(src, dest);
    }

    fn emitAlu64Imm(reg: Register, imm: Immediate, modrm_reg: Int32, rax_opcode: UInt8) {
        assert(imm.isInt32());
        self.emitRex64RmField(reg);

        if imm.isInt8() {
            self.emitByte(0x83u8);
            self.emitModRm(0b11i32, modrm_reg, reg.lowBits());
            self.emitByte(imm.toUInt8());
        } else if reg == RAX {
            self.emitByte(rax_opcode);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitByte(0x81u8);
            self.emitModRm(0b11i32, modrm_reg, reg.lowBits());
            self.emitInt32(imm.toInt32());
        }
    }

    fn emitAlu32Imm(reg: Register, imm: Immediate, modrm_reg: Int32, rax_opcode: UInt8) {
        assert(imm.isInt32());
        self.emitRex32RmFieldOptional(reg);

        if imm.isInt8() {
            self.emitByte(0x83u8);
            self.emitModRmOpcode(modrm_reg, reg);
            self.emitByte(imm.toUInt8());
        } else if reg == RAX {
            self.emitByte(rax_opcode);
            self.emitInt32(imm.toInt32());
        } else {
            self.emitByte(0x81u8);
            self.emitModRmOpcode(modrm_reg, reg);
            self.emitInt32(imm.toInt32());
        }
    }

    fn emitLockPrefix() {
        self.emitByte(0xF0u8);
    }

    fn emitRex32RmFieldOptional(reg: Register) {
        if reg.needsRexBit() {
            self.emitRex(false, false, false, true);
        }
    }

    fn emitRex64RmField(modrm_rm: Register) {
        self.emitRex(true, false, false, modrm_rm.needsRexBit());
    }

    fn emitRex64ModRm(modrm_reg: Register, modrm_rm: Register) {
        self.emitRex(true, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
    }

    fn emitRex32ModRmOptional(modrm_reg: Register, modrm_rm: Register) {
        if modrm_reg.needsRexBit() || modrm_rm.needsRexBit() {
            self.emitRex(false, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
        }
    }

    fn emitRex32ModRmByteOptional(modrm_reg: Register, modrm_rm: Register) {
        if modrm_reg.needsRexBit() || modrm_rm.needsRexBit() || modrm_rm.value > 3i32 {
            self.emitRex(false, modrm_reg.needsRexBit(), false, modrm_rm.needsRexBit());
        }
    }

    fn emitRex32ModRmAddressOptional(reg: Register, address: Address) {
        if address.rex != 0u8 || reg.needsRexBit() {
            let rex = 0x40i32 | address.rex.toInt32() | if reg.needsRexBit() { 0x04i32 } else { 0i32 };
            self.emitByte(rex.toUInt8());
        };
    }

    fn emitRex32ModRmAddressByteOptional(reg: Register, address: Address) {
        if address.rex != 0u8 || reg.value > 3i32 {
            let rex = 0x40i32 | address.rex.toInt32() | if reg.needsRexBit() { 0x04i32 } else { 0i32 };
            self.emitByte(rex.toUInt8());
        };
    }

    fn emitRex32AddressOptional(address: Address) {
        if address.rex != 0u8 {
            self.emitByte((0x40i32 | address.rex.toInt32()).toUInt8());
        }
    }

    fn emitRex64ModRmAddress(reg: Register, address: Address) {
        let rex = 0x48i32 | address.rex.toInt32() | if reg.needsRexBit() { 0x04i32 } else { 0i32 };
        self.emitByte(rex.toUInt8());
    }

    fn emitRex64Address(address: Address) {
        self.emitByte((0x48i32 | address.rex.toInt32()).toUInt8());
    }

    fn emitRex64() {
        self.emitRex(true, false, false, false);
    }

    fn emitRexSseModRmOptional(reg: XmmRegister, rm: XmmRegister) {
        if reg.needsRexBit() || rm.needsRexBit() {
            self.emitRex(false, reg.needsRexBit(), false, rm.needsRexBit());
        }
    }

    fn emitRexSseAddressOptional(reg: XmmRegister, address: Address) {
        if reg.needsRexBit() || address.rex != 0u8 {
            let value = 0x40i32 | address.rex.toInt32() | if reg.needsRexBit() { 0x04i32 } else { 0i32 };
            self.emitByte(value.toUInt8());
        }
    }

    fn emitRexOptional(w: Bool, r: Bool, x: Bool, b: Bool) {
        if w || r || x || b {
            self.emitRex(w, r, x, b);
        }
    }

    fn emitRex(w: Bool, r: Bool, x: Bool, b: Bool) {
        // w - 64-bit width
        // r - extension of modrm-reg field
        // x - extension of sib index field
        // b - extension of modrm-rm/sib base/opcode reg field
        let opcode = 0x40i32 | w.toInt32() << 3i32 | r.toInt32() << 2i32 | x.toInt32() << 1i32 | b.toInt32();
        self.emitByte(opcode.toUInt8());
    }

    fn emitAddress(reg_or_opcode: Int32, address: Address) {
        assert(reg_or_opcode < 8i32);

        self.emitByte((reg_or_opcode << 3i32 | address.bytes(0i64).toInt32()).toUInt8());

        let mut i = 1i64;

        while i < address.length {
            self.emitByte(address.bytes(i));
            i = i + 1i64;
        }
    }

    fn emitModRmReg(reg: Register, rm: Register) {
        self.emitModRm(0b11i32, reg.lowBits(), rm.lowBits());
    }

    fn emitModRmOpcode(opcode: Int32, rm: Register) {
        self.emitModRm(0b11i32, opcode, rm.lowBits());
    }

    fn emitModRmSseRegisters(reg: XmmRegister, rm: XmmRegister) {
        self.emitModRm(0b11i32, reg.lowBits(), rm.lowBits());
    }

    fn emitModRm(mode: Int32, reg: Int32, rm: Int32) {
        assert(mode < 4i32 && reg < 8i32 && rm < 8i32);
        self.emitByte((mode << 6i32 | reg << 3i32 | rm).toUInt8());
    }

    fn emitSib(scale: Int32, index: Int32, base: Int32) {
        assert(scale < 4i32);
        assert(index < 8i32);
        assert(base < 8i32);
        self.emitByte((scale << 6i32 | index << 3i32 | base).toUInt8());
    }

    fn emitByte(value: UInt8) {
        self.buffer.emitByte(value);
    }

    fn emitInt32(value: Int32) {
        self.buffer.emitInt32(value);
    }

    fn emitInt64(value: Int64) {
        self.buffer.emitInt64(value);
    }

    fn emitJump(lbl: Label, kind: JumpDistance) {
        let pc = self.buffer.size();
        self.jumps.push((pc, lbl, kind));
    }

    fn size(): Int64 {
        self.buffer.size()
    }

    pub fn finalize(): Array[UInt8] {
        self.resolveJumps();
        while self.buffer.size() % 16 != 0 {
            self.int3();
        }
        self.buffer.toArray()
    }

    pub fn finalizeTesting(): MachineCode {
        self.resolveJumps();
        MachineCode::new(self.buffer.toArray())
    }

    fn resolveJumps() {
        for (pc, lbl, distance) in self.jumps {
            assert(lbl.isBound());

            if distance == JumpDistance::Near {
                let distance = lbl.offset - (pc + 1i64);
                assert(-128i64 <= distance && distance <= 127i64);
                self.buffer.patchUInt8(pc, distance.toUInt8());
            } else {
                assert(distance == JumpDistance::Far);
                let distance = lbl.offset - (pc + 4i64);
                assert(distance.toInt32().toInt64() == distance);
                self.buffer.patchInt32(pc, distance.toInt32());
            }
        }

        self.jumps.clear();
    }
}

enum Condition {
    Overflow,
    NoOverflow,
    Below,
    NeitherAboveNorEqual,
    NotBelow,
    AboveOrEqual,
    Equal,
    Zero,
    NotEqual,
    NotZero,
    BelowOrEqual,
    NotAbove,
    NeitherBelowNorEqual,
    Above,
    Sign,
    NoSign,
    Parity,
    ParityEven,
    NoParity,
    ParityOdd,
    Less,
    NeitherGreaterNorEqual,
    NotLess,
    GreaterOrEqual,
    LessOrEqual,
    NotGreater,
    NeitherLessNorEqual,
    Greater,
}

impl Condition {
    fn toInt32(): Int32 {
        if self == Condition::Overflow {
            0b0000i32
        } else if self == Condition::NoOverflow {
            0b0001i32
        } else if self == Condition::Below {
            0b0010i32
        } else if self == Condition::NeitherAboveNorEqual {
            0b0010i32
        } else if self == Condition::NotBelow {
            0b0011i32
        } else if self == Condition::AboveOrEqual {
            0b0011i32
        } else if self == Condition::Equal {
            0b0100i32
        } else if self == Condition::Zero {
            0b0100i32
        } else if self == Condition::NotEqual {
            0b0101i32
        } else if self == Condition::NotZero {
            0b0101i32
        } else if self == Condition::BelowOrEqual {
            0b0110i32
        } else if self == Condition::NotAbove {
            0b0110i32
        } else if self == Condition::NeitherBelowNorEqual {
            0b0111i32
        } else if self == Condition::Above {
            0b0111i32
        } else if self == Condition::Sign {
            0b1000i32
        } else if self == Condition::NoSign {
            0b1001i32
        } else if self == Condition::Parity {
            0b1010i32
        } else if self == Condition::ParityEven {
            0b1010i32
        } else if self == Condition::NoParity {
            0b1011i32
        } else if self == Condition::ParityOdd {
            0b1011i32
        } else if self == Condition::Less {
            0b1100i32
        } else if self == Condition::NeitherGreaterNorEqual {
            0b1100i32
        } else if self == Condition::NotLess {
            0b1101i32
        } else if self == Condition::GreaterOrEqual {
            0b1101i32
        } else if self == Condition::LessOrEqual {
            0b1110i32
        } else if self == Condition::NotGreater {
            0b1110i32
        } else if self == Condition::NeitherLessNorEqual {
            0b1111i32
        } else if self == Condition::Greater {
            0b1111i32
        } else {
            unreachable[Int32]()
        }
    }
}

struct Immediate(value: Int64)

impl Immediate {
    fn isInt8(): Bool {
        let limit = 1i64 << 7i32;
        -limit <= self.value && self.value < limit
    }

    fn isUInt8(): Bool {
        0i64 <= self.value && self.value < 256i64
    }

    fn isInt32(): Bool {
        let limit = 1i64 << 32i32;
        -limit <= self.value && self.value < limit
    }

    fn isUInt32(): Bool {
        let limit = 1i64 << 32i32;
        0i64 <= self.value && self.value < limit
    }

    fn toUInt8(): UInt8 {
        self.value.toUInt8()
    }

    fn toInt32(): Int32 {
        self.value.toInt32()
    }

    fn toInt64(): Int64 {
        self.value
    }
}

enum ScaleFactor {
    One,
    Two,
    Four,
    Eight,
}

impl ScaleFactor {
    fn value(): Int32 {
        if self == ScaleFactor::One {
            0i32
        } else if self == ScaleFactor::Two {
            1i32
        } else if self == ScaleFactor::Four {
            2i32
        } else if self == ScaleFactor::Eight {
            3i32
        } else {
            unreachable[Int32]()
        }
    }
}

class Address {
    rex: UInt8,
    length: Int64,
    bytes: Array[UInt8],
}

impl Address {
    static fn new(): Address {
        Address(0u8, 0, Array[UInt8]::zero(6i64))
    }

    fn set_modrm(mode: Int32, reg: Register) {
        assert(self.length == 0i64);
        assert(0i32 <= mode && mode < 4i32);

        if reg.needsRexBit() {
            self.rex = (self.rex.toInt32() | 0x41i32).toUInt8();
        }

        self.bytes(0i64) = (mode << 6i32 | reg.lowBits()).toUInt8();
        self.length = self.length + 1i64;
    }

    fn set_sib(scale: ScaleFactor, index: Register, base: Register) {
        assert(self.length == 1i64);

        if base.needsRexBit() {
            self.rex = (self.rex.toInt32() | 0x41i32).toUInt8();
        }

        if index.needsRexBit() {
            self.rex = (self.rex.toInt32() | 0x42i32).toUInt8();
        }

        self.bytes(1i64) = (scale.value() << 6i32 | index.lowBits() << 3i32 | base.lowBits()).toUInt8();
        self.length = self.length + 1i64;
    }

    fn set_disp8(imm: Int32) {
        assert(self.length == 1i64 || self.length == 2i64);
        self.bytes(self.length) = imm.toUInt8();
        self.length = self.length + 1i64;
    }

    fn set_disp32(imm: Int32) {
        assert(self.length == 1i64 || self.length == 2i64);
        self.bytes(self.length) = imm.toUInt8();
        self.bytes(self.length + 1i64) = (imm >> 8i32).toUInt8();
        self.bytes(self.length + 2i64) = (imm >> 16i32).toUInt8();
        self.bytes(self.length + 3i64) = (imm >> 24i32).toUInt8();
        self.length = self.length + 4i64;
    }

    static fn offset(base: Register, offset: Int32): Address {
        let address = Address::new();

        let mode = if offset == 0i32 && base != RBP && base != R13 {
            0b00i32
        } else if -128i32 <= offset && offset < 128i32 {
            0b01i32
        } else {
            0b10i32
        };

        address.set_modrm(mode, base);

        if base == RSP {
            address.set_sib(ScaleFactor::One, RSP, base);
        }

        if mode == 0b00i32 {
            // nothing to do
        } else if mode == 0b01i32 {
            address.set_disp8(offset);
        } else if mode == 0b10i32 {
            address.set_disp32(offset);
        } else {
            unreachable[()]();
        }

        address
    }

    static fn index(index: Register, factor: ScaleFactor, disp: Int32): Address {
        let address = Address::new();

        address.set_modrm(0b00i32, RSP);
        assert(index != RSP);

        address.set_sib(factor, index, RBP);
        address.set_disp32(disp);

        address
    }

    static fn array(base: Register, index: Register, factor: ScaleFactor, disp: Int32): Address {
        let address = Address::new();

        let mode = if disp == 0i32 && base != RBP && base != R13 {
            0b00i32
        } else if -128i32 <= disp && disp < 128i32 {
            0b01i32
        } else {
            0b10i32
        };

        address.set_modrm(mode, RSP);
        assert(index != RSP);

        address.set_sib(factor, index, base);

        if mode == 0b00i32 {
            // nothing to do
        } else if mode == 0b01i32 {
            address.set_disp8(disp);
        } else if mode == 0b10i32 {
            address.set_disp32(disp);
        } else {
            unreachable[()]();
        }

        address
    }

    static fn rip(disp: Int32): Address {
        let address = Address::new();

        address.set_modrm(0b00i32, RBP);
        address.set_disp32(disp);

        address
    }
}

@Test
fn testConditionCodes() {
    assert(Condition::Overflow.toInt32() == 0b0000i32);

    assert(Condition::NoOverflow.toInt32() == 0b0001i32);

    assert(Condition::Below.toInt32() == 0b0010i32);
    assert(Condition::NeitherAboveNorEqual.toInt32() == 0b0010i32);

    assert(Condition::NotBelow.toInt32() == 0b0011i32);
    assert(Condition::AboveOrEqual.toInt32() == 0b0011i32);

    assert(Condition::Equal.toInt32() == 0b0100i32);
    assert(Condition::Zero.toInt32() == 0b0100i32);

    assert(Condition::NotEqual.toInt32() == 0b0101i32);
    assert(Condition::NotZero.toInt32() == 0b0101i32);

    assert(Condition::BelowOrEqual.toInt32() == 0b0110i32);
    assert(Condition::NotAbove.toInt32() == 0b0110i32);

    assert(Condition::NeitherBelowNorEqual.toInt32() == 0b0111i32);
    assert(Condition::Above.toInt32() == 0b0111i32);

    assert(Condition::Sign.toInt32() == 0b1000i32);

    assert(Condition::NoSign.toInt32() == 0b1001i32);

    assert(Condition::Parity.toInt32() == 0b1010i32);
    assert(Condition::ParityEven.toInt32() == 0b1010i32);

    assert(Condition::NoParity.toInt32() == 0b1011i32);
    assert(Condition::ParityOdd.toInt32() == 0b1011i32);

    assert(Condition::Less.toInt32() == 0b1100i32);
    assert(Condition::NeitherGreaterNorEqual.toInt32() == 0b1100i32);

    assert(Condition::NotLess.toInt32() == 0b1101i32);
    assert(Condition::GreaterOrEqual.toInt32() == 0b1101i32);

    assert(Condition::LessOrEqual.toInt32() == 0b1110i32);
    assert(Condition::NotGreater.toInt32() == 0b1110i32);

    assert(Condition::NeitherLessNorEqual.toInt32() == 0b1111i32);
    assert(Condition::Greater.toInt32() == 0b1111i32);

}

impl Register {
    fn lowBits(): Int32 { self.value & 0b111i32 }
    fn needsRexBit(): Bool { self.value > 7i32 }
}

mod tests {
    use super::{Address, AssemblerX64, Condition, Immediate, MachineCode, ScaleFactor};
    use super::{RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI};
    use super::{R8, R9, R10, R11, R12, R13, R14, R15};
    use super::{XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6};
    use super::{XMM7, XMM8, XMM9, XMM10, XMM11, XMM12, XMM13};
    use super::{XMM14, XMM15};

    @Test
    fn registers() {
        assert(RAX.lowBits() == 0i32 && !RAX.needsRexBit());
        assert(RCX.lowBits() == 1i32 && !RCX.needsRexBit());
        assert(RDX.lowBits() == 2i32 && !RDX.needsRexBit());
        assert(RBX.lowBits() == 3i32 && !RBX.needsRexBit());
        assert(RSP.lowBits() == 4i32 && !RSP.needsRexBit());
        assert(RBP.lowBits() == 5i32 && !RBP.needsRexBit());
        assert(RSI.lowBits() == 6i32 && !RSI.needsRexBit());
        assert(RDI.lowBits() == 7i32 && !RDI.needsRexBit());

        assert(R8.lowBits() == 0i32 && R8.needsRexBit());
        assert(R9.lowBits() == 1i32 && R9.needsRexBit());
        assert(R10.lowBits() == 2i32 && R10.needsRexBit());
        assert(R11.lowBits() == 3i32 && R11.needsRexBit());
        assert(R12.lowBits() == 4i32 && R12.needsRexBit());
        assert(R13.lowBits() == 5i32 && R13.needsRexBit());
        assert(R14.lowBits() == 6i32 && R14.needsRexBit());
        assert(R15.lowBits() == 7i32 && R15.needsRexBit());
    }

    @Test
    fn pushq_r() {
        let asm = AssemblerX64::new();
        asm.pushq_r(RAX);
        asm.pushq_r(RSP);
        asm.pushq_r(R8);
        asm.pushq_r(R15);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x50u8);
        assertAsm(buffer, 0x54u8);
        assertAsm(buffer, 0x41u8, 0x50u8);
        assertAsm(buffer, 0x41u8, 0x57u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn popq_r() {
        let asm = AssemblerX64::new();
        asm.popq_r(RAX);
        asm.popq_r(RSP);
        asm.popq_r(R8);
        asm.popq_r(R15);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x58u8);
        assertAsm(buffer, 0x5Cu8);
        assertAsm(buffer, 0x41u8, 0x58u8);
        assertAsm(buffer, 0x41u8, 0x5Fu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movq_rr() {
        let asm = AssemblerX64::new();
        asm.movq_rr(R15, RAX);
        asm.movq_rr(RAX, R15);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x49u8, 0x89u8, 0xC7u8);
        assertAsm(buffer, 0x4Cu8, 0x89u8, 0xF8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movl_rr() {
        let asm = AssemblerX64::new();
        asm.movl_rr(R15, RAX);
        asm.movl_rr(RAX, R15);
        asm.movl_rr(RCX, RAX);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x41u8, 0x89u8, 0xC7u8);
        assertAsm(buffer, 0x44u8, 0x89u8, 0xF8u8);
        assertAsm(buffer, 0x89u8, 0xC1u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn addq_rr() {
        let asm = AssemblerX64::new();
        asm.addq_rr(RAX, RBX);
        asm.addq_rr(RAX, R12);
        asm.addq_rr(R12, RAX);
        asm.addq_rr(R15, RSP);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x48u8, 0x01u8, 0xD8u8);
        assertAsm(buffer, 0x4Cu8, 0x01u8, 0xE0u8);
        assertAsm(buffer, 0x49u8, 0x01u8, 0xC4u8);
        assertAsm(buffer, 0x49u8, 0x01u8, 0xE7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn addl_rr() {
        let asm = AssemblerX64::new();
        asm.addl_rr(RAX, RBX);
        asm.addl_rr(RCX, R15);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x01u8, 0xD8u8);
        assertAsm(buffer, 0x44u8, 0x01u8, 0xF9u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn addl_ri() {
        let asm = AssemblerX64::new();
        asm.addl_ri(RAX, Immediate(1));
        asm.addl_ri(RCX, Immediate(1));
        asm.addl_ri(RAX, Immediate(128));
        asm.addl_ri(RCX, Immediate(128));
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x83u8, 0xc0u8, 0x01u8); // add eax, 1
        assertAsm(buffer, 0x83u8, 0xc1u8, 0x01u8); // add ecx, 1
        assertAsm(buffer, 0x05u8, 0x80u8, 0u8, 0u8, 0u8); // add eax, 128
        assertAsm(buffer, 0x81u8, 0xc1u8, 0x80u8, 0u8, 0u8, 0u8); // add ecx, 128
        assertAsmEnd(buffer);
    }

    @Test
    fn addq_ri() {
        let asm = AssemblerX64::new();
        asm.addq_ri(RAX, Immediate(0x11i64));
        asm.addq_ri(R15, Immediate(0x11i64));
        asm.addq_ri(RAX, Immediate(0x2211i64));
        asm.addq_ri(RCX, Immediate(0x2211i64));
        asm.addq_ri(R15, Immediate(0x2211i64));
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x48u8, 0x83u8, 0xC0u8, 0x11u8);
        assertAsm(buffer, 0x49u8, 0x83u8, 0xC7u8, 0x11u8);
        assertAsm(buffer, 0x48u8, 0x05u8, 0x11u8, 0x22u8, 0u8, 0u8);
        assertAsm(buffer, 0x48u8, 0x81u8, 0xC1u8, 0x11u8, 0x22u8, 0u8, 0u8);
        assertAsm(buffer, 0x49u8, 0x81u8, 0xC7u8, 0x11u8, 0x22u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn subq_rr() {
        let asm = AssemblerX64::new();
        asm.subq_rr(RAX, RBX);
        asm.subq_rr(RCX, R15);
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x48u8, 0x29u8, 0xD8u8);
        assertAsm(buffer, 0x4Cu8, 0x29u8, 0xF9u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn subq_ri() {
        let asm = AssemblerX64::new();
        asm.subq_ri(RAX, Immediate(0x11i64));
        asm.subq_ri(R15, Immediate(0x11i64));
        asm.subq_ri(RAX, Immediate(0x2211i64));
        asm.subq_ri(RCX, Immediate(0x2211i64));
        asm.subq_ri(R15, Immediate(0x2211i64));
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x48u8, 0x83u8, 0xE8u8, 0x11u8);
        assertAsm(buffer, 0x49u8, 0x83u8, 0xEFu8, 0x11u8);
        assertAsm(buffer, 0x48u8, 0x2Du8, 0x11u8, 0x22u8, 0u8, 0u8);
        assertAsm(buffer, 0x48u8, 0x81u8, 0xE9u8, 0x11u8, 0x22u8, 0u8, 0u8);
        assertAsm(buffer, 0x49u8, 0x81u8, 0xEFu8, 0x11u8, 0x22u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn retq() {
        let asm = AssemblerX64::new();
        asm.retq();
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0xC3u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn nop() {
        let asm = AssemblerX64::new();
        asm.nop();
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x90u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cdq_cqo() {
        let asm = AssemblerX64::new();
        asm.cdq();
        asm.cqo();
        let buffer = asm.finalizeTesting();
        assertAsm(buffer, 0x99u8);
        assertAsm(buffer, 0x48u8, 0x99u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn orl_rr() {
        let asm = AssemblerX64::new();
        asm.orl_rr(RAX, R15);
        asm.orl_rr(RAX, RCX);
        asm.orl_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x44u8, 0x09u8, 0xF8u8);
        assertAsm(buffer, 0x09u8, 0xC8u8);
        assertAsm(buffer, 0x41u8, 0x09u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn orq_rr() {
        let asm = AssemblerX64::new();
        asm.orq_rr(RAX, R15);
        asm.orq_rr(RAX, RCX);
        asm.orq_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x4Cu8, 0x09u8, 0xF8u8);
        assertAsm(buffer, 0x48u8, 0x09u8, 0xC8u8);
        assertAsm(buffer, 0x49u8, 0x09u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn andl_rr() {
        let asm = AssemblerX64::new();
        asm.andl_rr(RAX, R15);
        asm.andl_rr(RAX, RCX);
        asm.andl_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x44u8, 0x21u8, 0xF8u8);
        assertAsm(buffer, 0x21u8, 0xC8u8);
        assertAsm(buffer, 0x41u8, 0x21u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn andq_rr() {
        let asm = AssemblerX64::new();
        asm.andq_rr(RAX, R15);
        asm.andq_rr(RAX, RCX);
        asm.andq_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x4Cu8, 0x21u8, 0xF8u8);
        assertAsm(buffer, 0x48u8, 0x21u8, 0xC8u8);
        assertAsm(buffer, 0x49u8, 0x21u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn xorl_rr() {
        let asm = AssemblerX64::new();
        asm.xorl_rr(RAX, R15);
        asm.xorl_rr(RAX, RCX);
        asm.xorl_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x44u8, 0x31u8, 0xF8u8);
        assertAsm(buffer, 0x31u8, 0xC8u8);
        assertAsm(buffer, 0x41u8, 0x31u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn xorq_rr() {
        let asm = AssemblerX64::new();
        asm.xorq_rr(RAX, R15);
        asm.xorq_rr(RAX, RCX);
        asm.xorq_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x4Cu8, 0x31u8, 0xF8u8);
        assertAsm(buffer, 0x48u8, 0x31u8, 0xC8u8);
        assertAsm(buffer, 0x49u8, 0x31u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpl_rr() {
        let asm = AssemblerX64::new();
        asm.cmpl_rr(RAX, R15);
        asm.cmpl_rr(R15, RBX);
        asm.cmpl_rr(RAX, RBX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x44u8, 0x39u8, 0xF8u8);
        assertAsm(buffer, 0x41u8, 0x39u8, 0xDFu8);
        assertAsm(buffer, 0x39u8, 0xD8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpq_rr() {
        let asm = AssemblerX64::new();
        asm.cmpq_rr(RAX, R15);
        asm.cmpq_rr(R15, RBX);
        asm.cmpq_rr(RAX, RBX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x4Cu8, 0x39u8, 0xF8u8);
        assertAsm(buffer, 0x49u8, 0x39u8, 0xDFu8);
        assertAsm(buffer, 0x48u8, 0x39u8, 0xD8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn imull_rr() {
        let asm = AssemblerX64::new();
        asm.imull_rr(RAX, RBX);
        asm.imull_rr(RCX, R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0xAFu8, 0xC3u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0xAFu8, 0xCFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn imulq_rr() {
        let asm = AssemblerX64::new();
        asm.imulq_rr(RAX, RBX);
        asm.imulq_rr(RCX, R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xAFu8, 0xC3u8);
        assertAsm(buffer, 0x49u8, 0x0Fu8, 0xAFu8, 0xCFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn idivl_r() {
        let asm = AssemblerX64::new();
        asm.idivl_r(RAX);
        asm.idivl_r(R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF7u8, 0xF8u8);
        assertAsm(buffer, 0x41u8, 0xF7u8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn idivq_r() {
        let asm = AssemblerX64::new();
        asm.idivq_r(RAX);
        asm.idivq_r(R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xF7u8, 0xF8u8);
        assertAsm(buffer, 0x49u8, 0xF7u8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn setcc_r() {
        let asm = AssemblerX64::new();
        asm.setcc_r(Condition::Equal, RAX);
        asm.setcc_r(Condition::NotEqual, R15);
        asm.setcc_r(Condition::GreaterOrEqual, RCX);
        asm.setcc_r(Condition::Greater, RDX);
        asm.setcc_r(Condition::LessOrEqual, RSI);
        asm.setcc_r(Condition::Less, RDI);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0x94u8, 0xC0u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0x95u8, 0xC7u8);
        assertAsm(buffer, 0x0Fu8, 0x9Du8, 0xC1u8);
        assertAsm(buffer, 0x0Fu8, 0x9Fu8, 0xC2u8);
        assertAsm(buffer, 0x40u8, 0x0Fu8, 0x9Eu8, 0xC6u8);
        assertAsm(buffer, 0x40u8, 0x0Fu8, 0x9Cu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn call_r() {
        let asm = AssemblerX64::new();
        asm.call_r(RAX);
        asm.call_r(R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xFFu8, 0xD0u8);
        assertAsm(buffer, 0x41u8, 0xFFu8, 0xD7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmovl() {
        let asm = AssemblerX64::new();
        asm.cmovl(Condition::Equal, R15, RAX);
        asm.cmovl(Condition::NotEqual, RAX, R13);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x44u8, 0x0Fu8, 0x44u8, 0xF8u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0x45u8, 0xC5u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmovq() {
        let asm = AssemblerX64::new();
        asm.cmovq(Condition::Greater, RAX, RCX);
        asm.cmovq(Condition::Equal, R15, RAX);
        asm.cmovq(Condition::NotEqual, RAX, R13);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x0Fu8, 0x4Fu8, 0xC1u8);
        assertAsm(buffer, 0x4Cu8, 0x0Fu8, 0x44u8, 0xF8u8);
        assertAsm(buffer, 0x49u8, 0x0Fu8, 0x45u8, 0xC5u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movl_ri() {
        let asm = AssemblerX64::new();
        asm.movl_ri(RAX, Immediate(2i64));
        asm.movl_ri(R14, Immediate(3i64));
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xB8u8, 2u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x41u8, 0xBEu8, 3u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movq_ri() {
        let asm = AssemblerX64::new();
        asm.movq_ri(RAX, Immediate(1i64));
        asm.movq_ri(R15, Immediate(-1i64));
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xC7u8, 0xC0u8, 1u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x49u8, 0xC7u8, 0xC7u8, 0xFFu8, 0xFFu8, 0xFFu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testl_rr() {
        let asm = AssemblerX64::new();
        asm.testl_rr(RAX, RAX);
        asm.testl_rr(RSI, RAX);
        asm.testl_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x85u8, 0xC0u8);
        assertAsm(buffer, 0x85u8, 0xC6u8);
        assertAsm(buffer, 0x41u8, 0x85u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testq_rr() {
        let asm = AssemblerX64::new();
        asm.testq_rr(RAX, RAX);
        asm.testq_rr(RSI, RAX);
        asm.testq_rr(R15, RAX);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x85u8, 0xC0u8);
        assertAsm(buffer, 0x48u8, 0x85u8, 0xC6u8);
        assertAsm(buffer, 0x49u8, 0x85u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movq_ra() {
        let asm = AssemblerX64::new();
        asm.movq_ra(RAX, Address::offset(RSP, 0i32));
        asm.movq_ra(RAX, Address::offset(RSP, 1i32));

        asm.movq_ra(R15, Address::offset(RSP, 0i32));
        asm.movq_ra(R15, Address::offset(RSP, 1i32));

        asm.movq_ra(R15, Address::offset(RSP, 127i32));
        asm.movq_ra(R15, Address::offset(RSP, -128i32));

        asm.movq_ra(R15, Address::offset(RSP, 128i32));
        asm.movq_ra(R15, Address::offset(RSP, -129i32));

        asm.movq_ra(RAX, Address::offset(RBP, 0i32));
        asm.movq_ra(RAX, Address::offset(RBP, 1i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x8Bu8, 0x04u8, 0x24u8);
        assertAsm(buffer, 0x48u8, 0x8Bu8, 0x44u8, 0x24u8, 1u8);

        assertAsm(buffer, 0x4Cu8, 0x8Bu8, 0x3Cu8, 0x24u8);
        assertAsm(buffer, 0x4Cu8, 0x8Bu8, 0x7Cu8, 0x24u8, 1u8);

        assertAsm(buffer, 0x4Cu8, 0x8Bu8, 0x7Cu8, 0x24u8, 0x7Fu8);
        assertAsm(buffer, 0x4Cu8, 0x8Bu8, 0x7Cu8, 0x24u8, 0x80u8);

        assertAsm(buffer, 0x4Cu8, 0x8Bu8, 0xBCu8, 0x24u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x4Cu8, 0x8Bu8, 0xBCu8, 0x24u8, 0x7Fu8, 0xFFu8, 0xFFu8, 0xFFu8);

        assertAsm(buffer, 0x48u8, 0x8Bu8, 0x45u8, 0u8);
        assertAsm(buffer, 0x48u8, 0x8Bu8, 0x45u8, 1u8);

        assertAsmEnd(buffer);
    }

    @Test
    fn movq_ar() {
        let asm = AssemblerX64::new();
        asm.movq_ar(Address::offset(RBP, 0i32), RAX);
        asm.movq_ar(Address::offset(R13, 0i32), RAX);
        asm.movq_ar(Address::array(RAX, RBP, ScaleFactor::Four, 1i32), RAX);
        asm.movq_ar(Address::array(RBP, RAX, ScaleFactor::Eight, 0i32), RAX);
        asm.movq_ar(Address::array(R13, RAX, ScaleFactor::Eight, 0i32), RAX);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x89u8, 0x45u8, 0u8);
        assertAsm(buffer, 0x49u8, 0x89u8, 0x45u8, 0u8);
        assertAsm(buffer, 0x48u8, 0x89u8, 0x44u8, 0xA8u8, 1u8);
        assertAsm(buffer, 0x48u8, 0x89u8, 0x44u8, 0xc5u8, 0u8);
        assertAsm(buffer, 0x49u8, 0x89u8, 0x44u8, 0xc5u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movl_ra() {
        let asm = AssemblerX64::new();
        asm.movl_ra(RAX, Address::offset(RBP, 0i32));
        asm.movl_ra(RAX, Address::rip(0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x8Bu8, 0x45u8, 0u8);
        assertAsm(buffer, 0x8Bu8, 0x05u8, 0u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movl_ar() {
        let asm = AssemblerX64::new();
        asm.movl_ar(Address::offset(RBP, 0i32), RAX);
        asm.movl_ar(Address::offset(RBP, 0i32), R15);
        asm.movl_ar(Address::offset(R8, 0i32), R15);
        asm.movl_ar(Address::array(R8, R9, ScaleFactor::Four, 0i32), R15);
        asm.movl_ar(Address::array(RAX, RBP, ScaleFactor::Four, 1i32), RAX);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x89u8, 0x45u8, 0u8);
        assertAsm(buffer, 0x44u8, 0x89u8, 0x7Du8, 0u8);
        assertAsm(buffer, 0x45u8, 0x89u8, 0x38u8);
        assertAsm(buffer, 0x47u8, 0x89u8, 0x3Cu8, 0x88u8);
        assertAsm(buffer, 0x89u8, 0x44u8, 0xA8u8, 1u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn lea() {
        let asm = AssemblerX64::new();
        asm.lea(RAX, Address::offset(RAX, 0i32));
        asm.lea(RAX, Address::offset(RAX, 1i32));
        asm.lea(RAX, Address::offset(R8, 0i32));
        asm.lea(R8, Address::offset(RAX, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x8Du8, 0x00u8);
        assertAsm(buffer, 0x48u8, 0x8Du8, 0x40u8, 1u8);
        assertAsm(buffer, 0x49u8, 0x8Du8, 0x00u8);
        assertAsm(buffer, 0x4Cu8, 0x8Du8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movb_ar() {
        let asm = AssemblerX64::new();
        asm.movb_ar(Address::offset(RSP, 0i32), RAX);
        asm.movb_ar(Address::offset(RSP, 0i32), RSI);
        asm.movb_ar(Address::offset(RSP, 0i32), R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x88u8, 0x04u8, 0x24u8);
        assertAsm(buffer, 0x40u8, 0x88u8, 0x34u8, 0x24u8);
        assertAsm(buffer, 0x44u8, 0x88u8, 0x04u8, 0x24u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movb_ai() {
        let asm = AssemblerX64::new();
        asm.movb_ai(Address::offset(RAX, 0i32), Immediate(1i64));
        asm.movb_ai(Address::offset(RAX, 0i32), Immediate(127i64));
        asm.movb_ai(Address::offset(RAX, 0i32), Immediate(255i64));
        asm.movb_ai(Address::offset(RAX, 0i32), Immediate(-128i64));
        asm.movb_ai(Address::offset(RAX, 0i32), Immediate(128i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xC6u8, 0x00u8, 1u8);
        assertAsm(buffer, 0xC6u8, 0x00u8, 0x7Fu8);
        assertAsm(buffer, 0xC6u8, 0x00u8, 0xFFu8);
        assertAsm(buffer, 0xC6u8, 0x00u8, 0x80u8);
        assertAsm(buffer, 0xC6u8, 0x00u8, 0x80u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movq_ai() {
        let asm = AssemblerX64::new();
        asm.movq_ai(Address::offset(RAX, 0i32), Immediate(1i64));
        asm.movq_ai(Address::offset(R8, 0i32), Immediate(Int32::maxValue().toInt64()));
        asm.movq_ai(Address::offset(RDI, 0i32), Immediate(Int32::maxValue().toInt64()));
        asm.movq_ai(Address::offset(R15, 0i32), Immediate(Int32::minValue().toInt64()));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xC7u8, 0x00u8, 1u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x49u8, 0xC7u8, 0x00u8, 0xFFu8, 0xFFu8, 0xFFu8, 0x7Fu8);
        assertAsm(buffer, 0x48u8, 0xC7u8, 0x07u8, 0xFFu8, 0xFFu8, 0xFFu8, 0x7Fu8);
        assertAsm(buffer, 0x49u8, 0xC7u8, 0x07u8, 0u8, 0u8, 0u8, 0x80u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movl_ai() {
        let asm = AssemblerX64::new();
        asm.movl_ai(Address::offset(RAX, 0i32), Immediate(1i64));
        asm.movl_ai(Address::offset(R8, 0i32), Immediate((1i64 << 32i32) - 1i64));
        asm.movl_ai(Address::offset(RDI, 0i32), Immediate(Int32::maxValue().toInt64()));
        asm.movl_ai(Address::offset(R15, 0i32), Immediate(Int32::minValue().toInt64()));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xC7u8, 0x00u8, 1u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x41u8, 0xC7u8, 0x00u8, 0xFFu8, 0xFFu8, 0xFFu8, 0xFFu8);
        assertAsm(buffer, 0xC7u8, 0x07u8, 0xFFu8, 0xFFu8, 0xFFu8, 0x7Fu8);
        assertAsm(buffer, 0x41u8, 0xC7u8, 0x07u8, 0u8, 0u8, 0u8, 0x80u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testl_ri() {
        let asm = AssemblerX64::new();
        asm.testl_ri(RAX, Immediate(1i64));
        asm.testl_ri(RCX, Immediate(255i64));
        asm.testl_ri(RDX, Immediate(1i64));
        asm.testl_ri(RBX, Immediate(1i64));

        asm.testl_ri(RSI, Immediate(1i64));
        asm.testl_ri(RDI, Immediate(1i64));
        asm.testl_ri(R8, Immediate(1i64));
        asm.testl_ri(R15, Immediate(1i64));

        asm.testl_ri(RAX, Immediate(256i64));
        asm.testl_ri(RDI, Immediate(256i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xA8u8, 1u8);
        assertAsm(buffer, 0xF6u8, 0xC1u8, 255u8);
        assertAsm(buffer, 0xF6u8, 0xC2u8, 1u8);
        assertAsm(buffer, 0xF6u8, 0xC3u8, 1u8);

        assertAsm(buffer, 0x40u8, 0xF6u8, 0xC6u8, 1u8);
        assertAsm(buffer, 0x40u8, 0xF6u8, 0xC7u8, 1u8);
        assertAsm(buffer, 0x41u8, 0xF6u8, 0xC0u8, 1u8);
        assertAsm(buffer, 0x41u8, 0xF6u8, 0xC7u8, 1u8);

        assertAsm(buffer, 0xA9u8, 0u8, 1u8, 0u8, 0u8);
        assertAsm(buffer, 0xF7u8, 0xC7u8, 0u8, 1u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testl_ar() {
        let asm = AssemblerX64::new();
        asm.testl_ar(Address::offset(RDI, 1i32), RAX);
        asm.testl_ar(Address::offset(RDI, 0i32), RAX);

        asm.testl_ar(Address::offset(R8, 0i32), RAX);
        asm.testl_ar(Address::offset(R8, 1i32), RAX);
        asm.testl_ar(Address::offset(R8, 0i32), R15);

        asm.testl_ar(Address::offset(RAX, 0i32), R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x85u8, 0x47u8, 1u8);
        assertAsm(buffer, 0x85u8, 0x07u8);

        assertAsm(buffer, 0x41u8, 0x85u8, 0x00u8);
        assertAsm(buffer, 0x41u8, 0x85u8, 0x40u8, 1u8);
        assertAsm(buffer, 0x45u8, 0x85u8, 0x38u8);

        assertAsm(buffer, 0x44u8, 0x85u8, 0x38u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testl_ai() {
        let asm = AssemblerX64::new();
        asm.testl_ai(Address::offset(RAX, 0i32), Immediate(1i64));
        asm.testl_ai(Address::offset(RAX, 1i32), Immediate(1i64));

        asm.testl_ai(Address::offset(R8, 0i32), Immediate(1i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF7u8, 0x00u8, 1u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0xF7u8, 0x40u8, 1u8, 1u8, 0u8, 0u8, 0u8);

        assertAsm(buffer, 0x41u8, 0xF7u8, 0x00u8, 1u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testq_ai() {
        let asm = AssemblerX64::new();
        asm.testq_ai(Address::offset(RAX, 0i32), Immediate(1i64));
        asm.testq_ai(Address::offset(RAX, 1i32), Immediate(1i64));

        asm.testq_ai(Address::offset(R8, 0i32), Immediate(1i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xF7u8, 0x00u8, 1u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x48u8, 0xF7u8, 0x40u8, 1u8, 1u8, 0u8, 0u8, 0u8);

        assertAsm(buffer, 0x49u8, 0xF7u8, 0x00u8, 1u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn testq_ar() {
        let asm = AssemblerX64::new();
        asm.testq_ar(Address::offset(RDI, 1i32), RAX);
        asm.testq_ar(Address::offset(R8, 0i32), R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x85u8, 0x47u8, 1u8);
        assertAsm(buffer, 0x4Du8, 0x85u8, 0x38u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movzxb_rr() {
        let asm = AssemblerX64::new();
        asm.movzxb_rr(RAX, RAX);
        asm.movzxb_rr(RAX, RDI);
        asm.movzxb_rr(RDI, RAX);
        asm.movzxb_rr(RAX, R15);
        asm.movzxb_rr(R15, RBX);
        asm.movzxb_rr(RCX, RSI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0xB6u8, 0xC0u8);
        assertAsm(buffer, 0x40u8, 0x0Fu8, 0xB6u8, 0xC7u8);
        assertAsm(buffer, 0x0Fu8, 0xB6u8, 0xF8u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0xB6u8, 0xC7u8);
        assertAsm(buffer, 0x44u8, 0x0Fu8, 0xB6u8, 0xFBu8);
        assertAsm(buffer, 0x40u8, 0x0Fu8, 0xB6u8, 0xCEu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movzxb_ra() {
        let asm = AssemblerX64::new();
        asm.movzxb_ra(RAX, Address::offset(RAX, 0i32));
        asm.movzxb_ra(R8, Address::offset(RAX, 0i32));
        asm.movzxb_ra(RAX, Address::offset(R8, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0xB6u8, 0x00u8);
        assertAsm(buffer, 0x44u8, 0x0Fu8, 0xB6u8, 0x00u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0xB6u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsxbl_rr() {
        let asm = AssemblerX64::new();
        asm.movsxbl_rr(RAX, RAX);
        asm.movsxbl_rr(RAX, R8);
        asm.movsxbl_rr(RSP, RAX);
        asm.movsxbl_rr(R15, RAX);

        asm.movsxbl_rr(RAX, RBX);
        asm.movsxbl_rr(RAX, RSP);
        asm.movsxbl_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0xBEu8, 0xC0u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0xBEu8, 0xC0u8);
        assertAsm(buffer, 0x0Fu8, 0xBEu8, 0xE0u8);
        assertAsm(buffer, 0x44u8, 0x0Fu8, 0xBEu8, 0xF8u8);

        assertAsm(buffer, 0x0Fu8, 0xBEu8, 0xC3u8);
        assertAsm(buffer, 0x40u8, 0x0Fu8, 0xBEu8, 0xC4u8);
        assertAsm(buffer, 0x40u8, 0x0Fu8, 0xBEu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsxbl_ra() {
        let asm = AssemblerX64::new();
        asm.movsxbl_ra(RAX, Address::offset(RAX, 0i32));
        asm.movsxbl_ra(R8, Address::offset(RAX, 0i32));
        asm.movsxbl_ra(RSP, Address::offset(RAX, 0i32));
        asm.movsxbl_ra(RDI, Address::offset(RAX, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0xBEu8, 0x00u8);
        assertAsm(buffer, 0x44u8, 0x0Fu8, 0xBEu8, 0x00u8);
        assertAsm(buffer, 0x0Fu8, 0xBEu8, 0x20u8);
        assertAsm(buffer, 0x0Fu8, 0xBEu8, 0x38u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn novsxbq_rr() {
        let asm = AssemblerX64::new();
        asm.movsxbq_rr(RAX, RAX);
        asm.movsxbq_rr(RAX, R8);
        asm.movsxbq_rr(RSP, RAX);
        asm.movsxbq_rr(R15, RAX);

        asm.movsxbq_rr(RAX, RBX);
        asm.movsxbq_rr(RAX, RSP);
        asm.movsxbq_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0xC0u8);
        assertAsm(buffer, 0x49u8, 0x0Fu8, 0xBEu8, 0xC0u8);
        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0xE0u8);
        assertAsm(buffer, 0x4Cu8, 0x0Fu8, 0xBEu8, 0xF8u8);

        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0xC3u8);
        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0xC4u8);
        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsxbq_ra() {
        let asm = AssemblerX64::new();
        asm.movsxbq_ra(RAX, Address::offset(RAX, 0i32));
        asm.movsxbq_ra(R8, Address::offset(RAX, 0i32));
        asm.movsxbq_ra(RSP, Address::offset(RAX, 0i32));
        asm.movsxbq_ra(RDI, Address::offset(RAX, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0x00u8);
        assertAsm(buffer, 0x4Cu8, 0x0Fu8, 0xBEu8, 0x00u8);
        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0x20u8);
        assertAsm(buffer, 0x48u8, 0x0Fu8, 0xBEu8, 0x38u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsxlq_rr() {
        let asm = AssemblerX64::new();
        asm.movsxlq_rr(R15, RAX);
        asm.movsxlq_rr(RAX, R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x4Cu8, 0x63u8, 0xF8u8);
        assertAsm(buffer, 0x49u8, 0x63u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movss_rr() {
        let asm = AssemblerX64::new();
        asm.movss_rr(XMM0, XMM1);
        asm.movss_rr(XMM8, XMM1);
        asm.movss_rr(XMM0, XMM9);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x10u8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x10u8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x10u8, 0xC1u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movss_ra() {
        let asm = AssemblerX64::new();
        asm.movss_ra(XMM0, Address::offset(RAX, 0i32));
        asm.movss_ra(XMM8, Address::offset(RAX, 0i32));

        asm.movss_ra(XMM0, Address::offset(R8, 0i32));
        asm.movss_ra(XMM8, Address::offset(R15, 0i32));

        asm.movss_ra(XMM9, Address::offset(RAX, 0i32));
        asm.movss_ra(XMM15, Address::offset(RAX, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x10u8, 0x00u8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x10u8, 0x00u8);

        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x10u8, 0x00u8);
        assertAsm(buffer, 0xF3u8, 0x45u8, 0x0Fu8, 0x10u8, 0x07u8);

        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x10u8, 0x08u8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x10u8, 0x38u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movss_ar() {
        let asm = AssemblerX64::new();
        asm.movss_ar(Address::offset(RAX, 0i32), XMM0);
        asm.movss_ar(Address::offset(RAX, 0i32), XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x11u8, 0x00u8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x11u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsd_rr() {
        let asm = AssemblerX64::new();
        asm.movsd_rr(XMM0, XMM1);
        asm.movsd_rr(XMM8, XMM1);
        asm.movsd_rr(XMM0, XMM9);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x10u8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x10u8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x10u8, 0xC1u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsd_ra() {
        let asm = AssemblerX64::new();
        asm.movsd_ra(XMM0, Address::offset(RAX, 0i32));
        asm.movsd_ra(XMM8, Address::offset(RAX, 0i32));

        asm.movsd_ra(XMM0, Address::offset(R8, 0i32));
        asm.movsd_ra(XMM8, Address::offset(R15, 0i32));

        asm.movsd_ra(XMM9, Address::offset(RAX, 0i32));
        asm.movsd_ra(XMM15, Address::offset(RAX, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x10u8, 0x00u8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x10u8, 0x00u8);

        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x10u8, 0x00u8);
        assertAsm(buffer, 0xF2u8, 0x45u8, 0x0Fu8, 0x10u8, 0x07u8);

        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x10u8, 0x08u8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x10u8, 0x38u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movsd_ar() {
        let asm = AssemblerX64::new();
        asm.movsd_ar(Address::offset(RAX, 0i32), XMM0);
        asm.movsd_ar(Address::offset(RAX, 0i32), XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x11u8, 0x00u8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x11u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn addss_rr() {
        let asm = AssemblerX64::new();
        asm.addss_rr(XMM0, XMM1);
        asm.addss_rr(XMM3, XMM15);
        asm.addss_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x58u8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x58u8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x58u8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn addsd_rr() {
        let asm = AssemblerX64::new();
        asm.addsd_rr(XMM0, XMM1);
        asm.addsd_rr(XMM3, XMM15);
        asm.addsd_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x58u8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x58u8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x58u8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn subss_rr() {
        let asm = AssemblerX64::new();
        asm.subss_rr(XMM0, XMM1);
        asm.subss_rr(XMM3, XMM15);
        asm.subss_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x5Cu8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x5Cu8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x5Cu8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn subsd_rr() {
        let asm = AssemblerX64::new();
        asm.subsd_rr(XMM0, XMM1);
        asm.subsd_rr(XMM3, XMM15);
        asm.subsd_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x5Cu8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x5Cu8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x5Cu8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn mulss_rr() {
        let asm = AssemblerX64::new();
        asm.mulss_rr(XMM0, XMM1);
        asm.mulss_rr(XMM3, XMM15);
        asm.mulss_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x59u8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x59u8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x59u8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn mulsd_rr() {
        let asm = AssemblerX64::new();
        asm.mulsd_rr(XMM0, XMM1);
        asm.mulsd_rr(XMM3, XMM15);
        asm.mulsd_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x59u8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x59u8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x59u8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn divss_rr() {
        let asm = AssemblerX64::new();
        asm.divss_rr(XMM0, XMM1);
        asm.divss_rr(XMM3, XMM15);
        asm.divss_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x5Eu8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x5Eu8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x5Eu8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn divsd_rr() {
        let asm = AssemblerX64::new();
        asm.divsd_rr(XMM0, XMM1);
        asm.divsd_rr(XMM3, XMM15);
        asm.divsd_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x5Eu8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x5Eu8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x5Eu8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn ucomiss_rr() {
        let asm = AssemblerX64::new();
        asm.ucomiss_rr(XMM1, XMM0);
        asm.ucomiss_rr(XMM15, XMM3);
        asm.ucomiss_rr(XMM4, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0x2Eu8, 0xC8u8);
        assertAsm(buffer, 0x44u8, 0x0Fu8, 0x2Eu8, 0xFBu8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0x2Eu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn ucomisd_rr() {
        let asm = AssemblerX64::new();
        asm.ucomisd_rr(XMM1, XMM0);
        asm.ucomisd_rr(XMM15, XMM3);
        asm.ucomisd_rr(XMM4, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x0Fu8, 0x2Eu8, 0xC8u8);
        assertAsm(buffer, 0x66u8, 0x44u8, 0x0Fu8, 0x2Eu8, 0xFBu8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x2Eu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn pxor_rr() {
        let asm = AssemblerX64::new();
        asm.pxor_rr(XMM1, XMM0);
        asm.pxor_rr(XMM15, XMM3);
        asm.pxor_rr(XMM4, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x0Fu8, 0xEFu8, 0xC8u8);
        assertAsm(buffer, 0x66u8, 0x44u8, 0x0Fu8, 0xEFu8, 0xFBu8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0xEFu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn sqrtss_rr() {
        let asm = AssemblerX64::new();
        asm.sqrtss_rr(XMM1, XMM0);
        asm.sqrtss_rr(XMM15, XMM3);
        asm.sqrtss_rr(XMM4, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x51u8, 0xC8u8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x51u8, 0xFBu8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x51u8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn sqrtsd_rr() {
        let asm = AssemblerX64::new();
        asm.sqrtsd_rr(XMM1, XMM0);
        asm.sqrtsd_rr(XMM15, XMM3);
        asm.sqrtsd_rr(XMM4, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x51u8, 0xC8u8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x51u8, 0xFBu8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x51u8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn tzcntl_rr() {
        let asm = AssemblerX64::new();
        asm.tzcntl_rr(RDI, RAX);
        asm.tzcntl_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0xBCu8, 0xF8u8);
        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0xBCu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn tzcntq_rr() {
        let asm = AssemblerX64::new();
        asm.tzcntq_rr(RDI, RAX);
        asm.tzcntq_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0xBCu8, 0xF8u8);
        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0xBCu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn lzcntl_rr() {
        let asm = AssemblerX64::new();
        asm.lzcntl_rr(RDI, RAX);
        asm.lzcntl_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0xBDu8, 0xF8u8);
        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0xBDu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn lzcntq_rr() {
        let asm = AssemblerX64::new();
        asm.lzcntq_rr(RDI, RAX);
        asm.lzcntq_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0xBDu8, 0xF8u8);
        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0xBDu8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn popcntl_rr() {
        let asm = AssemblerX64::new();
        asm.popcntl_rr(RDI, RAX);
        asm.popcntl_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0xB8u8, 0xF8u8);
        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0xB8u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn popcntq_rr() {
        let asm = AssemblerX64::new();
        asm.popcntq_rr(RDI, RAX);
        asm.popcntq_rr(RAX, RDI);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0xB8u8, 0xF8u8);
        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0xB8u8, 0xC7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvtss2sd_rr() {
        let asm = AssemblerX64::new();
        asm.cvtss2sd_rr(XMM0, XMM1);
        asm.cvtss2sd_rr(XMM3, XMM15);
        asm.cvtss2sd_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x5Au8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x5Au8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x5Au8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvtsd2ss_rr() {
        let asm = AssemblerX64::new();
        asm.cvtsd2ss_rr(XMM0, XMM1);
        asm.cvtsd2ss_rr(XMM3, XMM15);
        asm.cvtsd2ss_rr(XMM8, XMM4);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x5Au8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x5Au8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x5Au8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movd_rx() {
        let asm = AssemblerX64::new();
        asm.movd_rx(RDI, XMM0);
        asm.movd_rx(R8, XMM0);
        asm.movd_rx(R8, XMM7);
        asm.movd_rx(R8, XMM8);
        asm.movd_rx(R8, XMM15);
        asm.movd_rx(R15, XMM0);
        asm.movd_rx(R15, XMM7);
        asm.movd_rx(R15, XMM8);
        asm.movd_rx(R15, XMM15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x0Fu8, 0x7Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x7Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x7Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x7Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x7Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x7Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x7Eu8, 0xFFu8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x7Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x7Eu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movd_xr() {
        let asm = AssemblerX64::new();
        asm.movd_xr(XMM0, RAX);
        asm.movd_xr(XMM0, R8);
        asm.movd_xr(XMM7, R8);
        asm.movd_xr(XMM8, R8);
        asm.movd_xr(XMM15, R8);
        asm.movd_xr(XMM0, R15);
        asm.movd_xr(XMM7, R15);
        asm.movd_xr(XMM8, R15);
        asm.movd_xr(XMM15, R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x0Fu8, 0x6Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x6Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x6Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x6Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x6Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x6Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0Fu8, 0x6Eu8, 0xFFu8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x6Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x6Eu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movq_rx() {
        let asm = AssemblerX64::new();
        asm.movq_rx(RDI, XMM0);
        asm.movq_rx(R8, XMM0);
        asm.movq_rx(R8, XMM7);
        asm.movq_rx(R8, XMM8);
        asm.movq_rx(R8, XMM15);
        asm.movq_rx(R15, XMM0);
        asm.movq_rx(R15, XMM7);
        asm.movq_rx(R15, XMM8);
        asm.movq_rx(R15, XMM15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x48u8, 0x0Fu8, 0x7Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x7Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x7Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x7Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x7Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x7Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x7Eu8, 0xFFu8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x7Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x7Eu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn movq_xr() {
        let asm = AssemblerX64::new();
        asm.movq_xr(XMM0, RAX);
        asm.movq_xr(XMM0, R8);
        asm.movq_xr(XMM7, R8);
        asm.movq_xr(XMM8, R8);
        asm.movq_xr(XMM15, R8);
        asm.movq_xr(XMM0, R15);
        asm.movq_xr(XMM7, R15);
        asm.movq_xr(XMM8, R15);
        asm.movq_xr(XMM15, R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x48u8, 0x0Fu8, 0x6Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x6Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x6Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x6Eu8, 0xC0u8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x6Eu8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x6Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x49u8, 0x0Fu8, 0x6Eu8, 0xFFu8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x6Eu8, 0xC7u8);
        assertAsm(buffer, 0x66u8, 0x4Du8, 0x0Fu8, 0x6Eu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn xorps_ra() {
        let asm = AssemblerX64::new();
        asm.xorps_ra(XMM0, Address::offset(RBP, -8i32));
        asm.xorps_ra(XMM8, Address::offset(R8, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0x57u8, 0x45u8, 0xF8u8);
        assertAsm(buffer, 0x45u8, 0x0Fu8, 0x57u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn xorps_rr() {
        let asm = AssemblerX64::new();
        asm.xorps_rr(XMM0, XMM1);
        asm.xorps_rr(XMM7, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0x57u8, 0xC1u8);
        assertAsm(buffer, 0x41u8, 0x0Fu8, 0x57u8, 0xF8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn xorpd_ra() {
        let asm = AssemblerX64::new();
        asm.xorpd_ra(XMM0, Address::offset(RBP, -8i32));
        asm.xorpd_ra(XMM8, Address::offset(R8, 0i32));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x0Fu8, 0x57u8, 0x45u8, 0xF8u8);
        assertAsm(buffer, 0x66u8, 0x45u8, 0x0Fu8, 0x57u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn xorl_ri() {
        let asm = AssemblerX64::new();
        asm.xorl_ri(RAX, Immediate(1i64));
        asm.xorl_ri(R8, Immediate(127i64));
        asm.xorl_ri(R15, Immediate(-128i64));

        asm.xorl_ri(RAX, Immediate(128i64));
        asm.xorl_ri(R8, Immediate(-129i64));
        asm.xorl_ri(R15, Immediate(128i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x83u8, 0xF0u8, 1u8);
        assertAsm(buffer, 0x41u8, 0x83u8, 0xF0u8, 0x7Fu8);
        assertAsm(buffer, 0x41u8, 0x83u8, 0xF7u8, 0x80u8);

        assertAsm(buffer, 0x35u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x41u8, 0x81u8, 0xF0u8, 0x7Fu8, 0xFFu8, 0xFFu8, 0xFFu8);
        assertAsm(buffer, 0x41u8, 0x81u8, 0xF7u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpb_ar() {
        let asm = AssemblerX64::new();
        asm.cmpb_ar(Address::offset(RAX, 0i32), RAX);
        asm.cmpb_ar(Address::offset(RAX, 0i32), RBX);
        asm.cmpb_ar(Address::offset(RAX, 0i32), RSP);
        asm.cmpb_ar(Address::offset(RAX, 0i32), RDI);
        asm.cmpb_ar(Address::offset(RAX, 0i32), R8);
        asm.cmpb_ar(Address::offset(R8, 0i32), RAX);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x38u8, 0x00u8);
        assertAsm(buffer, 0x38u8, 0x18u8);
        assertAsm(buffer, 0x40u8, 0x38u8, 0x20u8);
        assertAsm(buffer, 0x40u8, 0x38u8, 0x38u8);
        assertAsm(buffer, 0x44u8, 0x38u8, 0x00u8);
        assertAsm(buffer, 0x41u8, 0x38u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpb_ai() {
        let asm = AssemblerX64::new();
        asm.cmpb_ai(Address::offset(RAX, 0i32), Immediate(1i64));
        asm.cmpb_ai(Address::offset(RAX, 0i32), Immediate(127i64));
        asm.cmpb_ai(Address::offset(RAX, 0i32), Immediate(-128i64));
        asm.cmpb_ai(Address::offset(RAX, 0i32), Immediate(255i64));
        asm.cmpb_ai(Address::offset(R8, 0i32), Immediate(255i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x80u8, 0x38u8, 1u8);
        assertAsm(buffer, 0x80u8, 0x38u8, 0x7Fu8);
        assertAsm(buffer, 0x80u8, 0x38u8, 0x80u8);
        assertAsm(buffer, 0x80u8, 0x38u8, 0xFFu8);
        assertAsm(buffer, 0x41u8, 0x80u8, 0x38u8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpl_ri() {
        let asm = AssemblerX64::new();
        asm.cmpl_ri(RAX, Immediate(0i64));
        asm.cmpl_ri(R15, Immediate(0i64));
        asm.cmpl_ri(R9, Immediate(0i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x83u8, 0xF8u8, 0u8);
        assertAsm(buffer, 0x41u8, 0x83u8, 0xFFu8, 0u8);
        assertAsm(buffer, 0x41u8, 0x83u8, 0xF9u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpl_ai() {
        let asm = AssemblerX64::new();
        asm.cmpl_ai(Address::offset(RAX, 0i32), Immediate(127i64));
        asm.cmpl_ai(Address::offset(RAX, 0i32), Immediate(-128i64));
        asm.cmpl_ai(Address::offset(RAX, 0i32), Immediate(128i64));
        asm.cmpl_ai(Address::offset(R8, 0i32), Immediate(128i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x83u8, 0x38u8, 0x7Fu8);
        assertAsm(buffer, 0x83u8, 0x38u8, 0x80u8);
        assertAsm(buffer, 0x81u8, 0x38u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x41u8, 0x81u8, 0x38u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpl_ar() {
        let asm = AssemblerX64::new();
        asm.cmpl_ar(Address::offset(RBX, 1i32), RAX);
        asm.cmpl_ar(Address::offset(RBX, 1i32), R10);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x39u8, 0x43u8, 1u8);
        assertAsm(buffer, 0x44u8, 0x39u8, 0x53u8, 1u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpq_ai() {
        let asm = AssemblerX64::new();
        asm.cmpq_ai(Address::offset(RAX, 0i32), Immediate(127i64));
        asm.cmpq_ai(Address::offset(RAX, 0i32), Immediate(-128i64));
        asm.cmpq_ai(Address::offset(RAX, 0i32), Immediate(128i64));
        asm.cmpq_ai(Address::offset(R8, 0i32), Immediate(128i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x83u8, 0x38u8, 0x7Fu8);
        assertAsm(buffer, 0x48u8, 0x83u8, 0x38u8, 0x80u8);
        assertAsm(buffer, 0x48u8, 0x81u8, 0x38u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x49u8, 0x81u8, 0x38u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpq_ar() {
        let asm = AssemblerX64::new();
        asm.cmpq_ar(Address::offset(RBX, 1i32), RAX);
        asm.cmpq_ar(Address::offset(RBX, 256i32), RAX);
        asm.cmpq_ar(Address::offset(RDI, 1i32), RAX);
        asm.cmpq_ar(Address::offset(R9, 1i32), RAX);
        asm.cmpq_ar(Address::offset(RDI, 1i32), R10);
        asm.cmpq_ar(Address::rip(1i32), RAX);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x39u8, 0x43u8, 1u8);
        assertAsm(buffer, 0x48u8, 0x39u8, 0x83u8, 0u8, 1u8, 0u8, 0u8);
        assertAsm(buffer, 0x48u8, 0x39u8, 0x47u8, 1u8);
        assertAsm(buffer, 0x49u8, 0x39u8, 0x41u8, 1u8);
        assertAsm(buffer, 0x4Cu8, 0x39u8, 0x57u8, 1u8);
        assertAsm(buffer, 0x48u8, 0x39u8, 0x05u8, 1u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpq_ri() {
        let asm = AssemblerX64::new();
        asm.cmpq_ri(RAX, Immediate(127i64));
        asm.cmpq_ri(R15, Immediate(-128i64));
        asm.cmpq_ri(R9, Immediate(0i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x83u8, 0xF8u8, 0x7Fu8);
        assertAsm(buffer, 0x49u8, 0x83u8, 0xFFu8, 0x80u8);
        assertAsm(buffer, 0x49u8, 0x83u8, 0xF9u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn notl_r() {
        let asm = AssemblerX64::new();
        asm.notl_r(RAX);
        asm.notl_r(R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF7u8, 0xD0u8);
        assertAsm(buffer, 0x41u8, 0xF7u8, 0xD7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn notq_r() {
        let asm = AssemblerX64::new();
        asm.notq_r(RAX);
        asm.notq_r(R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xF7u8, 0xD0u8);
        assertAsm(buffer, 0x49u8, 0xF7u8, 0xD7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn negl_r() {
        let asm = AssemblerX64::new();
        asm.negl_r(RAX);
        asm.negl_r(R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF7u8, 0xD8u8);
        assertAsm(buffer, 0x41u8, 0xF7u8, 0xDFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn negq_r() {
        let asm = AssemblerX64::new();
        asm.negq_r(RAX);
        asm.negq_r(R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xF7u8, 0xD8u8);
        assertAsm(buffer, 0x49u8, 0xF7u8, 0xDFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn andq_ri() {
        let asm = AssemblerX64::new();
        asm.andq_ri(RAX, Immediate(-8i64));
        asm.andq_ri(RAX, Immediate(128i64));
        asm.andq_ri(R9, Immediate(-8i64));
        asm.andq_ri(R9, Immediate(128i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x83u8, 0xE0u8, 0xF8u8);
        assertAsm(buffer, 0x48u8, 0x25u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsm(buffer, 0x49u8, 0x83u8, 0xE1u8, 0xF8u8);
        assertAsm(buffer, 0x49u8, 0x81u8, 0xE1u8, 0x80u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jmpr() {
        let asm = AssemblerX64::new();
        asm.jmp_r(RAX);
        asm.jmp_r(RDI);
        asm.jmp_r(R8);
        asm.jmp_r(R15);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xFFu8, 0xE0u8);
        assertAsm(buffer, 0xFFu8, 0xE7u8);
        assertAsm(buffer, 0x41u8, 0xFFu8, 0xE0u8);
        assertAsm(buffer, 0x41u8, 0xFFu8, 0xE7u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shrl_ri() {
        let asm = AssemblerX64::new();
        asm.shrl_ri(RAX, Immediate(2i64));
        asm.shrl_ri(R8, Immediate(2i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xC1u8, 0xE8u8, 2u8);
        assertAsm(buffer, 0x41u8, 0xC1u8, 0xE8u8, 2u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shrl_r() {
        let asm = AssemblerX64::new();
        asm.shrl_r(RAX);
        asm.shrl_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xD3u8, 0xE8u8);
        assertAsm(buffer, 0x41u8, 0xD3u8, 0xE8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shrq_ri() {
        let asm = AssemblerX64::new();
        asm.shrq_ri(RAX, Immediate(2i64));
        asm.shrq_ri(R8, Immediate(2i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xC1u8, 0xE8u8, 2u8);
        assertAsm(buffer, 0x49u8, 0xC1u8, 0xE8u8, 2u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shrq_r() {
        let asm = AssemblerX64::new();
        asm.shrq_r(RAX);
        asm.shrq_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xD3u8, 0xE8u8);
        assertAsm(buffer, 0x49u8, 0xD3u8, 0xE8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn sarl_ri() {
        let asm = AssemblerX64::new();
        asm.sarl_ri(RAX, Immediate(2i64));
        asm.sarl_ri(R8, Immediate(2i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xC1u8, 0xF8u8, 2u8);
        assertAsm(buffer, 0x41u8, 0xC1u8, 0xF8u8, 2u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn sarl_r() {
        let asm = AssemblerX64::new();
        asm.sarl_r(RAX);
        asm.sarl_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xD3u8, 0xF8u8);
        assertAsm(buffer, 0x41u8, 0xD3u8, 0xF8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn sarq_ri() {
        let asm = AssemblerX64::new();
        asm.sarq_ri(RAX, Immediate(2i64));
        asm.sarq_ri(R8, Immediate(2i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xC1u8, 0xF8u8, 2u8);
        assertAsm(buffer, 0x49u8, 0xC1u8, 0xF8u8, 2u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn sarq_r() {
        let asm = AssemblerX64::new();
        asm.sarq_r(RAX);
        asm.sarq_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xD3u8, 0xF8u8);
        assertAsm(buffer, 0x49u8, 0xD3u8, 0xF8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shll_ri() {
        let asm = AssemblerX64::new();
        asm.shll_ri(RAX, Immediate(2i64));
        asm.shll_ri(R8, Immediate(2i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xC1u8, 0xE0u8, 2u8);
        assertAsm(buffer, 0x41u8, 0xC1u8, 0xE0u8, 2u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shll_r() {
        let asm = AssemblerX64::new();
        asm.shll_r(RAX);
        asm.shll_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xD3u8, 0xE0u8);
        assertAsm(buffer, 0x41u8, 0xD3u8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shlq_ri() {
        let asm = AssemblerX64::new();
        asm.shlq_ri(RAX, Immediate(2i64));
        asm.shlq_ri(R8, Immediate(2i64));

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xC1u8, 0xE0u8, 2u8);
        assertAsm(buffer, 0x49u8, 0xC1u8, 0xE0u8, 2u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn shlq_r() {
        let asm = AssemblerX64::new();
        asm.shlq_r(RAX);
        asm.shlq_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xD3u8, 0xE0u8);
        assertAsm(buffer, 0x49u8, 0xD3u8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn roll_r() {
        let asm = AssemblerX64::new();
        asm.roll_r(RAX);
        asm.roll_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xD3u8, 0xC0u8);
        assertAsm(buffer, 0x41u8, 0xD3u8, 0xC0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn rolq_r() {
        let asm = AssemblerX64::new();
        asm.rolq_r(RAX);
        asm.rolq_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xD3u8, 0xC0u8);
        assertAsm(buffer, 0x49u8, 0xD3u8, 0xC0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn rorl_r() {
        let asm = AssemblerX64::new();
        asm.rorl_r(RAX);
        asm.rorl_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xD3u8, 0xC8u8);
        assertAsm(buffer, 0x41u8, 0xD3u8, 0xC8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn rorq_r() {
        let asm = AssemblerX64::new();
        asm.rorq_r(RAX);
        asm.rorq_r(R8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0xD3u8, 0xC8u8);
        assertAsm(buffer, 0x49u8, 0xD3u8, 0xC8u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvtsi2ssd_rr() {
        let asm = AssemblerX64::new();
        asm.cvtsi2ssd_rr(XMM0, RCX);
        asm.cvtsi2ssd_rr(XMM3, R15);
        asm.cvtsi2ssd_rr(XMM8, RSP);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x2Au8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x2Au8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x2Au8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvtsi2ssq_rr() {
        let asm = AssemblerX64::new();
        asm.cvtsi2ssq_rr(XMM0, RCX);
        asm.cvtsi2ssq_rr(XMM3, R15);
        asm.cvtsi2ssq_rr(XMM8, RSP);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0x2Au8, 0xC1u8);
        assertAsm(buffer, 0xF3u8, 0x49u8, 0x0Fu8, 0x2Au8, 0xDFu8);
        assertAsm(buffer, 0xF3u8, 0x4Cu8, 0x0Fu8, 0x2Au8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvtsi2sdd_rr() {
        let asm = AssemblerX64::new();
        asm.cvtsi2sdd_rr(XMM0, RCX);
        asm.cvtsi2sdd_rr(XMM3, R15);
        asm.cvtsi2sdd_rr(XMM8, RSP);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x2Au8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x2Au8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x2Au8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvtsi2sdq_rr() {
        let asm = AssemblerX64::new();
        asm.cvtsi2sdq_rr(XMM0, RCX);
        asm.cvtsi2sdq_rr(XMM3, R15);
        asm.cvtsi2sdq_rr(XMM8, RSP);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x48u8, 0x0Fu8, 0x2Au8, 0xC1u8);
        assertAsm(buffer, 0xF2u8, 0x49u8, 0x0Fu8, 0x2Au8, 0xDFu8);
        assertAsm(buffer, 0xF2u8, 0x4Cu8, 0x0Fu8, 0x2Au8, 0xC4u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvttss2sid_rr() {
        let asm = AssemblerX64::new();
        asm.cvttss2sid_rr(RCX, XMM0);
        asm.cvttss2sid_rr(R15, XMM3);
        asm.cvttss2sid_rr(RSP, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x0Fu8, 0x2Cu8, 0xC8u8);
        assertAsm(buffer, 0xF3u8, 0x44u8, 0x0Fu8, 0x2Cu8, 0xFBu8);
        assertAsm(buffer, 0xF3u8, 0x41u8, 0x0Fu8, 0x2Cu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvttss2siq_rr() {
        let asm = AssemblerX64::new();
        asm.cvttss2siq_rr(RCX, XMM0);
        asm.cvttss2siq_rr(R15, XMM3);
        asm.cvttss2siq_rr(RSP, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF3u8, 0x48u8, 0x0Fu8, 0x2Cu8, 0xC8u8);
        assertAsm(buffer, 0xF3u8, 0x4Cu8, 0x0Fu8, 0x2Cu8, 0xFBu8);
        assertAsm(buffer, 0xF3u8, 0x49u8, 0x0Fu8, 0x2Cu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvttsd2sid_rr() {
        let asm = AssemblerX64::new();
        asm.cvttsd2sid_rr(RCX, XMM0);
        asm.cvttsd2sid_rr(R15, XMM3);
        asm.cvttsd2sid_rr(RSP, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x0Fu8, 0x2Cu8, 0xC8u8);
        assertAsm(buffer, 0xF2u8, 0x44u8, 0x0Fu8, 0x2Cu8, 0xFBu8);
        assertAsm(buffer, 0xF2u8, 0x41u8, 0x0Fu8, 0x2Cu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn cvttsd2siq_rr() {
        let asm = AssemblerX64::new();
        asm.cvttsd2siq_rr(RCX, XMM0);
        asm.cvttsd2siq_rr(R15, XMM3);
        asm.cvttsd2siq_rr(RSP, XMM8);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF2u8, 0x48u8, 0x0Fu8, 0x2Cu8, 0xC8u8);
        assertAsm(buffer, 0xF2u8, 0x4Cu8, 0x0Fu8, 0x2Cu8, 0xFBu8);
        assertAsm(buffer, 0xF2u8, 0x49u8, 0x0Fu8, 0x2Cu8, 0xE0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn andps_ra() {
        let asm = AssemblerX64::new();
        asm.andps_ra(XMM0, Address::rip(-4i32));
        asm.andps_ra(XMM15, Address::rip(8i32));
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0fu8, 0x54u8, 0x05u8, 0xfcu8, 0xffu8, 0xffu8, 0xffu8); // andps xmm0, xmmword ptr [rip - 4] ## 0x3 <_main+0x3>
        assertAsm(buffer, 0x44u8, 0x0fu8, 0x54u8, 0x3du8, 0x08u8, 0u8, 0u8, 0u8); // andps xmm15, xmmword ptr [rip + 8] ## 0x17 <_main+0x17>
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpxchgq_ar() {
        let asm = AssemblerX64::new();
        asm.cmpxchgq_ar(Address::offset(RAX, 0i32), RDI);
        asm.cmpxchgq_ar(Address::offset(RDI, 0i32), RAX);
        asm.cmpxchgq_ar(Address::offset(R15, 0i32), RDI);
        asm.cmpxchgq_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x0fu8, 0xb1u8, 0x38u8); // cmpxchg qword ptr [rax], rdi
        assertAsm(buffer, 0x48u8, 0x0fu8, 0xb1u8, 0x07u8); // cmpxchg qword ptr [rdi], rax
        assertAsm(buffer, 0x49u8, 0x0fu8, 0xb1u8, 0x3fu8); // cmpxchg qword ptr [r15], rdi
        assertAsm(buffer, 0x4cu8, 0x0fu8, 0xb1u8, 0x3fu8); // cmpxchg qword ptr [rdi], r15
        assertAsmEnd(buffer);
    }

    @Test
    fn lock_cmpxchgq_ar() {
        let asm = AssemblerX64::new();
        asm.lock_cmpxchgq_ar(Address::offset(RAX, 0i32), RDI);
        asm.lock_cmpxchgq_ar(Address::offset(RDI, 0i32), RAX);
        asm.lock_cmpxchgq_ar(Address::offset(R15, 0i32), RDI);
        asm.lock_cmpxchgq_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF0u8, 0x48u8, 0x0fu8, 0xb1u8, 0x38u8); // lock cmpxchg qword ptr [rax], rdi
        assertAsm(buffer, 0xF0u8, 0x48u8, 0x0fu8, 0xb1u8, 0x07u8); // lock cmpxchg qword ptr [rdi], rax
        assertAsm(buffer, 0xF0u8, 0x49u8, 0x0fu8, 0xb1u8, 0x3fu8); // lock cmpxchg qword ptr [r15], rdi
        assertAsm(buffer, 0xF0u8, 0x4cu8, 0x0fu8, 0xb1u8, 0x3fu8); // lock cmpxchg qword ptr [rdi], r15
        assertAsmEnd(buffer);
    }

    @Test
    fn cmpxchgl_ar() {
        let asm = AssemblerX64::new();
        asm.cmpxchgl_ar(Address::offset(RAX, 0i32), RDI);
        asm.cmpxchgl_ar(Address::offset(RDI, 0i32), RAX);
        asm.cmpxchgl_ar(Address::offset(R15, 0i32), RDI);
        asm.cmpxchgl_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0fu8, 0xb1u8, 0x38u8); // cmpxchg dword ptr [rax], edi
        assertAsm(buffer, 0x0fu8, 0xb1u8, 0x07u8); // cmpxchg dword ptr [rdi], eax
        assertAsm(buffer, 0x41u8, 0x0fu8, 0xb1u8, 0x3fu8); // cmpxchg dword ptr [r15], edi
        assertAsm(buffer, 0x44u8, 0x0fu8, 0xb1u8, 0x3fu8); // cmpxchg dword ptr [rdi], r15d
        assertAsmEnd(buffer);
    }

    @Test
    fn lock_cmpxchgl_ar() {
        let asm = AssemblerX64::new();
        asm.lock_cmpxchgl_ar(Address::offset(RAX, 0i32), RDI);
        asm.lock_cmpxchgl_ar(Address::offset(RDI, 0i32), RAX);
        asm.lock_cmpxchgl_ar(Address::offset(R15, 0i32), RDI);
        asm.lock_cmpxchgl_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF0u8, 0x0fu8, 0xb1u8, 0x38u8); // lock cmpxchg dword ptr [rax], edi
        assertAsm(buffer, 0xF0u8, 0x0fu8, 0xb1u8, 0x07u8); // lock cmpxchg dword ptr [rdi], eax
        assertAsm(buffer, 0xF0u8, 0x41u8, 0x0fu8, 0xb1u8, 0x3fu8); // lock cmpxchg dword ptr [r15], edi
        assertAsm(buffer, 0xF0u8, 0x44u8, 0x0fu8, 0xb1u8, 0x3fu8); // lock cmpxchg dword ptr [rdi], r15d
        assertAsmEnd(buffer);
    }

    @Test
    fn xaddl_ar() {
        let asm = AssemblerX64::new();
        asm.xaddl_ar(Address::offset(RAX, 0i32), RDI);
        asm.xaddl_ar(Address::offset(RDI, 0i32), RAX);
        asm.xaddl_ar(Address::offset(R15, 0i32), RDI);
        asm.xaddl_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0fu8, 0xc1u8, 0x38u8); // xadd dword ptr [rax], edi
        assertAsm(buffer, 0x0fu8, 0xc1u8, 0x07u8); // xadd dword ptr [rdi], eax
        assertAsm(buffer, 0x41u8, 0x0fu8, 0xc1u8, 0x3fu8); // xadd dword ptr [r15], edi
        assertAsm(buffer, 0x44u8, 0x0fu8, 0xc1u8, 0x3fu8); // xadd dword ptr [rdi], r15d
        assertAsmEnd(buffer);
    }

    @Test
    fn xaddq_ar() {
        let asm = AssemblerX64::new();
        asm.xaddq_ar(Address::offset(RAX, 0i32), RDI);
        asm.xaddq_ar(Address::offset(RDI, 0i32), RAX);
        asm.xaddq_ar(Address::offset(R15, 0i32), RDI);
        asm.xaddq_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x0fu8, 0xc1u8, 0x38u8); // xadd qword ptr [rax], rdi
        assertAsm(buffer, 0x48u8, 0x0fu8, 0xc1u8, 0x07u8); // xadd qword ptr [rdi], rax
        assertAsm(buffer, 0x49u8, 0x0fu8, 0xc1u8, 0x3fu8); // xadd qword ptr [r15], rdi
        assertAsm(buffer, 0x4cu8, 0x0fu8, 0xc1u8, 0x3fu8); // xadd qword ptr [rdi], r15
        assertAsmEnd(buffer);
    }

    @Test
    fn lock_xaddl_ar() {
        let asm = AssemblerX64::new();
        asm.lock_xaddl_ar(Address::offset(RAX, 0i32), RDI);
        asm.lock_xaddl_ar(Address::offset(RDI, 0i32), RAX);
        asm.lock_xaddl_ar(Address::offset(R15, 0i32), RDI);
        asm.lock_xaddl_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF0u8, 0x0fu8, 0xc1u8, 0x38u8); // lock xadd dword ptr [rax], edi
        assertAsm(buffer, 0xF0u8, 0x0fu8, 0xc1u8, 0x07u8); // lock xadd dword ptr [rdi], eax
        assertAsm(buffer, 0xF0u8, 0x41u8, 0x0fu8, 0xc1u8, 0x3fu8); // lock xadd dword ptr [r15], edi
        assertAsm(buffer, 0xF0u8, 0x44u8, 0x0fu8, 0xc1u8, 0x3fu8); // lock xadd dword ptr [rdi], r15d
        assertAsmEnd(buffer);
    }

    @Test
    fn lock_xaddq_ar() {
        let asm = AssemblerX64::new();
        asm.lock_xaddq_ar(Address::offset(RAX, 0i32), RDI);
        asm.lock_xaddq_ar(Address::offset(RDI, 0i32), RAX);
        asm.lock_xaddq_ar(Address::offset(R15, 0i32), RDI);
        asm.lock_xaddq_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xF0u8, 0x48u8, 0x0fu8, 0xc1u8, 0x38u8); // lock xadd qword ptr [rax], rdi
        assertAsm(buffer, 0xF0u8, 0x48u8, 0x0fu8, 0xc1u8, 0x07u8); // lock xadd qword ptr [rdi], rax
        assertAsm(buffer, 0xF0u8, 0x49u8, 0x0fu8, 0xc1u8, 0x3fu8); // lock xadd qword ptr [r15], rdi
        assertAsm(buffer, 0xF0u8, 0x4cu8, 0x0fu8, 0xc1u8, 0x3fu8); // lock xadd qword ptr [rdi], r15
        assertAsmEnd(buffer);
    }

    @Test
    fn test_movb_ra() {
        let asm = AssemblerX64::new();
        asm.movb_ra(RAX, Address::offset(RSP, 0i32));
        asm.movb_ra(RSI, Address::offset(RSP, 0i32));
        asm.movb_ra(R8, Address::offset(RSP, 0i32));
        let buffer = asm.finalizeTesting();
    
        assertAsm(buffer, 0x8au8, 0x04u8, 0x24u8); // mov al, byte ptr [rsp]
        assertAsm(buffer, 0x40u8, 0x8au8, 0x34u8, 0x24u8); // mov sil, byte ptr [rsp]
        assertAsm(buffer, 0x44u8, 0x8au8, 0x04u8, 0x24u8); // mov r8b, byte ptr [rsp]
        assertAsmEnd(buffer);
    }

    @Test
    fn test_roundss_ri() {
        let asm = AssemblerX64::new();
        asm.roundss_ri(XMM0, XMM15, 8u8);
        asm.roundss_ri(XMM7, XMM8, 9u8);
        asm.roundss_ri(XMM8, XMM7, 10u8);
        asm.roundss_ri(XMM15, XMM0, 11u8);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x41u8, 0x0fu8, 0x3au8, 0x0au8, 0xc7u8, 0x08u8); // roundss xmm0, xmm15, 8
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0fu8, 0x3au8, 0x0au8, 0xf8u8, 0x09u8); // roundss xmm7, xmm8, 9
        assertAsm(buffer, 0x66u8, 0x44u8, 0x0fu8, 0x3au8, 0x0au8, 0xc7u8, 0x0au8); // roundss xmm8, xmm7, 10
        assertAsm(buffer, 0x66u8, 0x44u8, 0x0fu8, 0x3au8, 0x0au8, 0xf8u8, 0x0bu8); // roundss xmm15, xmm0, 11
        assertAsmEnd(buffer);
    }

    @Test
    fn test_roundsd_ri() {
        let asm = AssemblerX64::new();
        asm.roundsd_ri(XMM0, XMM15, 8u8);
        asm.roundsd_ri(XMM7, XMM8, 9u8);
        asm.roundsd_ri(XMM8, XMM7, 10u8);
        asm.roundsd_ri(XMM15, XMM0, 11u8);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x66u8, 0x41u8, 0x0fu8, 0x3au8, 0x0bu8, 0xc7u8, 0x08u8); // roundsd xmm0, xmm15, 8
        assertAsm(buffer, 0x66u8, 0x41u8, 0x0fu8, 0x3au8, 0x0bu8, 0xf8u8, 0x09u8); // roundsd xmm7, xmm8, 9
        assertAsm(buffer, 0x66u8, 0x44u8, 0x0fu8, 0x3au8, 0x0bu8, 0xc7u8, 0x0au8); // roundsd xmm8, xmm7, 10
        assertAsm(buffer, 0x66u8, 0x44u8, 0x0fu8, 0x3au8, 0x0bu8, 0xf8u8, 0x0bu8); // roundsd xmm15, xmm0, 11
        assertAsmEnd(buffer);
    }

    @Test
    fn xchgq_ar() {
        let asm = AssemblerX64::new();
        asm.xchgq_ar(Address::offset(RAX, 0i32), RDI);
        asm.xchgq_ar(Address::offset(RDI, 0i32), RAX);
        asm.xchgq_ar(Address::offset(R15, 0i32), RDI);
        asm.xchgq_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x48u8, 0x87u8, 0x38u8); // xchg qword ptr [rax], rdi
        assertAsm(buffer, 0x48u8, 0x87u8, 0x07u8); // xchg qword ptr [rdi], rax
        assertAsm(buffer, 0x49u8, 0x87u8, 0x3fu8); // xchg qword ptr [r15], rdi
        assertAsm(buffer, 0x4cu8, 0x87u8, 0x3fu8); // xchg qword ptr [rdi], r15
        assertAsmEnd(buffer);
    }

    @Test
    fn xchgl_ar() {
        let asm = AssemblerX64::new();
        asm.xchgl_ar(Address::offset(RAX, 0i32), RDI);
        asm.xchgl_ar(Address::offset(RDI, 0i32), RAX);
        asm.xchgl_ar(Address::offset(R15, 0i32), RDI);
        asm.xchgl_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x87u8, 0x38u8); // xchg dword ptr [rax], edi
        assertAsm(buffer, 0x87u8, 0x07u8); // xchg dword ptr [rdi], eax
        assertAsm(buffer, 0x41u8, 0x87u8, 0x3fu8); // xchg dword ptr [r15], edi
        assertAsm(buffer, 0x44u8, 0x87u8, 0x3fu8); // xchg dword ptr [rdi], r15d
        assertAsmEnd(buffer);
    }

    @Test
    fn xchgb_ar() {
        let asm = AssemblerX64::new();
        asm.xchgb_ar(Address::offset(RAX, 0i32), RDI);
        asm.xchgb_ar(Address::offset(RDI, 0i32), RAX);
        asm.xchgb_ar(Address::offset(R15, 0i32), RDI);
        asm.xchgb_ar(Address::offset(RDI, 0i32), R15);
        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x40u8, 0x86u8, 0x38u8); // xchg byte ptr [rax], dil
        assertAsm(buffer, 0x86u8, 0x07u8); // xchg byte ptr [rdi], al
        assertAsm(buffer, 0x41u8, 0x86u8, 0x3fu8); // xchg byte ptr [r15], dil
        assertAsm(buffer, 0x44u8, 0x86u8, 0x3fu8); // xchg byte ptr [rdi], r15b
        assertAsmEnd(buffer);
    }

    @Test
    fn jmp_backward_near() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        asm.jmp(lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xEBu8, 0xFEu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jmp_backward_still_near() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        for x in std::range(0i32, 126i32) {
            asm.nop();
        }
        asm.jmp(lbl);

        let buffer = asm.finalizeTesting();

        assertAsmNop(buffer, 126i64);
        assertAsm(buffer, 0xEBu8, 0x80u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jmp_backward_already_far() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        for x in std::range(0i32, 127i32) {
            asm.nop();
        }
        asm.jmp(lbl);

        let buffer = asm.finalizeTesting();

        assertAsmNop(buffer, 127i64);
        assertAsm(buffer, 0xE9u8, 0x7Cu8, 0xFFu8, 0xFFu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jmp_forward() {
        let asm = AssemblerX64::new();
        let lbl = asm.createLabel();
        asm.jmp(lbl);
        asm.bindLabel(lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xE9u8, 0u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jmp_near_forward() {
        let asm = AssemblerX64::new();
        let lbl = asm.createLabel();
        asm.jmp_near(lbl);
        asm.bindLabel(lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xEBu8, 0u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jmp_near_backward() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        asm.jmp_near(lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0xEBu8, 0xFEu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jcc_near_backward() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        asm.jcc_near(Condition::Overflow, lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x70u8, 0xFEu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jcc_near_forward() {
        let asm = AssemblerX64::new();
        let lbl = asm.createLabel();
        asm.jcc_near(Condition::Overflow, lbl);
        asm.bindLabel(lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x70u8, 0x00u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jcc_backward_near() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        asm.jcc(Condition::Overflow, lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x70u8, 0xFEu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jcc_backward_still_near() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        for x in std::range(0i32, 126i32) {
            asm.nop();
        }
        asm.jcc(Condition::Overflow, lbl);

        let buffer = asm.finalizeTesting();

        assertAsmNop(buffer, 126i64);
        assertAsm(buffer, 0x70u8, 0x80u8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jcc_backward_already_far() {
        let asm = AssemblerX64::new();
        let lbl = asm.createAndBindLabel();
        for x in std::range(0i32, 127i32) {
            asm.nop();
        }
        asm.jcc(Condition::Overflow, lbl);

        let buffer = asm.finalizeTesting();

        assertAsmNop(buffer, 127i64);
        assertAsm(buffer, 0x0Fu8, 0x80u8, 0x7Bu8, 0xFFu8, 0xFFu8, 0xFFu8);
        assertAsmEnd(buffer);
    }

    @Test
    fn jcc_forward() {
        let asm = AssemblerX64::new();
        let lbl = asm.createLabel();
        asm.jcc(Condition::Overflow, lbl);
        asm.bindLabel(lbl);

        let buffer = asm.finalizeTesting();

        assertAsm(buffer, 0x0Fu8, 0x80u8, 0u8, 0u8, 0u8, 0u8);
        assertAsmEnd(buffer);
    }

    fn assertAsmNop(code: MachineCode, length: Int64) {
        assert(length > 0i64);

        let mut idx = 0i64;
        while idx < length {
            assert(0x90u8 == code.bytes(code.start + idx));
            idx = idx + 1i64;
        }

        code.start = code.start + length;
    }

    fn assertAsm(code: MachineCode, bytes: UInt8...) {
        assert(code.start + bytes.size() <= code.bytes.size());

        for (idx, exp) in bytes.enumerate() {
            let got = code.bytes(code.start + idx);

            if exp != got {
                println("expected ${exp.toStringHex()} at index ${code.start + idx} but got ${got.toStringHex()}");

                let mut i = 0i64;
                print("expected: ");

                while i < bytes.size() {
                    if i > 0i64 { print(", "); }
                    let value = bytes(i);
                    print("${value.toStringHex()}");
                    i = i + 1i64;
                }

                i = 0i64;
                println("");
                print("buffer: ");

                while i < bytes.size() {
                    if i > 0i64 { print(", "); }
                    let value = code.bytes(code.start + i);
                    print("${value.toStringHex()}");
                    i = i + 1i64;
                }
                println("");
            }

            assert(exp == got);
        }

        code.start = code.start + bytes.size();
    }

    fn assertAsmEnd(code: MachineCode) {
        assert(code.start == code.bytes.size());
    }
}
