use package::assembler::{FloatRegister, Register};
use package::codegen::CodeGen;
use package::graph::{Graph, Inst, Location, LocationData, Op, Operand, Policy, StackSlot, Type};
use package::interface::{config, CompilationInfo, PTR_SIZE, Architecture};

pub fn ensureLocationData(graph: Graph, codegen: CodeGen, ci: CompilationInfo): Int32 {
    let argumentLocations = computeArgumentLocations(codegen, ci);

    let annotator = LocationAnnotation(graph, codegen, ci, 0i32, argumentLocations);
    annotator.annotate();
    annotator.maxOutgoingArgsSize
}

class LocationAnnotation {
    graph: Graph,
    codegen: CodeGen,
    ci: CompilationInfo,
    maxOutgoingArgsSize: Int32,
    argumentLocations: Array[Location],
}

impl LocationAnnotation {
    fn annotate() {
        for block in self.graph.insertionOrderIterator() {
            for inst in block.phisIterator() {
                let loc_data = LocationData::new(inst);
                inst.setLocationData(loc_data);
            }

            for inst in block.instructionsIterator() {
                self.annotateInst(inst);
            }
        }
    }

    fn annotateInst(inst: Inst) {
        let loc = LocationData::new(inst);
        inst.setLocationData(loc);
        let arch = config.architecture;

        match inst.op() {
            Op::Arg => {
                let location = self.argumentLocations(inst.getArgIndex().toInt64());

                if inst.getValueType().isAnyFloat() {
                    if location.isFloatRegister() {
                        useOutputFloatRegisterFixed(inst, location.getFloatRegister(), false);
                    } else  {
                        useOutputFloatStack(inst, location);
                    }
                } else {
                    if location.isRegister() {
                        useOutputRegisterFixed(inst, location.getRegister(), false);
                    } else  {
                        useOutputStack(inst, location);
                    }
                }
            },

            Op::TrueConst |
            Op::FalseConst => {
                useOutputRegister(inst, false);
            },

            Op::UInt8Const
            | Op::Int32Const
            | Op::Int64Const
            | Op::StringConst => {
                useOutputRegister(inst, false);
            },

            Op::Float32Const
            | Op::Float64Const => {
                useOutputFloatRegister(inst, false);
            },

            Op::DivZeroCheck => {
                useInputRegister(inst, 0);
            },

            Op::Greater
            | Op::GreaterOrEqual
            | Op::Less
            | Op::LessOrEqual
            | Op::Equal
            | Op::NotEqual => {
                if inst.getOperationType().isAnyFloat() {
                    useInputFloatRegister(inst, 0);
                    useInputFloatRegister(inst, 1);
                } else {
                    useInputRegister(inst, 0);
                    useInputRegister(inst, 1);
                }

                useOutputRegister(inst, true);
            },

            Op::CheckedAdd => {
                self.codegen.setLocationConstraintsCheckedAdd(inst, loc);
            },

            Op::CheckedSub => {
                self.codegen.setLocationConstraintsCheckedSub(inst, loc);
            },

            Op::CheckedMul => {
                self.codegen.setLocationConstraintsCheckedMul(inst, loc);
            },

            Op::Add
            | Op::Sub
            | Op::Mul
            | Op::Div => {
                if inst.getValueType().isAnyFloat() {
                    useInputFloatRegister(inst, 0);
                    useInputFloatRegister(inst, 1);
                    useOutputFloatRegister(inst, true);
                } else {
                    useInputRegister(inst, 0);
                    useInputRegister(inst, 1);
                    useOutputRegister(inst, true);
                }
            },

            Op::CheckedDiv => {
                self.codegen.setLocationConstraintsCheckedDiv(inst, loc);
            },

            Op::CheckedMod => {
                self.codegen.setLocationConstraintsCheckedMod(inst, loc);
            },

            Op::Neg | Op::CheckedNeg => {
                if inst.getValueType().isAnyFloat() {
                    useInputFloatRegister(inst, 0);
                    useOutputFloatRegister(inst, true);
                } else {
                    useInputRegister(inst, 0);
                    useOutputRegister(inst, true);
                }
            },

            Op::If => {
                useInputRegister(inst, 0);
            },

            Op::Goto => {},

            Op::Return => {
                self.codegen.setLocationConstraintsReturn(inst, loc);
            },

            Op::InvokeStatic
            | Op::InvokeDirect
            | Op::InvokeVirtual
            | Op::InvokeLambda
            => {
                let outgoingArgsSize = annotateCall(inst, loc, self.codegen, self.ci);
                self.maxOutgoingArgsSize = Int32::max(self.maxOutgoingArgsSize, outgoingArgsSize);
            },

            Op::LoadField => {
                useInputRegister(inst, 0);

                if inst.getValueType().isAnyFloat() {
                    useOutputFloatRegister(inst, true);
                } else {
                    useOutputRegister(inst, true);
                }
            },

            Op::StoreField => {
                useInputRegister(inst, 0);

                if inst.getOperationType().isAnyFloat() {
                    useInputFloatRegister(inst, 1);
                } else {
                    useInputRegister(inst, 1);
                }

                setOutputOverlaps(inst, false);
            },

            Op::ArrayLength => {
                useInputRegister(inst, 0);
                useOutputRegister(inst, true);
            },

            Op::BoundsCheck => {
                useInputRegister(inst, 0);
                useInputRegister(inst, 1);
            },

            Op::LoadArray => {
                useInputRegister(inst, 0);
                useInputRegister(inst, 1);

                if inst.getValueType().isAnyFloat() {
                    useOutputFloatRegister(inst, true);
                } else {
                    useOutputRegister(inst, true);
                }

                setOutputOverlaps(inst, false);
            },

            Op::StoreArray => {
                useInputRegister(inst, 0);
                useInputRegister(inst, 1);

                if inst.getOperationType().isAnyFloat() {
                    useInputFloatRegister(inst, 2);
                } else {
                    useInputRegister(inst, 2);
                }

                setOutputOverlaps(inst, false);
            },

            Op::NewObject | Op::NewLambda => {
                addTempRegister(inst);
                useOutputRegister(inst, true);
            },

            Op::LoadGlobal => {
                if inst.getOperationType().isAnyFloat() {
                    useOutputFloatRegister(inst,  false);
                } else {
                    useOutputRegister(inst,  false);
                }
            },

            Op::EnsureGlobalInitialized => {
                addTempRegister(inst);
                setOutputOverlaps(inst, false);
            },

            Op::StoreGlobal => {
                if inst.getOperationType().isAnyFloat() {
                    useInputFloatRegister(inst, 0);
                } else {
                    useInputRegister(inst, 0);
                }
            },

            Op::MarkGlobalInitialized => {
                if config.architecture == Architecture::Arm64 {
                    addTempRegister(inst);
                }
            },

            Op::ThreadCurrent => {
                useOutputRegister(inst, false);
            },

            _ => {
                println("unsupported op ${inst.op().name()}");
                unreachable[()]();
            }
        }
    }
}

fn computeArgumentLocations(codegen: CodeGen, ci: CompilationInfo): Array[Location] {
    let arguments = ci.bc.arguments.toInt64();
    let locations = Array[Location]::fill(arguments, Location::None);
    let mut gp_idx = 0;
    let mut fp_idx = 0;
    let mut next_fp_offset = PTR_SIZE * 2i32;

    let gp_argument_registers = codegen.argumentRegisters();
    let fp_argument_registers = codegen.argumentFloatRegisters();

    for idx in std::range(0, arguments) {
        let ty = ci.bc.registers(idx);
        let ty = ty.specialize(ci.typeParams);
        let ty = Type::fromBytecodeType(ty);

        if ty.isAnyFloat() {
            if fp_idx < fp_argument_registers.size() {
                locations(idx) = fp_argument_registers(fp_idx).toLocation();
            } else {
                locations(idx) = Location::fp(next_fp_offset);
                next_fp_offset = next_fp_offset + PTR_SIZE;
            }
            fp_idx = fp_idx + 1;
        } else {
            if gp_idx < gp_argument_registers.size() {
                locations(idx) = gp_argument_registers(gp_idx).toLocation();
            } else {
                locations(idx) = Location::fp(next_fp_offset);
                next_fp_offset = next_fp_offset + PTR_SIZE;
            }

            gp_idx = gp_idx + 1;
        }
    }


    locations
}

fn annotateCall(inst: Inst, loc: LocationData, codegen: CodeGen, ci: CompilationInfo): Int32 {
    let mut idx = 0;
    let mut gp_idx = 0;
    let mut fp_idx = 0;
    let mut next_sp_offset: Int32 = 0;

    let gp_regs = codegen.argumentRegisters();
    let fp_regs = codegen.argumentFloatRegisters();

    for input in inst.getInputs() {
        if input.getValue().getValueType().isAnyFloat() {
            if fp_idx < fp_regs.size() {
                useInputFloatRegisterFixed(inst, idx, fp_regs(fp_idx));
            } else {
                useInputFloatStack(inst, idx, StackSlot::sp(next_sp_offset));
                next_sp_offset = next_sp_offset + PTR_SIZE;
            }
            fp_idx = fp_idx + 1;
        } else {
            if gp_idx < gp_regs.size() {
                useInputRegisterFixed(inst, idx, gp_regs(gp_idx));
            } else {
                useInputStack(inst, idx, StackSlot::sp(next_sp_offset));
                next_sp_offset = next_sp_offset + PTR_SIZE;
            }
            gp_idx = gp_idx + 1;
        }
        idx = idx + 1;
    }

    if inst.op() == Op::InvokeVirtual || inst.op() == Op::InvokeLambda {
        addTempRegister(inst);
    }

    let ty = inst.getValueType();

    if ty.isUnit() {
        setOutputOverlaps(inst, false);
    } else {
        if ty.isAnyFloat() {
            let reg = codegen.getFloatReturnRegister();
            useOutputFloatRegisterFixed(inst, reg, false);
        } else {
            let reg = codegen.getReturnRegister();
            useOutputRegisterFixed(inst, reg, false);
        }
    }

    next_sp_offset
}

pub fn useOutputRegister(inst: Inst, overlaps: Bool) {
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::AnyReg, Location::None), overlaps);
}

pub fn useOutputRegisterFixed(inst: Inst, reg: Register, output_overlaps: Bool) {
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::FixedReg, Location::Reg(reg)), output_overlaps);
}

pub fn useOutputFloatRegister(inst: Inst, output_overlaps: Bool) {
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::AnyFloatReg, Location::None), output_overlaps);
}

pub fn useOutputFloatRegisterFixed(inst: Inst, reg: FloatRegister, output_overlaps: Bool) {
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::FixedFloatReg, Location::FloatReg(reg)), output_overlaps);
}

pub fn useInputRegister(inst: Inst, idx: Int64) {
    let loc = inst.getLocationData();
    loc.setInput(idx, Operand::new(Policy::AnyReg, Location::None));
}

pub fn useInputRegisterFixed(inst: Inst, idx: Int64, reg: Register) {
    let loc = inst.getLocationData();
    loc.setInput(idx, Operand::new(Policy::FixedReg, Location::Reg(reg)));
    applyHint(inst.getInput(idx).getValue(), Location::Reg(reg));
}

pub fn useInputFloatRegister(inst: Inst, idx: Int64) {
    let loc = inst.getLocationData();
    loc.setInput(idx, Operand::new(Policy::AnyFloatReg, Location::None));
}

pub fn useInputFloatRegisterFixed(inst: Inst, idx: Int64, reg: FloatRegister) {
    let loc = inst.getLocationData();
    loc.setInput(idx, Operand::new(Policy::FixedFloatReg, Location::FloatReg(reg)));
    applyHint(inst.getInput(idx).getValue(), Location::FloatReg(reg));
}

pub fn useInputStack(inst: Inst, idx: Int64, stack: StackSlot) {
    let loc = inst.getLocationData();
    loc.setInput(idx, Operand::new(Policy::FixedStack, Location::Stack(stack)));
}

pub fn useInputFloatStack(inst: Inst, idx: Int64, stack: StackSlot) {
    let loc = inst.getLocationData();
    loc.setInput(idx, Operand::new(Policy::FixedFloatStack, Location::Stack(stack)));
}

pub fn useOutputSameAsFirstInput(inst: Inst) {
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::SameAsFirstInput, Location::None), true);
}

pub fn useOutputFloatStack(inst: Inst, stack: Location) {
    assert(stack.isStack());
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::FixedFloatStack, stack), true);
}

pub fn useOutputStack(inst: Inst, stack: Location) {
    assert(stack.isStack());
    let loc = inst.getLocationData();
    loc.setOutput(Operand::new(Policy::FixedStack, stack), true);
}

pub fn addTempRegister(inst: Inst) {
    let loc = inst.getLocationData();
    loc.addTemp(Operand::new(Policy::AnyReg, Location::None));
}

pub fn addTempRegisterFixed(inst: Inst, reg: Register) {
    let loc = inst.getLocationData();
    loc.addTemp(Operand::new(Policy::FixedReg, Location::Reg(reg)));
}

pub fn setOutputOverlaps(inst: Inst, overlaps: Bool) {
    let loc = inst.getLocationData();
    loc.setOutputOverlaps(overlaps)
}

fn applyHint(inst: Inst, location: Location) {
    let loc = inst.getLocationData();

    if !loc.getHint().isNone() {
        return;
    }

    loc.setHint(location);
}
