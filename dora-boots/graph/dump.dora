use std::CodepointIterator;
use std::StringBuffer;

use package::assembler::arm64::registerName as registerNameOnArm64;
use package::assembler::x64::registerName as registerNameOnX64;
use package::graph::{Block, Edge, Graph, Input, Inst, Location, LocationData, Op};
use package::interface::Architecture;

pub fn dumpGraph(graph: Graph, architecture: Architecture): String {
    GraphDumper::new(graph, architecture).dump()
}

class GraphDumper {
    graph: Graph,
    architecture: Architecture,
    buffer: StringBuffer,
}

impl GraphDumper {
    static fn new(graph: Graph, architecture: Architecture): GraphDumper {
        GraphDumper(graph, architecture, StringBuffer::new())
    }

    fn dump(): String {
        for block in self.graph.insertionOrderIterator() {
            self.dumpBlock(block);
        }

        self.buffer.toString()
    }

    fn dumpBlock(block: Block) {
        self.buffer.append("@${block.id()}:");

        self.dumpEdgeList(true, block.predecessors);
        self.dumpEdgeList(false, block.successors);
        self.dumpLiveIn(block);

        self.buffer.appendNewline();

        for inst in block.phisIterator() {
            self.dumpInst(inst);
        }

        for inst in block.instructionsIterator() {
            self.dumpInst(inst);
        }
    }

    fn dumpLiveIn(block: Block) {
        if !block.hasLiveIn() {
            return;
        }

        let liveIn = block.getLiveIn();
        self.buffer.append(" liveIn = [");
        let mut first: Bool = true;

        for entry in liveIn {
            if !first {
                self.buffer.append(", ");
            }

            self.buffer.append("%${entry}");
            first = false;
        }

        self.buffer.append("]");
    }

    fn dumpEdgeList(is_pred: Bool, edges: Vec[Edge]) {
        if edges.isEmpty() {
            return;
        }

        let name = if is_pred { "pred" } else { "succ" };
        self.buffer.append(" ${name} = [");
        let mut first: Bool = true;

        for edge in edges {
            if !first {
                self.buffer.append(", ");
            }

            let block = if is_pred {
                edge.source
            } else {
                edge.target
            };
            self.buffer.append("@${block.id()}");

            if edge.isBackward() {
                self.buffer.append(" (BACK)");
            }

            first = false;
        }

        self.buffer.append("]");
    }

    fn dumpInst(inst: Inst) {
        self.buffer.append("  %${inst.id()}: ");
        self.dumpOutputLocation(inst);
        self.buffer.append("${dumpInstName(inst)}");

        if !inst.getInputs().isEmpty() {
            let mut idx = 0;
            self.buffer.append(" ");

            for inp in inst.getInputs() {
                if idx > 0 {
                    self.buffer.append(", ");
                }

                self.buffer.append("%${inp.value.id()}");
                self.dumpInputLocation(inst, idx);
                idx = idx + 1;
            }
        }

        if inst.hasUses() {
            self.buffer.append(" [");
            let mut first = true;

            for input in inst.uses() {
                if !first {
                    self.buffer.append(", ");
                }

                self.buffer.append("%${input.usedBy.id()}");
                first = false;
            }

            self.buffer.append("]");
        }

        self.buffer.appendNewline();
    }

    fn dumpOutputLocation(inst: Inst) {
        if !inst.hasLocationData() {
            return;
        }

        let loc = inst.getLocationData();

        if loc.hasOutput() {
            self.dumpLocation(loc.getOutput());
            self.buffer.append(" <- ");
        }
    }

    fn dumpInputLocation(inst: Inst, idx: Int64) {
        if !inst.hasLocationData() {
            return;
        }

        let loc = inst.getLocationData();
        self.buffer.append(" in ");
        self.dumpLocation(loc.getInput(idx));
    }

    fn dumpLocation(loc: Location) {
        let name = if loc.hasRegister() {
                        let register = loc.getRegister();
                        match self.architecture {
                            Architecture::Arm64 => registerNameOnArm64(register),
                            Architecture::X64 => registerNameOnX64(register),
                        }
                    } else {
                        "XXX"
                    };
        self.buffer.append(name);
    }
}

fn dumpInstName(inst: Inst): String {
    let op = inst.op();
    match op {
        Op::NullConst => "Const.Null",
        Op::TrueConst => "Const.True",
        Op::FalseConst => "Const.False",
        Op::Int32Const => "Const.Int32(#${inst.auxAsInt32()})",
        Op::Int64Const => "Const.Int64(#${inst.auxAsInt64()})",
        Op::Float32Const => "Const.Float32(#${inst.auxAsFloat32()})",
        Op::Float64Const => "Const.Float64(#${inst.auxAsFloat64()})",
        Op::LoadGlobal => "LoadGlobal.${inst.getType()}(${inst.auxAsInt32()})",
        Op::StoreGlobal => "StoreGlobal.${inst.getType()}(${inst.auxAsInt32()})",
        Op::Undef => "Undef",
        Op::BoundsCheck => "BoundsCheck",
        Op::Goto => {
            "Goto(@${inst.getTargetBlock().id()})"
        },
        Op::If => {
            "If(@${inst.getTrueBlock().id()}, @${inst.getFalseBlock().id()})"
        },
        Op::Return => {
            if inst.getType().isUnit() {
                "Ret.Void"
            } else {
                "Ret.${inst.getType()}"
            }
        },
        Op::Neg => "Neg.${inst.getType()}",
        Op::CheckedNeg => "CheckedNeg.${inst.getType()}",
        Op::Not => "Not.${inst.getType()}",
        Op::Add => "Add.${inst.getType()}",
        Op::CheckedAdd => "CheckedAdd.${inst.getType()}",
        Op::Sub => "Sub.${inst.getType()}",
        Op::CheckedSub => "CheckedSub.${inst.getType()}",
        Op::Mul => "Mul.${inst.getType()}",
        Op::CheckedMul => "CheckedMul.${inst.getType()}",
        Op::Div => "Div.${inst.getType()}",
        Op::CheckedDiv => "CheckedDiv.${inst.getType()}",
        Op::Mod => "Mod.${inst.getType()}",
        Op::CheckedMod => "CheckedMod.${inst.getType()}",
        Op::And => "And.${inst.getType()}",
        Op::Or => "Or.${inst.getType()}",
        Op::Xor => "Xor.${inst.getType()}",
        Op::Shl => "Shl.${inst.getType()}",
        Op::Shr => "Shr.${inst.getType()}",
        Op::Sar => "Sar.${inst.getType()}",
        Op::TestIdentity => "TestIdentity.${inst.getType()}",
        Op::Equal => "Equal.${inst.getType()}",
        Op::NotEqual => "NotEqual.${inst.getType()}",
        Op::Greater => "Greater.${inst.getType()}",
        Op::GreaterOrEqual => "GreaterOrEqual.${inst.getType()}",
        Op::Less => "Less.${inst.getType()}",
        Op::LessOrEqual => "LessOrEqual.${inst.getType()}",
        Op::Phi => "Phi",
        Op::DivZeroCheck => "DivZeroCheck",
        Op::ArrayGet => "ArrayGet.${inst.getType()}",
        Op::ArraySet => "ArraySet",
        Op::ArrayLength => "ArrayLength",
        Op::FieldGet => "FieldGet.${inst.getType()}",
        Op::FieldSet => "FieldSet",
        Op::Arg => "Arg.${inst.getType()}(${inst.auxAsInt32()})",
        Op::Move => "Move",
        Op::MoveImmediate => "MoveImmediate",
    }
}

pub fn assertGraph(graph: Graph, output: String) {
    let graphOutput = dumpGraph(graph, Architecture::Arm64);

    if !compareStrings(graphOutput, output) {
        println("got: \"${graphOutput}\"");
        println("expected: \"${output}\"");

        for idx in std::range(0i32, graphOutput.size().toInt32()) {
            let value = graphOutput.getByte(idx.toInt64());
            print("${value.toInt32().toStringHex()} ");
        }

        println("");

        for idx in std::range(0i32, output.size().toInt32()) {
            let value = output.getByte(idx.toInt64());
            print("${value.toInt32().toStringHex()} ");
        }

        println("");

        std::fatalError("output does not match");
    }
}

fn compareStrings(lhs: String, rhs: String): Bool {
    let mut lhs = Output::new(lhs);
    let mut rhs = Output::new(rhs);

    skipWhite(lhs);
    skipWhite(rhs);

    while true {
        if lhs.end() && rhs.end() {
            return true;
        } else if lhs.end() || rhs.end() {
            return false;
        }

        if lhs.current == rhs.current {
            lhs.advance();
            rhs.advance();
            continue;
        }

        if lhs.current == 0xDu8.toChar() && lhs.next == 0xAu8.toChar() {
            lhs.advance();
        }

        if rhs.current == 0xDu8.toChar() && rhs.next == 0xAu8.toChar() {
            rhs.advance();
        }

        if lhs.current != rhs.current {
            return false;
        }

        lhs.advance();
        rhs.advance();
    }

    false
}

class Output {
    iterator: CodepointIterator,
    current: Char,
    next: Char,
}

impl Output {
    static fn new(text: String): Output {
        let output = Output(
            CodepointIterator::new(text),
            '\0',
            '\0',
        );

        output.advance();
        output.advance();

        output
    }

    fn advance() {
        self.current = self.next;
        self.next = self.iterator.next().unwrapOr('\0');
    }

    fn end(): Bool {
        self.current == '\0'
    }
}

fn skipWhite(it: Output) {
    while isWhite(it.current) {
        it.advance();
    }
}

fn isWhite(ch: Char): Bool {
    ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'
}
