use package::codegen::{CodeDescriptor, CommentTable, GcPoint, GcPointTable,   LazyCompilationData, LocationTable};
use package::interface::Address;

pub fn encodeCodeDescriptor(writer: ByteWriter, descriptor: CodeDescriptor) {
    encodeConstPool(writer, descriptor.constPool);
    encodeArrayUInt8(writer, descriptor.code);
    encodeLazyCompilationTable(writer, descriptor.lazyCompilation);
    encodeGcPointTable(writer, descriptor.gcPoints);
    encodeLocationTable(writer, descriptor.locations);
    encodeCommentTable(writer, descriptor.comments);
}

pub fn encodeConstPool(writer: ByteWriter, table: Vec[Address]) {
    writer.emitInt32(table.size().toInt32());

    for value in table {
        writer.emitAddress(value);
    }
}

pub fn encodeArrayUInt8(writer: ByteWriter, array: Array[UInt8]) {
    writer.emitInt32(array.size().toInt32());

    for value in array {
        writer.emitByte(value);
    }
}

pub fn encodeCommentTable(writer: ByteWriter, table: CommentTable) {
    writer.emitInt32(table.size().toInt32());

    for (offset, comment) in table {
        writer.emitInt32(offset);
        encodeString(writer, comment);
    }
}

pub fn encodeLazyCompilationTable(writer: ByteWriter, table: LazyCompilationData) {
    writer.emitInt32(table.size().toInt32());
    assert(table.size() == 0);
}

pub fn encodeGcPointTable(writer: ByteWriter, table: GcPointTable) {
    writer.emitInt32(table.size().toInt32());

    for (offset, gcpoint) in table {
        writer.emitInt32(offset);
        encodeGcPoint(writer, gcpoint);
    }
}

pub fn encodeGcPoint(writer: ByteWriter, table: GcPoint) {
    writer.emitInt32(table.size().toInt32());

    for offset in table {
        writer.emitInt32(offset);
    }
}

pub fn encodeString(writer: ByteWriter, value: String) {
    writer.emitInt32(value.size().toInt32());

    for byte in value.asBytes() {
        writer.emitByte(byte);
    }
}

pub fn encodeLocationTable(writer: ByteWriter, locations: LocationTable) {
    writer.emitInt32(locations.size().toInt32());

    for (offset, location) in locations {
        writer.emitInt32(offset);
        writer.emitInt32(location.line);
        writer.emitInt32(location.column);
    }
}

pub class ByteWriter {
    buffer: Vec[UInt8],
}

impl ByteWriter {
    pub static fn new(): ByteWriter {
        ByteWriter(
            Vec[UInt8]::new(),
        )
    }

    pub fn emitAddress(address: Address) {
        self.emitInt64(address.value);
    }

    pub fn emitInt64(value: Int64) {
        self.emitInt32((value >> 32i32).toInt32());
        self.emitInt32(value.toInt32());
    }

    pub fn emitInt32(value: Int32) {
        self.buffer.push(value.toUInt8());
        self.buffer.push((value >> 8i32).toUInt8());
        self.buffer.push((value >> 16i32).toUInt8());
        self.buffer.push((value >> 24i32).toUInt8());
    }

    pub fn emitByte(value: UInt8) {
        self.buffer.push(value);
    }

    pub fn toArray(): Array[UInt8] {
        self.buffer.toArray()
    }
}
