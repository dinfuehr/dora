use std::collections::VecIter;

use package::bytecode::{BytecodeFunction, BytecodeType, ConstPoolId, FctId, Location};
use package::deserializer::decodeBytecodeFunction;
use package::deserializer::decodeCompilationInfo;
use package::deserializer::decodeConfig;
use package::deserializer::ByteReader;
use package::codegen::x64::CodeGenX64;
use package::codegen::arm64::CodeGenArm64;
use package::compileFunction;
use package::serializer::{ByteWriter, encodeBytecodeTypeArray, encodeCodeDescriptor};

pub const TRAP_DIV0: Int32 = 1i32;
pub const TRAP_ASSERT: Int32 = 2i32;
pub const TRAP_INDEX_OUT_OF_BOUNDS: Int32 = 3i32;
pub const TRAP_NIL: Int32 = 4i32;
pub const TRAP_CAST: Int32 = 5i32;
pub const TRAP_OOM: Int32 = 6i32;
pub const TRAP_STACK_OVERFLOW: Int32 = 7i32;
pub const TRAP_ILLEGAL: Int32 = 8i32;
pub const TRAP_OVERFLOW: Int32 = 9i32;

@internal pub fn getSystemConfig(): Array[UInt8];
@internal pub fn getFunctionAddressRaw(data: Array[UInt8]): Int64;

pub fn getFunctionAddress(fct_id: FctId, type_params: Array[BytecodeType]): Address {
    let writer = ByteWriter::new();
    writer.emitInt32(fct_id.value);
    encodeBytecodeTypeArray(writer, type_params);
    Address(getFunctionAddressRaw(writer.toArray()))
}

pub class Config {
    pub architecture: Architecture,
    pub safepoint_trampoline: Address,
    pub trap_trampoline: Address,
}

pub let config: Config = decodeConfig(getSystemConfig());

pub fn compile(encoded: Array[UInt8]): Array[UInt8] {
    let reader = ByteReader::new(encoded);
    let ci = decodeCompilationInfo(reader);
    assert(!reader.moreBytes());
    let code = compileFunction(ci);
    let writer = ByteWriter::new();
    encodeCodeDescriptor(writer, code);
    writer.toArray()
}

pub struct Address(pub value: Int64)

impl Address {
    pub fn toInt64(): Int64 {
        self.value
    }
}

pub let trap_trampoline: Address = Address(0);

pub class CompilationInfo(
    pub bc: BytecodeFunction,
    pub typeParams: Array[BytecodeType],
    pub loc: Location,
    pub emitDebug: Bool,
    pub emitGraph: Bool,
    pub emitCodeComments: Bool,
)

pub enum Architecture {
    X64,
    Arm64,
}

pub const THREAD_LOCAL_DATA_TLAB_TOP_OFFSET: Int32 = 0;
pub const THREAD_LOCAL_DATA_TLAB_END_OFFSET: Int32 = 8;
pub const THREAD_LOCAL_DATA_STACK_LIMIT_OFFSET: Int32 = 16;
pub const THREAD_LOCAL_DATA_DTN_OFFSET: Int32 = 24;
pub const THREAD_LOCAL_DATA_HANDLE_OFFSET: Int32 = 32;
pub const THREAD_LOCAL_DATA_MARKING_OFFSET: Int32 = 40;
pub const THREAD_LOCAL_DATA_STATE_OFFSET: Int32 = 41;

pub class CodeDescriptor {
    pub constPool: ConstPool,
    pub code: Array[UInt8],
    pub lazyCompilation: LazyCompilationData,
    pub gcPoints: GcPointTable,
    pub locations: LocationTable,
    pub comments: CommentTable,
}

pub class CommentTable {
    entries: Vec[(Int32, String)],
}

impl CommentTable {
    pub static fn new(): CommentTable {
        CommentTable(
            Vec[(Int32, String)]::new(),
        )
    }

    pub fn insert(offset: Int32, comment: String) {
        if self.entries.last().isSome() {
            let last = self.entries.last().getOrPanic();
            assert(last.0 <= offset);
        }

        self.entries.push((offset, comment));
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, String)] {
        self.entries.makeIterator()
    }
}

pub class LocationTable {
    entries: Vec[(Int32, Location)],
}

impl LocationTable {
    pub static fn new(): LocationTable {
        LocationTable(
            Vec[(Int32, Location)]::new(),
        )
    }

    pub fn insert(offset: Int32, location: Location) {
        if self.entries.last().isSome() {
            let last = self.entries.last().getOrPanic();
            assert(last.0 <= offset);
        }

        self.entries.push((offset, location));
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, Location)] {
        self.entries.makeIterator()
    }
}

pub class LazyCompilationData {
    entries: Vec[(Int32, LazyCompilationSite)],
}

impl LazyCompilationData {
    pub static fn new(): LazyCompilationData {
        LazyCompilationData(
            Vec[(Int32, LazyCompilationSite)]::new(),
        )
    }

    pub fn insert(offset: Int32, site: LazyCompilationSite) {
        if self.entries.last().isSome() {
            let last = self.entries.last().getOrPanic();
            assert(last.0 <= offset);
        }

        self.entries.push((offset, site));
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, LazyCompilationSite)] {
        self.entries.makeIterator()
    }
}

pub enum LazyCompilationSite {
    Direct(LazyCompilationSiteDirect),
    Virtual(LazyCompilationSiteVirtual),
    Lambda(LazyCompilationSiteLambda),
}

pub struct LazyCompilationSiteDirect {
    pub fct_id: FctId,
    pub type_params: Array[BytecodeType],
    pub const_pool_offset: Int32,
}

pub struct LazyCompilationSiteVirtual {
    pub receiver_is_first: Bool,
    pub fct_id: FctId,
    pub type_params: Array[BytecodeType],
    pub vtable_index: Int32,
    pub trait_object_ty: BytecodeType,
}

pub struct LazyCompilationSiteLambda {
    pub receiver_is_first: Bool,
    pub params: Array[BytecodeType],
    pub return_ty: BytecodeType,
}

pub class GcPointTable {
    entries: Vec[(Int32, GcPoint)],
}

impl GcPointTable {
    pub static fn new(): GcPointTable {
        GcPointTable(
            Vec[(Int32, GcPoint)]::new(),
        )
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn makeIterator(): VecIter[(Int32, GcPoint)] {
        self.entries.makeIterator()
    }
}

pub class GcPoint {
    offsets: Vec[Int32],
}

impl GcPoint {
    pub fn size(): Int64 {
        self.offsets.size()
    }

    pub fn makeIterator(): VecIter[Int32] {
        self.offsets.makeIterator()
    }
}

pub class ConstPool {
    entries: Vec[ConstPoolEntry],
    size: Int32,
}

impl ConstPool {
    pub static fn new(): ConstPool {
        ConstPool(
            Vec[ConstPoolEntry]::new(),
            0i32,
        )
    }

    pub fn size(): Int64 {
        self.entries.size()
    }

    pub fn push(value: ConstPoolValue): ConstPoolEntry {
        let entry_size = value.size();
        let entry_alignment = entry_size;
        let new_size = (self.size + (entry_alignment - 1i32)) & entry_alignment + entry_size;
        let entry = ConstPoolEntry(new_size, value);
        self.size = new_size;
        self.entries.push(entry);
        entry
    }

    pub fn makeIterator(): VecIter[ConstPoolEntry] {
        self.entries.makeIterator()
    }
}

pub struct ConstPoolEntry {
    pub disp: Int32,
    pub value: ConstPoolValue
}

pub enum ConstPoolValue {
    Address(Address),
    Float32(Float32),
    Float64(Float64),
    Int128(Int64, Int64),
}

impl ConstPoolValue {
    fn size(): Int32 {
        match self {
            ConstPoolValue::Address(address) => 8i32,
            ConstPoolValue::Float64(value) => 8i32,
            ConstPoolValue::Float32(value) => 4i32,
            ConstPoolValue::Int128(lower, upper) => 16i32,
        }
    }
}