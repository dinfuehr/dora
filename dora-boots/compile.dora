fun compile(info: EncodedCompilationInfo) -> Array[UInt8] {
    let info = CompilationInfo(info);
    // bytecodeDump(info.bc);
    CodeGen(info).generate()
}

@internal fun encodedBytecode(fct: String) -> EncodedCompilationInfo;

fun bytecode(fct: String) -> BytecodeFunction {
    let encoded = encodedBytecode(fct);
    BytecodeFunction(encoded.code, decodeConstPool(encoded.constpool), decodeRegisters(encoded.registers), encoded.arguments)
}

class CompilationInfo(encoded: EncodedCompilationInfo) {
    let bc: BytecodeFunction = BytecodeFunction(encoded.code, decodeConstPool(encoded.constpool), decodeRegisters(encoded.registers), encoded.arguments);
}

class EncodedCompilationInfo {
    let code: Array[UInt8] = arrayEmpty[UInt8]();
    let constpool: Array[UInt8] = arrayEmpty[UInt8]();
    let registers: Array[Int32] = arrayEmpty[Int32]();
    let arguments: Int32 = 0;
}

fun decodeRegisters(registers: Array[Int32]) -> Array[BytecodeType] {
    var i = 0L;
    let result = arrayFill[BytecodeType](registers.length().toInt64(), BytecodeType::bool());

    while i < registers.length().toInt64() {
        let regtype = registers(i.toInt32());

        let value = if regtype == BC_TYPE_BOOL {
            BytecodeType::bool()
        } else if regtype == BC_TYPE_U_INT8 {
            BytecodeType::uint8()
        } else if regtype == BC_TYPE_CHAR {
            BytecodeType::char()
        } else if regtype == BC_TYPE_INT32 {
            BytecodeType::int32()
        } else if regtype == BC_TYPE_INT64 {
            BytecodeType::int64()
        } else if regtype == BC_TYPE_FLOAT {
            BytecodeType::float()
        } else if regtype == BC_TYPE_DOUBLE {
            BytecodeType::double()
        } else if regtype == BC_TYPE_PTR {
            BytecodeType::ptr()
        } else {
            unreachable();
            BytecodeType::bool()
        };

        result(i.toInt32()) = value;
        i = i + 1L;
    }

    result
}

fun decodeConstPool(constpool: Array[UInt8]) -> Array[ConstPoolEntry] {
    let constPool = Vec[ConstPoolEntry]();
    let reader = ByteReader(constpool);

    while reader.moreBytes() {
        let opcode = reader.readUInt8().toInt32();

        if opcode == CONSTPOOL_OPCODE_INT32 {
            let value = reader.readInt32();
            constPool.push(ConstPoolInt32(value));
        } else if opcode == CONSTPOOL_OPCODE_INT64 {
            let value = reader.readInt64();
            constPool.push(ConstPoolInt64(value));
        } else if opcode == CONSTPOOL_OPCODE_FLOAT {
            let value = reader.readInt32().asFloat();
            constPool.push(ConstPoolFloat(value));
        } else if opcode == CONSTPOOL_OPCODE_DOUBLE {
            let value = reader.readInt64().asDouble();
            constPool.push(ConstPoolDouble(value));
        } else if opcode == CONSTPOOL_OPCODE_CHAR {
            let value = reader.readInt32().toCharUnchecked();
            constPool.push(ConstPoolChar(value));
        } else if opcode == CONSTPOOL_OPCODE_STRING {
            let length = reader.readInt32();
            let start = reader.offset();
            let value = String::fromBytesPart(constpool, start, length.toInt64()).unwrap();
            constPool.push(ConstPoolString(value));
            reader.skipBytes(length.toInt64());
        } else {
            println("opcode = ${opcode}");
            unreachable();
        }
    }

    constPool.toArray()
}

class ByteReader(let array: Array[UInt8]) {
    var idx: Int64 = 0L;

    fun moreBytes() -> Bool {
        self.idx < self.array.length().toInt64()
    }

    fun readUInt8() -> UInt8 {
        let value = self.array.get(self.idx.toInt32());
        self.idx = self.idx + 1L;
        value
    }

    fun readInt32() -> Int32 {
        let by1 = self.readUInt8().toInt32();
        let by2 = self.readUInt8().toInt32();
        let by3 = self.readUInt8().toInt32();
        let by4 = self.readUInt8().toInt32();

        (by4 << 24) | (by3 << 16) | (by2 << 8) | by1
    }

    fun readInt64() -> Int64 {
        let by1 = self.readUInt8().toInt64();
        let by2 = self.readUInt8().toInt64();
        let by3 = self.readUInt8().toInt64();
        let by4 = self.readUInt8().toInt64();
        let by5 = self.readUInt8().toInt64();
        let by6 = self.readUInt8().toInt64();
        let by7 = self.readUInt8().toInt64();
        let by8 = self.readUInt8().toInt64();

        (by8 << 56) | (by7 << 48) | (by6 << 40) | (by5 << 32) | (by4 << 24) | (by3 << 16) | (by2 << 8) | by1
    }

    fun offset() -> Int64 {
        self.idx
    }

    fun skipBytes(value: Int64) {
        self.idx = self.idx + value;
    }
}