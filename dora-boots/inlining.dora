use package::compilation::CompilationInfo;
use package::graph::{Graph, Op};
use package::graph_builder;
use package::interface as iface;

pub fn performInlining(ci: CompilationInfo, graph: Graph) {
    for block in graph.insertionOrderIterator() {
        for inst in block.instructionsIterator() {
            let op = inst.op();

            if op == Op::InvokeStatic {
                let fctInfo = inst.getFunctionInfo();
                let fctId = fctInfo.fct_id;

                let info = iface::getFunctionInfoForInlining(fctId);

                if info.hasInlineAnnotation {
                    let inlined_function_id = ci.addInlinedFunction(fctId, fctInfo.type_params, inst.getInlinedLocation());
                    let data = iface::getFunctionDataForInlining(fctId);
                    let newBlock = block.splitAfter(inst);
                    let returnValue = graph_builder::addToGraph(graph, inlined_function_id, data.bc, fctInfo.type_params, data.returnType, block, newBlock, inst);
                    if returnValue.isSome() {
                        let returnValue = returnValue.getOrPanic();
                        inst.replaceAllUsesWith(returnValue);
                    }
                    inst.remove();
                    return;
                }
            }
        }
    }
}
