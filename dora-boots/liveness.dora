use std::collections::BitVec;

use package::graph::Graph;

pub fn computeLiveness(graph: Graph) {
    computeLinearOrderIndex(graph);

    for block in graph.postOrderIterator() {
        let live = BitVec::new();

        for successorEdge in block.successors {
            let successor = successorEdge.target;
            let idx = successorEdge.targetIdx;

            for phi in successor.phisIterator() {
                let input = phi.getInput(idx);
                let value = input.getValue();
                live.insert(value.id().toInt64());
                value.usedAt(block.lastInst());
            }
        }

        for successorEdge in block.successors {
            if successorEdge.isBackward() {
                continue;
            }

            let successorLiveIn = successorEdge.target.getLiveIn();
            live.unionWith(successorLiveIn);
        }

        for inst in block.reverseInstructionsIterator() {
            for input in inst.getInputs() {
                let value = input.getValue();
                value.usedAt(inst);

                let id = value.id().toInt64();
                if !live.contains(id) {
                    input.markKill();
                }
                live.insert(id);
            }

            live.remove(inst.id().toInt64());
        }

        for phi in block.phisIterator() {
            live.remove(phi.id().toInt64());
        }

        block.setLiveIn(live);
    }

    for block in graph.reversePostOrderIterator() {
        if !block.isLoopHeader() {
            continue;
        }

        let loopData = block.getLoopData().getOrPanic();
        let liveLoop = block.getLiveIn();

        // A value that is live-in in a loop header, needs to be
        // live through the whole loop.

        for value_id in liveLoop {
            let value = graph.getInstById(value_id.toInt32());

            // Extend live range for each live-in variable up to
            // the last loop back edge.
            for backEdge in loopData.getBackEdges() {
                value.usedInLoop(backEdge.source);
            }
        }

        // A variable which is live-in in the loop header, is also live-in
        // in all blocks of that loop.
        for loopBlockId in loopData.blocks() {
            let loopBlock = graph.getBlockWithId(loopBlockId.toInt32());
            loopBlock.getLiveIn().unionWith(liveLoop);
        }
    }
}

fn computeLinearOrderIndex(graph: Graph) {
    let mut idx = 1i32;

    for block in graph.reversePostOrderIterator() {
        for phi in block.phisIterator() {
            phi.setLinearOrderIndex(idx);
        }

        for inst in block.instructionsIterator() {
            inst.setLinearOrderIndex(idx);
            idx = idx + 1i32;
        }
    }
}
