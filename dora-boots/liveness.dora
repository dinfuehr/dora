use std::collections::BitVec;

use package::graph::Graph;

pub fn computeLiveness(graph: Graph) {
    for block in graph.postOrderIterator() {
        let live = BitVec::new();

        for successorEdge in block.successors {
            let successor = successorEdge.target;
            let idx = successorEdge.targetIdx;

            for phi in successor.phisIterator() {
                let input = phi.getInput(idx);
                live.insert(input.getValue().id().toInt64());
            }
        }

        for successorEdge in block.successors {
            if successorEdge.isBackward() {
                continue;
            }

            let successorLiveIn = successorEdge.target.getLiveIn();
            live.unionWith(successorLiveIn);
        }

        for inst in block.reverseInstructionsIterator() {
            for input in inst.getInputs() {
                let id = input.getValue().id().toInt64();
                if !live.contains(id) {
                    input.markKill();
                }
                live.insert(id);
            }

            live.remove(inst.id().toInt64());
        }

        for phi in block.phisIterator() {
            live.remove(phi.id().toInt64());
        }

        block.setLiveIn(live);
    }

    for block in graph.reversePostOrderIterator() {
        if !block.isLoopHeader() {
            return;
        }

        let loopData = block.getLoopData().getOrPanic();
        let liveLoop = block.getLiveIn();

        for loopBlockId in loopData.blocks() {
            let loopBlock = graph.getBlockWithId(loopBlockId.toInt32());
            loopBlock.getLiveIn().unionWith(liveLoop);
        }
    }
}
