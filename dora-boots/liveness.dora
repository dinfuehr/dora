use std::collections::BitVec;
use std::collections::HashSet;

use package::graph::{Graph, Input};

pub fn computeLiveness(graph: Graph) {
    computeLinearOrderIndex(graph);

    for block in graph.postOrderIterator() {
        let live = BitVec::new();

        for successorEdge in block.successors {
            let successor = successorEdge.target;
            let idx = successorEdge.targetIdx;

            for phi in successor.phisIterator() {
                let input = phi.getInput(idx);
                let value = input.getValue();
                live.insert(value.id().toInt64());
                value.usedAt(block.lastInst());
                value.prependNextUse(input);
            }
        }

        for successorEdge in block.successors {
            if successorEdge.isBackward() {
                continue;
            }

            let successorLiveIn = successorEdge.target.getLiveIn();
            live.unionWith(successorLiveIn);
        }

        for inst in block.reverseInstructionsIterator() {
            for input in inst.getInputs() {
                let value = input.getValue();
                value.usedAt(inst);
                value.prependNextUse(input);

                let id = value.id().toInt64();
                if !live.contains(id) {
                    input.markKill();
                }
                live.insert(id);
            }

            live.remove(inst.id().toInt64());
        }

        for phi in block.phisIterator() {
            live.remove(phi.id().toInt64());
        }

        block.setLiveIn(live);
    }

    for block in graph.reversePostOrderIterator() {
        if !block.isLoopHeader() {
            continue;
        }

        let loopData = block.getLoopData().getOrPanic();
        let liveLoop = block.getLiveIn();

        // A value that is live-in in a loop header, needs to be
        // live through the whole loop.

        for value_id in liveLoop {
            let value = graph.getInstById(value_id.toInt32());

            // Extend live range for each live-in variable up to
            // the last loop back edge.
            for backEdge in loopData.getBackEdges() {
                value.usedInLoop(backEdge.source);
            }
        }

        // A variable which is live-in in the loop header, is also live-in
        // in all blocks of that loop.
        for loopBlockId in loopData.blocks() {
            let loopBlock = graph.getBlockWithId(loopBlockId.toInt32());
            loopBlock.getLiveIn().unionWith(liveLoop);
        }
    }

    for block in graph.reversePostOrderIterator() {
        for inst in block.instructionsIterator() {
            if !inst.hasUses() {
                assert(inst.currentNextUse().isNone());
            } else {
                let mut current = inst.currentNextUse();
                let mut currentIdx = 0i32;
                let inputs = Vec[Input]::new();

                while current.isSome() {
                    let input = current.getOrPanic();
                    inputs.push(input);
                    // Uses should be ordered by the linear order index.
                    assert(currentIdx <= input.getUsedBy().getLinearOrderIndex());
                    current = input.getNextUse();
                    currentIdx = input.getUsedBy().getLinearOrderIndex();
                }

                let mut regularUseCount = 0;

                for _ in inst.uses() {
                    regularUseCount = regularUseCount + 1;
                }

                assert(inputs.size() == regularUseCount);
            }
        }
    }
}

fn computeLinearOrderIndex(graph: Graph) {
    let mut idx = 1i32;

    for block in graph.reversePostOrderIterator() {
        for phi in block.phisIterator() {
            phi.setLinearOrderIndex(idx);
        }

        for inst in block.instructionsIterator() {
            inst.setLinearOrderIndex(idx);
            idx = idx + 1i32;
        }
    }
}
