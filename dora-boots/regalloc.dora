use std::collections::HashMap;

use package::assembler::{RegMap, RegSet, Register};
use package::codegen::CodeGen;
use package::codegen::{emitInst, CodeDescriptor, setLocationConstraints};
use package::graph::{createGotoInst, createMove, Block, Edge, Graph, Inst, Location, LocationData, Op, Operand, opName};

pub fn performRegisterAllocation(graph: Graph, codegen: CodeGen) {
    ensureLocationData(graph, codegen);

    let allocator = SimpleRegisterAllocator::new(graph, codegen);
    allocator.allocateRegisters();

    ssaDestruction(graph, codegen);
}

fn ensureLocationData(graph: Graph, codegen: CodeGen) {
    for block in graph.insertionOrderIterator() {
        for inst in block.phisIterator() {
            setLocationConstraints(codegen, inst);
        }

        for inst in block.instructionsIterator() {
            setLocationConstraints(codegen, inst);
        }
    }
}

class SimpleRegisterAllocator {
    graph: Graph,
    codegen: CodeGen,
    tracker: InstTracker,
    currentSpillSlot: Int32,
    currentInst: Option[Inst],
}

impl SimpleRegisterAllocator {
    static fn new(graph: Graph, codegen: CodeGen): SimpleRegisterAllocator {
        SimpleRegisterAllocator(
            graph,
            codegen,
            InstTracker::new(codegen.allocatableRegisters()),
            0i32,
            None[Inst],
        )
    }

    fn allocateRegisters() {
        for block in self.graph.reversePostOrderIterator() {
            self.initializeInstTracker(block);
            block.setTrackerIn(self.tracker.clone());

            for inst in block.phisIterator() {
                self.allocatePhi(inst);
            }

            for inst in block.instructionsIterator() {
                self.allocateInstruction(inst);
            }

            block.setTrackerOut(self.tracker);
        }
    }

    fn initializeInstTracker(block: Block) {
        self.tracker = InstTracker::new(self.codegen.allocatableRegisters());
    }

    fn allocatePhi(inst: Inst) {
        // pick a register
        let register = self.tracker.allocateRegister(inst).getOrPanic();
        inst.getLocationData().getOutput().setRegister(register);
        self.allocateSpillSlot(inst);
    }

    fn allocateInstruction(inst: Inst) {
        assert(self.tracker.protected.isEmpty());
        self.currentInst = Some(inst);
        self.allocateFixedRegisters(inst);
        self.allocateArbitraryRegisters(inst);
        self.allocateOutputRegister(inst);
        self.allocateSpillSlot(inst);
        self.tracker.protected.clear();
        self.freeDeadValues(inst);
        self.currentInst = None[Inst];
    }

    fn allocateFixedRegisters(inst: Inst) {
        assert(self.tracker.protected.isEmpty());
        let loc = inst.getLocationData();
        
        for input in inst.getInputs() {
            let idx = input.getIdx().toInt64();

            if loc.getInput(idx).hasRegister() {
                let reg = loc.getInput(idx).getRegister();
                self.allocateFixedRegister(reg, input.getValue());
                self.tracker.protect(reg);
            }
        }

        for temp in loc.getTemps() {
            if temp.hasRegister() {
                let reg = temp.getRegister();
                self.allocateFixedTempRegister(reg);
                self.tracker.protect(reg);
            }
        }

        if loc.hasOutput() && loc.getOutput().hasRegister() {
            let reg = loc.getOutput().getRegister();

            if !self.tracker.allocateFixedRegister(reg, inst) {
                self.tracker.freeRegister(reg);
                assert(self.tracker.allocateFixedRegister(reg, inst));
            }

            self.tracker.protect(reg);
        }
    }

    fn allocateArbitraryRegisters(inst: Inst) {
        let loc = inst.getLocationData();

        for input in inst.getInputs() {
            let idx = input.getIdx().toInt64();

            if !loc.getInput(idx).hasRegister() {
                let register = self.allocateArbitraryRegister(input.getValue());
                self.tracker.protect(register);
                loc.getInput(idx).setRegister(register);
            }
        }

        for temp in loc.getTemps() {
            if !temp.hasRegister() {
                let register = self.allocateArbitraryTempRegister();
                self.tracker.protect(register);
                temp.setRegister(register);
            }
        }
    }

    fn allocateOutputRegister(inst: Inst) {
        let loc = inst.getLocationData();

        if loc.hasOutput() {
            let output = loc.getOutput();

            if !output.hasRegister() {
                // pick a register
                let register = self.tracker.allocateRegister(inst);

                if register.isSome() {
                    output.setRegister(register.getOrPanic());
                } else {
                    let register = self.tracker.freeUnprotected();
                    output.setRegister(register);
                }
            }
        }
    }

    fn allocateSpillSlot(inst: Inst) {
        let loc = inst.getLocationData();

        if loc.hasOutput() && !loc.hasSpillSlot() {
            self.currentSpillSlot = self.currentSpillSlot - 8i32;
            let slot = self.currentSpillSlot;
            loc.setSpillSlot(slot);
        }
    }

    fn freeDeadValues(inst: Inst) {
        for input in inst.getInputs() {
            let value = input.getValue();

            if value.getLastUse() === input {
                self.tracker.free(value);
            }
        }

        let loc = inst.getLocationData();

        for temp in loc.getTemps() {
            self.tracker.freeRegister(temp.getRegister());
        }
    }

    fn ensureRegister(value: Inst): Register {
        self.tracker.getRegister(value).getOrPanic()
    }

    fn allocateArbitraryRegister(value: Inst): Register {
        let register = self.tracker.getRegister(value);

        if register.isSome() {
            return register.getOrPanic();
        }

        let register = self.tracker.allocateRegister(value);

        if register.isSome() {
            let register = register.getOrPanic();
            self.emitReloadInst(register, value);
            return register;
        }

        let register = self.tracker.freeUnprotected();
        self.tracker.allocateFixedRegister(register, value);
        self.emitReloadInst(register, value);
        register
    }

    fn emitReloadInst(reg: Register, value: Inst) {
        let slot = value.getLocationData().getSpillSlot();
        let inst = createMove(Operand::Reg(reg), Operand::Stack(slot));
        self.currentInst.getOrPanic().insertBefore(inst);
    }

    fn allocateArbitraryTempRegister(): Register {
        let register = self.tracker.allocateTempRegister();

        if register.isSome() {
            return register.getOrPanic();
        }

        self.tracker.freeUnprotected()
    }

    fn allocateFixedRegister(reg: Register, inst: Inst) {
        let current = self.tracker.getRegister(inst);

        if current.isSome() && current.getOrPanic() == reg {
            return;
        }

        if !self.tracker.allocateFixedRegister(reg, inst) {
            self.tracker.freeRegister(reg);
            assert(self.tracker.allocateFixedRegister(reg, inst));
        }

        let source = if current.isSome() {
            Operand::Reg(current.getOrPanic())
        } else {
            let slot = inst.getLocationData().getSpillSlot();
            Operand::Stack(slot)
        };

        let inst = createMove(Operand::Reg(reg), source);
        self.currentInst.getOrPanic().insertBefore(inst);
    }

    fn allocateFixedTempRegister(reg: Register) {
        if !self.tracker.allocateFixedTempRegister(reg) {
            self.tracker.freeRegister(reg);
            assert(self.tracker.allocateFixedTempRegister(reg));
        }
    }
}

fn ssaDestruction(graph: Graph, codegen: CodeGen) {
    for block in graph.insertionOrderIterator() {
        for predecessorEdge in block.predecessors {
            let predecessor = predecessorEdge.source;
            let moves = ParallelMoveResolver::new();

            let predecessorTracker = predecessor.getTrackerOut();

            for phi in block.phisIterator() {
                let phiDestRegister = phi.getLocationData().getOutput().getRegister();
                let value = phi.getInput(predecessorEdge.targetIdx).getValue();

                // Critical edges should already be split.
                assert(predecessor.successors.size() == 1);

                let valueRegister = predecessorTracker.getRegister(value);

                let value = if valueRegister.isSome() {
                    Operand::Reg(valueRegister.getOrPanic())
                } else {
                    Operand::Stack(value.getLocationData().getSpillSlot())
                };

                moves.addOperand(phiDestRegister, value);
            }

            moves.resolve(codegen.getScratchRegister());
            moves.emitMoves(predecessor);
        }
    }
}

pub class InstTracker {
    allocatable: RegSet,
    free: RegSet,
    protected: RegSet,
    data: RegMap[Inst],
    locations: HashMap[Inst, Register],
}

impl InstTracker {
    static fn new(allocatable: RegSet): InstTracker {
        InstTracker(
            allocatable.clone(),
            allocatable.clone(),
            RegSet::new(),
            RegMap[Inst]::new(allocatable),
            HashMap[Inst, Register]::new(),
        )
    }

    fn getRegister(inst: Inst): Option[Register] {
        self.locations.get(inst)
    }

    fn protect(reg: Register) {
        self.protected.add(reg);
    }

    fn allocateFixedRegister(reg: Register, value: Inst): Bool {
        if self.free.contains(reg) {
            self.free.remove(reg);
            self.data.pick(reg, value);
            self.locations.insert(value, reg);
            true
        } else {
            false
        }
    }

    fn allocateFixedTempRegister(reg: Register): Bool {
        if self.free.contains(reg) {
            self.free.remove(reg);
            true
        } else {
            false
        }
    }

    fn allocateRegister(value: Inst): Option[Register] {
        let result = self.free.first();

        if result.isSome() {
            let reg = result.getOrPanic();
            self.free.remove(reg);
            self.data.pick(reg, value);
            self.locations.insert(value, reg);
        }

        result
    }

    fn allocateTempRegister(): Option[Register] {
        let result = self.free.first();

        if result.isSome() {
            let reg = result.getOrPanic();
            self.free.remove(reg);
        }

        result
    }

    fn free(inst: Inst) {
        let reg = self.getRegister(inst);

        if reg.isSome() {
            let reg = reg.getOrPanic();
            self.free.add(reg);
            self.data.free(reg);
        }

        self.locations.remove(inst);
    }

    fn freeRegister(reg: Register) {
        assert(!self.free.contains(reg));
        assert(!self.protected.contains(reg));
        self.free.add(reg);
        let inst = self.data.free(reg);
        if inst.isSome() {
            self.locations.remove(inst.getOrPanic());
        }
    }

    fn freeUnprotected(): Register {
        assert(self.free.union(self.allocatable).isEmpty());
        let usedButUnprotected = self.allocatable.difference(self.protected);
        let reg = usedButUnprotected.first().getOrPanic();
        self.free.add(reg);
        let inst = self.data.free(reg);
        if inst.isSome() {
            self.locations.remove(inst.getOrPanic());
        }
        reg
    }

    fn clone(): InstTracker {
        InstTracker(
            self.allocatable.clone(),
            self.free.clone(),
            self.protected.clone(),
            self.data.clone(),
            self.locations.clone(),
        )
    }
}

enum InstLocation {
    Register(Register),
    Stack(Int32),
}

impl InstLocation {
    fn isRegister(): Bool {
        match self {
            InstLocation::Register(reg) => true,
            InstLocation::Stack(stack) => false,
        }
    }

    fn toRegister(): Option[Register] {
        match self {
            InstLocation::Register(reg) => Some(reg),
            InstLocation::Stack(stack) => None,
        }
    }
}

class ParallelMoveResolver {
    moves: Vec[(Register, Register)],
    reloads: Vec[(Register, Int32)],
    orderedMoves: Vec[(Operand, Operand)],
    // All written registers.
    directpreds: HashMap[Register, Register],
    // All used variables and their current location.
    locations: HashMap[Register, Register],
    todo: RegSet,
}

impl ParallelMoveResolver {
    static fn new(): ParallelMoveResolver {
        ParallelMoveResolver(
            Vec[(Register, Register)]::new(),
            Vec[(Register, Int32)]::new(),
            Vec[(Operand, Operand)]::new(),
            HashMap[Register, Register]::new(),
            HashMap[Register, Register]::new(),
            RegSet::new(),
        )
    }

    fn add(dest: Register, src: Register) {
        if dest == src { return; }
        self.moves.push((dest, src));
    }

    fn addOperand(dest: Register, src: Operand) {
        match src {
            Operand::None => unreachable[()](),
            Operand::Reg(src) => self.add(dest, src),
            Operand::Stack(slot) => {
                self.reloads.push((dest, slot));
            }
        }
    }

    fn resolve(scratch: Register) {
        for (dest, src) in self.moves {
            assert(!self.directpreds.contains(dest));
            self.directpreds.insert(dest, src);
            self.locations.insert(src, src);
            assert(!self.todo.contains(dest));
            self.todo.add(dest);
        }

        for (dest, src) in self.moves {
            if !self.locations.contains(dest) {
                assert(self.todo.contains(dest));
                self.emitMoveChainStartingAt(dest);
            }
        }

        while !self.todo.isEmpty() {
            let dest = self.todo.first().getOrPanic();
            assert(self.inCycle(dest));
            self.emitOrderedMove(scratch, dest);
            self.locations.insert(dest, scratch);
            self.emitMoveChainStartingAt(dest);
        }

        for (dest, slot) in self.reloads {
            self.orderedMoves.push((Operand::Reg(dest), Operand::Stack(slot)));
        }
    }

    fn inCycle(reg: Register): Bool {
        let start = reg;
        let mut reg = reg;
        assert(self.todo.contains(reg));

        while self.directpreds.contains(reg) {
            reg = self.directpreds.get(reg).getOrPanic();
            assert(self.todo.contains(reg));

            if reg == start {
                return true;
            }
        }

        false
    }

    fn emitMoveChainStartingAt(dest: Register) {
        let mut dest = dest;
        assert(self.todo.contains(dest));

        while self.todo.contains(dest) {
            let original_src = self.directpreds.get(dest).getOrPanic();
            let actual_src = self.locations.get(original_src).getOrPanic();
            self.emitOrderedMove(dest, actual_src);
            self.locations.insert(original_src, dest);
            assert(self.todo.remove(dest));

            if !self.directpreds.contains(original_src) {
                return;
            }

            dest = original_src;
        }
    }

    fn emitOrderedMove(dest: Register, src: Register) {
        self.orderedMoves.push((Operand::Reg(dest), Operand::Reg(src)));
    }

    fn emitMoves(block: Block) {
        for (dest, src) in self.orderedMoves {
            let inst = createMove(dest, src);
            let terminator = block.lastInst();
            assert(terminator.isTerminator());
            terminator.insertBefore(inst);
        }
    }
}

@Test
fn testMovesWithoutDependencies() {
    let moves = ParallelMoveResolver::new();
    moves.add(Register(1u8), Register(0u8));
    moves.add(Register(3u8), Register(2u8));
    moves.resolve(Register(10u8));

    let mut idx = 0;
    for move in moves.orderedMoves {
        assert(move.0.getRegister() == moves.moves(idx).0);
        assert(move.1.getRegister() == moves.moves(idx).1);
        idx = idx + 1;
    }
}

@Test
fn testMovesWithDependency() {
    let moves = ParallelMoveResolver::new();
    moves.add(Register(1u8), Register(0u8));
    moves.add(Register(2u8), Register(1u8));
    moves.resolve(Register(10u8));

    let expected = Array[(Register, Register)]::new(
        (Register(2u8), Register(1u8)),
        (Register(1u8), Register(0u8)),
    );

    let mut idx = 0;
    for move in moves.orderedMoves {
        assert(move.0.getRegister() == expected(idx).0);
        assert(move.1.getRegister() == expected(idx).1);
        idx = idx + 1;
    }
}

@Test
fn testMovesWithCycle() {
    let moves = ParallelMoveResolver::new();
    moves.add(Register(1u8), Register(0u8));
    moves.add(Register(2u8), Register(1u8));
    moves.add(Register(0u8), Register(2u8));
    moves.resolve(Register(3u8));

    let expected = Array[(Register, Register)]::new(
        (Register(3u8), Register(0u8)),
        (Register(0u8), Register(2u8)),
        (Register(2u8), Register(1u8)),
        (Register(1u8), Register(3u8)),
    );

    let mut idx = 0;
    for move in moves.orderedMoves {
        assert(move.0.getRegister() == expected(idx).0);
        assert(move.1.getRegister() == expected(idx).1);
        idx = idx + 1;
    }
}
