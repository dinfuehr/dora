use std::collections::{HashMap, HashSet};

use package::assembler::{FloatRegister, RegMap, RegSet, Register, RegisterType};
use package::codegen::CodeGen;
use package::codegen::{emitInst, setLocationConstraints, STACK_FRAME_ALIGNMENT};
use package::graph::{createGotoInst, createMoveInst, Block, Edge, Graph, Inst, Location, LocationData, Op, Operand, opName, RegisterTrackers, Type};

pub fn performRegisterAllocation(graph: Graph, codegen: CodeGen) {
    ensureLocationData(graph, codegen);

    let allocator = SimpleRegisterAllocator::new(graph, codegen);
    allocator.allocateRegisters();

    ssaDestruction(graph, codegen);
}

fn ensureLocationData(graph: Graph, codegen: CodeGen) {
    for block in graph.insertionOrderIterator() {
        for inst in block.phisIterator() {
            setLocationConstraints(codegen, inst);
        }

        for inst in block.instructionsIterator() {
            setLocationConstraints(codegen, inst);
        }
    }
}

class SimpleRegisterAllocator {
    graph: Graph,
    codegen: CodeGen,
    registers: Option[RegisterTracker[Register]],
    float_registers: Option[RegisterTracker[FloatRegister]],
    currentStackSize: Int32,
    refs: Vec[Int32],
    currentInst: Option[Inst],
}

impl SimpleRegisterAllocator {
    static fn new(graph: Graph, codegen: CodeGen): SimpleRegisterAllocator {
        SimpleRegisterAllocator(
            graph,
            codegen,
            None[RegisterTracker[Register]],
            None[RegisterTracker[FloatRegister]],
            0i32,
            Vec[Int32]::new(),
            None[Inst],
        )
    }

    fn allocateRegisters() {
        for block in self.graph.reversePostOrderIterator() {
            self.allocateBlock(block);
        }

        let stack_alignment = STACK_FRAME_ALIGNMENT.toInt32();
        self.currentStackSize = (self.currentStackSize + (stack_alignment - 1i32)) & stack_alignment;
        self.graph.setStackSize(self.currentStackSize);
    }

    fn allocateBlock(block: Block) {
        self.initializeRegisters(block);
        block.setTrackerIn(self.snapshotRegisters());

        for inst in block.phisIterator() {
            self.allocatePhi(inst);
        }

        for inst in block.instructionsIterator() {
            self.allocateInstruction(inst);
        }

        block.setTrackerOut(self.snapshotRegisters());
    }

    fn snapshotRegisters(): RegisterTrackers {
        RegisterTrackers(self.registers().clone(), self.float_registers().clone())
    }

    fn initializeRegisters(block: Block) {
        self.registers = Some(RegisterTracker[Register]::new(self.codegen.allocatableRegisters()));
        self.float_registers = Some(RegisterTracker[FloatRegister]::new(self.codegen.allocatableFloatRegisters()));

        if block.isLoopHeader() {
            // For now everything is spilled at the beginning of a loop.
            for id in block.getLiveIn() {
                let inst = self.graph.getInstById(id.toInt32());
                self.spill(inst);
            }
        } else {
            let candidates = HashMap[Inst, Int64]::new();
            let all = HashMap[Inst, Register]::new();
            let predecessorCount = block.predecessors.size();

            for predecessorEdge in block.predecessors {
                let predecessor = predecessorEdge.source;
                let predecessorTracker = predecessor.getTrackerOut().general;

                for (reg, inst) in predecessorTracker.data {
                    if !block.getLiveIn().contains(inst.id().toInt64()) {
                        continue;
                    }

                    let current = candidates.get(inst);
                    let current = if current.isSome() {
                        current.getOrPanic() + 1
                    } else {
                        1
                    };
                    if current == predecessorCount {
                        assert(all.insert(inst, reg).isNone());
                    }
                    candidates.insert(inst, current);
                }
            }

            for (inst, reg) in all {
                assert(self.registers().allocateFixedRegister(reg, inst));
            }

            for id in block.getLiveIn() {
                let inst = self.graph.getInstById(id.toInt32());
                if all.contains(inst) {
                    continue;
                }
                self.spill(inst);
            }
        }
    }

    fn allocatePhi(inst: Inst) {
        let register = self.registers().allocateRegister(inst);

        if register.isSome() {
            let loc = inst.getLocationData();
            loc.getOutput().setRegister(register.getOrPanic());
        } else {
            self.spill(inst);
        }
    }

    fn allocateInstruction(inst: Inst) {
        assert(self.registers().protected.isEmpty());
        assert(self.float_registers().protected.isEmpty());

        self.currentInst = Some(inst);
        self.allocateFixedRegisters(inst);
        self.allocateArbitraryRegisters(inst);

        if inst.isCall() {
            self.spillAndResetLiveRegisters();
        }

        self.allocateOutputRegister(inst);

        self.registers().protected.clear();
        self.float_registers().protected.clear();

        self.freeDeadValues(inst);
        self.currentInst = None[Inst];
    }

    fn spillAndResetLiveRegisters() {
        for (reg, inst) in self.registers().data {
            self.spill(inst);
            self.registers().freeRegisterRaw(reg);
        }
    }

    fn allocateFixedRegisters(inst: Inst) {
        assert(self.registers().protected.isEmpty());
        let loc = inst.getLocationData();
        
        for input in inst.getInputs() {
            let idx = input.getIdx().toInt64();

            if loc.getInput(idx).hasRegister() {
                let reg = loc.getInput(idx).getRegister();
                self.allocateFixedRegister(reg, input.getValue());
                self.registers().protect(reg);
            }
        }

        for temp in loc.getTemps() {
            if temp.hasRegister() {
                let reg = temp.getRegister();
                self.allocateFixedTempRegister(reg);
                self.registers().protect(reg);
            }
        }
    }

    fn yieldRegister(reg: Register) {
        let inst = self.registers().data.get(reg).getOrPanic();
        let newReg = self.registers().allocateRegister(inst);

        if newReg.isSome() {
            let newReg = newReg.getOrPanic();
            let inst = createMoveInst(inst.getValueType(), Operand::Reg(newReg), Operand::Reg(reg));
            self.currentInst.getOrPanic().insertBefore(inst);
        } else {
            self.spill(inst);
        }
    }

    fn allocateArbitraryRegisters(inst: Inst) {
        let loc = inst.getLocationData();

        for input in inst.getInputs() {
            let idx = input.getIdx().toInt64();

            if loc.getInput(idx).isNone() {
                let register = self.allocateArbitraryRegister(input.getValue());
                self.registers().protect(register);
                loc.getInput(idx).setRegister(register);
            }
        }

        for temp in loc.getTemps() {
            if !temp.hasRegister() {
                let register = self.allocateArbitraryTempRegister();
                self.registers().protect(register);
                temp.setRegister(register);
            }
        }
    }

    fn allocateOutputRegister(inst: Inst) {
        let loc = inst.getLocationData();

        if !loc.hasOutput() {
            return;
        }

        let output = loc.getOutput();

        if output.hasRegister() {
            let reg = loc.getOutput().getRegister();

            if !self.registers().allocateFixedRegister(reg, inst) {
                self.yieldRegister(reg);
                self.registers().freeRegister(reg);
                assert(self.registers().allocateFixedRegister(reg, inst));
            }

            self.registers().protect(reg);
        } else if output.hasFloatRegister() {
            let reg = loc.getOutput().getFloatRegister();

            if !self.float_registers().allocateFixedRegister(reg, inst) {
                unimplemented();
            }

            self.float_registers().protect(reg);
        } else if inst.getValueType().isAnyFloat() {
            let register = self.float_registers().allocateRegister(inst).getOrPanic();
            output.setFloatRegister(register);
        } else {
            // pick a register
            let register = self.registers().allocateRegister(inst);

            if register.isSome() {
                output.setRegister(register.getOrPanic());
            } else {
                let (register, instInReg) = self.registers().freeUnprotected();
                self.spill(instInReg);
                output.setRegister(register);
            }
        }
    }

    fn spill(inst: Inst) {
        let loc = inst.getLocationData();
        assert(loc.hasOutput());

        if !loc.hasSpillSlot() {
            let slot = self.allocateSpillSlot(inst.getValueType());
            loc.setSpillSlot(slot);
        }

        assert(loc.hasSpillSlot());
    }

    fn allocateSpillSlot(ty: Type): Int32 {
        let (size, alignment) = match ty {
            Type::Bool => (1i32, 1i32),
            Type::Int32 => (4i32, 4i32),
            Type::Ptr | Type::Int64 => (8i32, 8i32),
            _ => unreachable[(Int32, Int32)](),
        };

        self.currentStackSize = (self.currentStackSize + (alignment - 1i32)) & alignment;
        self.currentStackSize = self.currentStackSize + size;

        let offset = -self.currentStackSize;

        if ty == Type::Ptr {
            self.refs.push(offset);
        }

        offset
    }

    fn freeDeadValues(inst: Inst) {
        let loc = inst.getLocationData();

        for temp in loc.getTemps() {
            self.registers().freeRegister(temp.getRegister());
        }
    }

    fn allocateArbitraryRegister(value: Inst): Register {
        let register = self.registers().getRegister(value);

        if register.isSome() {
            return register.getOrPanic();
        }

        let register = self.registers().allocateRegister(value);

        if register.isSome() {
            let register = register.getOrPanic();
            self.emitReloadInst(register, value);
            return register;
        }

        let (register, instInReg) = self.registers().freeUnprotected();
        self.spill(instInReg);
        self.registers().allocateFixedRegister(register, value);
        self.emitReloadInst(register, value);
        register
    }

    fn emitReloadInst(reg: Register, value: Inst) {
        let slot = value.getLocationData().getSpillSlot();
        let inst = createMoveInst(value.getValueType(), Operand::Reg(reg), Operand::Stack(slot));
        self.currentInst.getOrPanic().insertBefore(inst);
    }

    fn allocateArbitraryTempRegister(): Register {
        let register = self.registers().allocateTempRegister();

        if register.isSome() {
            return register.getOrPanic();
        }

        let (register, instInReg) = self.registers().freeUnprotected();
        self.spill(instInReg);

        register
    }

    fn allocateFixedRegister(reg: Register, inst: Inst) {
        let current = self.registers().getRegister(inst);

        if current.isSome() && current.getOrPanic() == reg {
            return;
        }

        if !self.registers().allocateFixedRegister(reg, inst) {
            self.yieldRegister(reg);
            self.registers().freeRegister(reg);
            assert(self.registers().allocateFixedRegister(reg, inst));
        }

        let source = if current.isSome() {
            Operand::Reg(current.getOrPanic())
        } else {
            let slot = inst.getLocationData().getSpillSlot();
            Operand::Stack(slot)
        };

        let inst = createMoveInst(inst.getValueType(), Operand::Reg(reg), source);
        self.currentInst.getOrPanic().insertBefore(inst);
    }

    fn allocateFixedTempRegister(reg: Register) {
        if !self.registers().allocateFixedTempRegister(reg) {
            self.yieldRegister(reg);
            self.registers().freeRegister(reg);
            assert(self.registers().allocateFixedTempRegister(reg));
        }
    }

    fn registers(): RegisterTracker[Register] {
        self.registers.getOrPanic()
    }

    fn float_registers(): RegisterTracker[FloatRegister] {
        self.float_registers.getOrPanic()
    }
}

fn ssaDestruction(graph: Graph, codegen: CodeGen) {
    for block in graph.insertionOrderIterator() {
        for predecessorEdge in block.predecessors {
            let predecessor = predecessorEdge.source;
            let moves = ParallelMoveResolver::new();

            let blockTracker = block.getTrackerIn().general;
            let predecessorTracker = predecessor.getTrackerOut().general;

            for (reg, inst) in blockTracker.data {
                let instRegister = predecessorTracker.getRegister(inst);

                let value = if instRegister.isSome() {
                    Operand::Reg(instRegister.getOrPanic())
                } else {
                    Operand::Stack(inst.getLocationData().getSpillSlot())
                };

                moves.add(inst.getValueType(), Operand::Reg(reg), value);
            }

            for phi in block.phisIterator() {
                // Critical edges should already be split.
                assert(predecessor.successors.size() == 1);

                let loc = phi.getLocationData();
                let dest = if loc.hasSpillSlot() {
                    Operand::Stack(loc.getSpillSlot())
                } else {
                    Operand::Reg(loc.getOutput().getRegister())
                };

                let value = phi.getInput(predecessorEdge.targetIdx).getValue();
                let valueRegister = predecessorTracker.getRegister(value);

                let value = if valueRegister.isSome() {
                    Operand::Reg(valueRegister.getOrPanic())
                } else {
                    Operand::Stack(value.getLocationData().getSpillSlot())
                };

                moves.add(phi.getValueType(), dest, value);
            }

            moves.resolve(codegen.getScratchRegister());
            moves.emitMoves(predecessor);
        }
    }
}

pub class RegisterTracker[T: RegisterType] {
    allocatable: RegSet[T],
    free: RegSet[T],
    protected: RegSet[T],
    data: RegMap[T, Inst],
    locations: HashMap[Inst, T],
}

impl[T: RegisterType] RegisterTracker[T] {
    static fn new(allocatable: RegSet[T]): RegisterTracker[T] {
        RegisterTracker(
            allocatable.clone(),
            allocatable.clone(),
            RegSet[T]::new(),
            RegMap[T, Inst]::new(allocatable),
            HashMap[Inst, T]::new(),
        )
    }

    fn getRegister(inst: Inst): Option[T] {
        self.locations.get(inst)
    }

    fn protect(reg: T) {
        self.protected.add(reg);
    }

    fn allocateFixedRegister(reg: T, value: Inst): Bool {
        if self.free.contains(reg) {
            self.free.remove(reg);
            self.data.pick(reg, value);
            self.locations.insert(value, reg);
            true
        } else {
            false
        }
    }

    fn allocateFixedTempRegister(reg: T): Bool {
        if self.free.contains(reg) {
            self.free.remove(reg);
            true
        } else {
            false
        }
    }

    fn allocateRegister(value: Inst): Option[T] {
        let result = self.free.first();

        if result.isSome() {
            let reg = result.getOrPanic();
            self.free.remove(reg);
            self.data.pick(reg, value);
            self.locations.insert(value, reg);
        }

        result
    }

    fn allocateTempRegister(): Option[T] {
        let result = self.free.first();

        if result.isSome() {
            let reg = result.getOrPanic();
            self.free.remove(reg);
        }

        result
    }

    fn free(inst: Inst) {
        let reg = self.getRegister(inst);

        if reg.isSome() {
            let reg = reg.getOrPanic();
            self.free.add(reg);
            self.data.free(reg);
        }

        self.locations.remove(inst);
    }

    fn freeRegister(reg: T) {
        assert(!self.protected.contains(reg));
        self.freeRegisterRaw(reg);
    }

    fn freeRegisterRaw(reg: T) {
        assert(!self.free.contains(reg));
        self.free.add(reg);
        let inst = self.data.free(reg);
        if inst.isSome() {
            self.locations.remove(inst.getOrPanic());
        }
    }

    fn freeUnprotected(): (T, Inst) {
        assert(self.free.intersect(self.allocatable).isEmpty());
        let usedButUnprotected = self.allocatable.difference(self.protected);
        let reg = usedButUnprotected.first().getOrPanic();
        self.free.add(reg);
        let inst = self.data.free(reg).getOrPanic();
        self.locations.remove(inst);
        (reg, inst)
    }

    fn clone(): RegisterTracker[T] {
        RegisterTracker(
            self.allocatable.clone(),
            self.free.clone(),
            self.protected.clone(),
            self.data.clone(),
            self.locations.clone(),
        )
    }
}

struct Move {
    ty: Type,
    dest: Operand,
    src: Operand,
}

class ParallelMoveResolver {
    moves: Vec[Move],
    orderedMoves: Vec[Move],
    types: HashMap[Operand, Type],
    // All written registers.
    directpreds: HashMap[Operand, Operand],
    // All used variables and their current location.
    locations: HashMap[Operand, Operand],
    todo: HashSet[Operand],
}

impl ParallelMoveResolver {
    static fn new(): ParallelMoveResolver {
        ParallelMoveResolver(
            Vec[Move]::new(),
            Vec[Move]::new(),
            HashMap[Operand, Type]::new(),
            HashMap[Operand, Operand]::new(),
            HashMap[Operand, Operand]::new(),
            HashSet[Operand]::new(),
        )
    }

    fn add(ty: Type, dest: Operand, src: Operand) {
        if dest == src { return; }
        self.moves.push(Move(ty, dest, src));
    }

    fn resolve(scratch: Register) {
        for move in self.moves {
            let ty = move.ty;
            let dest = move.dest;
            let src = move.src;

            assert(!self.directpreds.contains(dest));
            self.directpreds.insert(dest, src);
            self.locations.insert(src, src);
            self.types.insert(dest, ty);
            assert(!self.todo.contains(dest));
            self.todo.insert(dest);
        }

        for move in self.moves {
            let ty = move.ty;
            let dest = move.dest;
            let src = move.src;

            if !self.locations.contains(dest) {
                assert(self.todo.contains(dest));
                self.emitMoveChainAt(dest);
            }
        }

        while !self.todo.isEmpty() {
            let dest = self.todo.makeIterator().next().getOrPanic();
            let ty = self.types.get(dest).getOrPanic();
            assert(self.inCycle(dest));
            let scratch = Operand::Reg(scratch);
            self.emitOrderedMove(ty, scratch, dest);
            self.locations.insert(dest, scratch);
            self.emitMoveChainAt(dest);
        }
    }

    fn inCycle(opnd: Operand): Bool {
        let start = opnd;
        let mut opnd = opnd;
        assert(self.todo.contains(opnd));

        while self.directpreds.contains(opnd) {
            opnd = self.directpreds.get(opnd).getOrPanic();
            assert(self.todo.contains(opnd));

            if opnd == start {
                return true;
            }
        }

        false
    }

    fn emitMoveChainAt(dest: Operand) {
        let mut dest = dest;
        let ty = self.types.get(dest).getOrPanic();
        assert(self.todo.contains(dest));

        while self.todo.contains(dest) {
            let original_src = self.directpreds.get(dest).getOrPanic();
            let actual_src = self.locations.get(original_src).getOrPanic();
            self.emitOrderedMove(ty, dest, actual_src);
            self.locations.insert(original_src, dest);
            assert(self.todo.remove(dest));

            if !self.directpreds.contains(original_src) {
                return;
            }

            dest = original_src;
        }
    }

    fn emitOrderedMove(ty: Type, dest: Operand, src: Operand) {
        self.orderedMoves.push(Move(ty, dest, src));
    }

    fn emitMoves(block: Block) {
        for move in self.orderedMoves {
            let inst = createMoveInst(move.ty, move.dest, move.src);
            let terminator = block.lastInst();
            assert(terminator.isTerminator());
            terminator.insertBefore(inst);
        }
    }
}

@Test
fn testMovesWithoutDependencies() {
    let moves = ParallelMoveResolver::new();
    moves.add(Type::Int64, r(1), r(0));
    moves.add(Type::Int64, r(3), r(2));
    moves.resolve(Register(10u8));

    expectMoves(moves, moves.moves.toArray());
}

@Test
fn testRegisterMovesWithDependency() {
    let moves = ParallelMoveResolver::new();
    moves.add(Type::Int64, r(1), r(0));
    moves.add(Type::Int64, r(2), r(1));
    moves.resolve(Register(10u8));

    expectMoves(moves, Array[Move]::new(
        Move(Type::Int64, r(2), r(1)),
        Move(Type::Int64, r(1), r(0)),
    ));
}

@Test
fn testMovesWithDependency() {
    let moves = ParallelMoveResolver::new();
    moves.add(Type::Int32, s(1), r(0));
    moves.add(Type::Int32, r(2), s(1));
    moves.resolve(Register(10u8));

    expectMoves(moves, Array[Move]::new(
        Move(Type::Int32, r(2), s(1)),
        Move(Type::Int32, s(1), r(0)),
    ));
}

@Test
fn testRegisterMovesWithCycle() {
    let moves = ParallelMoveResolver::new();
    moves.add(Type::Int64, r(1), r(0));
    moves.add(Type::Int64, r(2), r(1));
    moves.add(Type::Int64, r(0), r(2));
    moves.resolve(Register(100u8));

    expectMoves(moves, Array[Move]::new(
        Move(Type::Int64, r(100), r(2)),
        Move(Type::Int64, r(2), r(1)),
        Move(Type::Int64, r(1), r(0)),
        Move(Type::Int64, r(0), r(100)),
    ));
}

@Test
fn testStackMovesWithCycle() {
    let moves = ParallelMoveResolver::new();
    moves.add(Type::Int64, s(1), s(0));
    moves.add(Type::Int64, s(2), s(1));
    moves.add(Type::Int64, s(0), s(2));
    moves.resolve(Register(100u8));

    expectMoves(moves, Array[Move]::new(
        Move(Type::Int64, r(100), s(2)),
        Move(Type::Int64, s(2), s(1)),
        Move(Type::Int64, s(1), s(0)),
        Move(Type::Int64, s(0), r(100)),
    ));
}

fn expectMoves(moves: ParallelMoveResolver, expected: Array[Move]) {
    let mut idx = 0;
    assert(moves.orderedMoves.size() == expected.size());
    for move in moves.orderedMoves {
        let exp = expected(idx);
        assert(move.ty == exp.ty);
        assert(move.dest == exp.dest);
        assert(move.src == exp.src);
        idx = idx + 1;
    }
}

fn r(value: Int64): Operand {
    Operand::Reg(Register(value.toUInt8()))
}

fn s(value: Int64): Operand {
    Operand::Stack(value.toInt32())
}
