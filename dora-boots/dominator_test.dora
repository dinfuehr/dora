fun assertDominatedBlocks(fct: BytecodeFunction, idoms: Int32...) {
    let graph = createGraph(fct);
    graph.buildDominatorTree();

    assert(graph.getEntryBlock().getDominator().isNone());

    for (idx, expectedDominatorId) in idoms.enumerate() {
        // Block 0 is entry block and idoms doesn't contain that block so skip it.
        let block = graph.getBlockWithId(idx.toInt32() + 1I);

        let dominator = block.getDominator();

        if dominator.isNone() {
            println("block ${idx}: missing dominator, expected ${expectedDominatorId}");
        } else if dominator.getOrPanic().id != expectedDominatorId {
            println("block ${idx}: idom is ${dominator.getOrPanic().id}, expected ${expectedDominatorId}");
            println(dumpGraph(graph));
        }

        assert(dominator.getOrPanic().id == expectedDominatorId);
    }
}

@test fun testDominatorRetVoid(_x: Testing) {
    let writer = BytecodeWriter();
    writer.emitRetVoid();
    let fct = writer.generate();

    assertDominatedBlocks(fct);
}

@test fun testDominatorEmptyBlocks(_x: Testing) {
    let writer = BytecodeWriter();
    let next = writer.createLabel();
    writer.emitJump(next);
    writer.bindLabel(next);
    let next = writer.createLabel();
    writer.emitJump(next);
    writer.bindLabel(next);
    writer.emitRetVoid();
    let fct = writer.generate();

    assertDominatedBlocks(fct, 0I, 1I);
}

@test fun testDominatorSimple(_x: Testing) {
    let writer = BytecodeWriter();
    let arg0 = writer.addRegister(BytecodeType::Bool);
    writer.setArguments(1I);
    let elseBlock = writer.createLabel();
    writer.emitJumpIfFalse(arg0, elseBlock);
    let returnBlock = writer.createLabel();
    writer.emitJump(returnBlock);
    writer.bindLabel(elseBlock);
    writer.emitJump(returnBlock);
    writer.bindLabel(returnBlock);
    writer.emitRetVoid();
    let fct = writer.generate();

    assertDominatedBlocks(fct, 0I, 0I, 0I);
}

@test fun testDominatorIfReturnInBothBranches(_x: Testing) {
    let fct = getBytecodeFunctionByName("bcSsaGenIfReturnInBothBranches");
    let graph = createGraph(fct);
    graph.buildDominatorTree();

    let condBlock = graph.getBlockWithId(0I);
    let thenBlock = graph.getBlockWithId(1I);
    let elseBlock = graph.getBlockWithId(2I);

    assert(condBlock.getDominator().isNone());
    assert(condBlock.getDominatedBlocks().size() == 2L);

    assert(thenBlock.getDominator().getOrPanic() === condBlock);
    assert(thenBlock.getDominatedBlocks().size() == 0L);

    assert(elseBlock.getDominator().getOrPanic() === condBlock);
    assert(elseBlock.getDominatedBlocks().size() == 0L);
}

@test fun testDominatorWhileCountDown(_x: Testing) {
    let fct = getBytecodeFunctionByName("bcSsaGenWhileCountDown");
    let graph = createGraph(fct);
    graph.buildDominatorTree();

    let varBlock = graph.getBlockWithId(0I);
    let whileHeader = graph.getBlockWithId(1I);
    let whileBody = graph.getBlockWithId(3I);
    let returnBlock = graph.getBlockWithId(2I);

    assert(varBlock.getDominator().isNone());

    assert(whileHeader.getDominator().getOrPanic() === varBlock);
    assert(whileHeader.getDominatedBlocks().size() == 2L);

    assert(whileBody.getDominator().getOrPanic() === whileHeader);
    assert(whileBody.getDominatedBlocks().size() == 0L);

    assert(returnBlock.getDominator().getOrPanic() === whileHeader);
    assert(returnBlock.getDominatedBlocks().size() == 0L);
}
