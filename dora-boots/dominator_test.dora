use package::bytecode::builder::BytecodeBuilder;
use package::bytecode::data::BytecodeFunction;
use package::bytecode::data::BytecodeType;
use package::compilation::CompilationInfo;
use package::graph_builder;
use package::graph::{Block, Graph};
use package::graph::dump::dumpGraph;
use package::interface::Architecture;

fn createGraph(fct: BytecodeFunction): Graph {
    let ci = CompilationInfo::newForTesting(fct, Array[BytecodeType]::new());
    graph_builder::createGraph(ci)
}

fn assertDominatedBlocks(fct: BytecodeFunction, idoms: Int32...) {
    let graph = createGraph(fct);
    graph.buildDominatorTree();

    let entry = graph.getEntryBlock();
    assert(entry.getDominator().isNone());
    assert(entry.id() == 0i32);

    assert(idoms.size() == graph.blockCount().toInt64() - 1);

    for (idx, expectedDominatorId) in idoms.enumerate() {
        // Block 0 is entry block and idoms doesn't contain that block so skip it.
        let block = graph.getBlockWithId(idx.toInt32() + 1i32);

        let dominator = block.getDominator();

        if dominator.isNone() {
            println("block ${idx}: missing dominator, expected ${expectedDominatorId}");
        } else if dominator.getOrPanic().id() != expectedDominatorId {
            println("block ${idx}: idom is ${dominator.getOrPanic().id()}, expected ${expectedDominatorId}");
            println(dumpGraph(None[CompilationInfo], graph, Architecture::Arm64));
        }

        assert(dominator.getOrPanic().id() == expectedDominatorId);
    }
}

@Test
fn testDominatorRet() {
    let writer = BytecodeBuilder::new();
    let regUnit = writer.addRegister(BytecodeType::Unit);
    writer.emitRet(regUnit);
    let fct = writer.generate();

    assertDominatedBlocks(fct, 0i32);
}

@Test
fn testDominatorEmptyBlocks() {
    let writer = BytecodeBuilder::new();
    let regUnit = writer.addRegister(BytecodeType::Unit);
    let next = writer.createLabel();
    writer.emitJump(next);
    writer.bindLabel(next);
    let next = writer.createLabel();
    writer.emitJump(next);
    writer.bindLabel(next);
    writer.emitRet(regUnit);
    let fct = writer.generate();

    assertDominatedBlocks(fct, 0i32, 1i32, 2i32);
}

@Test
fn testDominatorSimple() {
    let writer = BytecodeBuilder::new();
    let arg0 = writer.addRegister(BytecodeType::Bool);
    writer.setArguments(1i32);
    let regUnit = writer.addRegister(BytecodeType::Unit);
    let elseBlock = writer.createLabel();
    writer.emitJumpIfFalse(arg0, elseBlock);
    let returnBlock = writer.createLabel();
    writer.emitJump(returnBlock);
    writer.bindLabel(elseBlock);
    writer.emitJump(returnBlock);
    writer.bindLabel(returnBlock);
    writer.emitRet(regUnit);
    let fct = writer.generate();

    assertDominatedBlocks(fct, 0i32, 1i32, 1i32, 1i32);
}
