pub mod arm64;
pub mod x64;

class AssemblerBuffer {
    buffer: Vec[UInt8],
    pos: Int64,
}

impl AssemblerBuffer {
    static fn new(): AssemblerBuffer {
        AssemblerBuffer(Vec[UInt8]::new(), 0)
    }

    fn position(): Int64 {
        self.pos
    }

    fn setPosition(newpos: Int64) {
        self.pos = newpos;
    }

    fn emitByte(value: UInt8) {
        if self.pos == self.buffer.size() {
            self.buffer.push(value);
        } else {
            self.buffer(self.pos) = value;
        }

        self.pos = self.pos + 1;
    }

    fn emitInt32(value: Int32) {
        self.emitByte((value & 0xFFi32).toUInt8());
        self.emitByte(((value >>> 8i32) & 0xFFi32).toUInt8());
        self.emitByte(((value >>> 16i32) & 0xFFi32).toUInt8());
        self.emitByte(((value >>> 24i32) & 0xFFi32).toUInt8());
    }

    fn emitInt64(value: Int64) {
        self.emitInt32(value.toInt32());
        self.emitInt32((value >>> 32i32).toInt32());
    }

    fn patchUInt8(offset: Int64, value: UInt8) {
        self.buffer(offset) = value;
    }

    fn patchInt32(offset: Int64, value: Int32) {
        self.buffer(offset) = (value & 0xFFi32).toUInt8();
        self.buffer(offset + 1i64) = ((value >>> 8i32) & 0xFFi32).toUInt8();
        self.buffer(offset + 2i64) = ((value >>> 16i32) & 0xFFi32).toUInt8();
        self.buffer(offset + 3i64) = ((value >>> 24i32) & 0xFFi32).toUInt8();
    }

    fn size(): Int64 {
        self.buffer.size()
    }

    fn capacity(): Int64 {
        self.buffer.capacity()
    }

    fn toArray(): Array[UInt8] {
        self.buffer.toArray()
    }

    fn createLabel(): Label {
        Label::new()
    }

    fn bindLabel(lbl: Label) {
        lbl.bindTo(self.size());
    }

    fn createAndBindLabel(): Label {
        let lbl = self.createLabel();
        self.bindLabel(lbl);

        lbl
    }
}

pub class Label {
    offset: Int64
}

impl Label {
    static fn new(): Label {
        Label(-1)
    }

    fn bindTo(pos: Int64) {
        assert(pos >= 0i64 && self.offset < 0i64);
        self.offset = pos;
    }

    fn isBound(): Bool {
        self.offset >= 0i64
    }
}

@Test
fn testAssemblerBufferEmitByte() {
    let buffer = AssemblerBuffer::new();
    buffer.emitByte(0x01u8);
    buffer.emitByte(0x02u8);
    assert(buffer.size() == 2i64);
}

@Test
fn testAssemblerBufferEmitInt() {
    let asm = AssemblerBuffer::new();
    asm.emitInt32(0x11223344i32);
    let buffer = asm.toArray();
    assert(buffer(0i64) == 0x44u8);
    assert(buffer(1i64) == 0x33u8);
    assert(buffer(2i64) == 0x22u8);
    assert(buffer(3i64) == 0x11u8);
    assert(buffer.size() == 4i64);
}

pub struct Register(value: UInt8)

impl Register {
    fn equals(rhs: Register): Bool {
        self.value == rhs.value
    }
}

class MachineCode {
    bytes: Array[UInt8],
    start: Int64,
}

impl MachineCode {
    static fn new(bytes: Array[UInt8]): MachineCode {
        MachineCode(bytes, 0)
    }

    fn getInt32(idx: Int64): Int32 {
        self.bytes(idx).toInt32() |
            self.bytes(idx+1i64).toInt32() << 8i32 |
            self.bytes(idx+2i64).toInt32() << 16i32 |
            self.bytes(idx+3i64).toInt32() << 24i32
    }
}

pub class RegMap[V] {
    all: Int64,
    value: Int64,
    data: Array[Option[V]],
}

impl[V] RegMap[V] {
    pub static fn new(rs: RegSet): RegMap[V] {
        RegMap(
            rs.value,
            0,
            Array[Option[V]]::fill(64, None[V])
        )
    }

    pub fn acquire(value: V): Option[Register] {
        let available = !self.value & self.all;
        let idx = available.countZeroBitsTrailing();

        if idx == 64i32 {
            None[Register]
        } else {
            self.value = self.value & !(1 << idx);
            self.data(idx.toInt64()) = Some[V](value);
            Some[Register](Register(idx.toUInt8()))
        }
    }

    pub fn remove(reg: Register) {
        let value = reg.value.toInt32();
        assert(value < 64i32);
        self.value = self.value & !(1 << value);
        self.data(reg.value.toInt64()) = None[V];
    }
}

pub class RegSet {
    value: Int64,
}

impl RegSet {
    pub static fn new(registers: Register...): RegSet {
        let rs = RegSet(0);

        for reg in registers {
            rs.add(reg);
        }

        rs
    }

    pub fn add(reg: Register) {
        let value = reg.value.toInt32();
        assert(value < 64i32);
        self.value = self.value | (1 << value);
    }

    pub fn contains(reg: Register): Bool {
        let value = reg.value.toInt32();
        assert(value < 64i32);
        (self.value & (1 << value)) != 0
    }

    pub fn remove(reg: Register) {
        let value = reg.value.toInt32();
        assert(value < 64i32);
        self.value = self.value & !(1 << value);
    }

    pub fn acquire(): Option[Register] {
        let idx = self.value.countZeroBitsTrailing();

        if idx == 64i32 {
            None[Register]
        } else {
            self.value = self.value & !(1 << idx);
            Some[Register](Register(idx.toUInt8()))
        }
    }

    pub fn equals(other: RegSet): Bool {
        self.value == other.value
    }
}
